{
  "metadata": {
    "description": "OpenSCAD Training Data for fine-tuning LLM",
    "version": "1.0",
    "date": "2025-03-16T14:29:09.816Z",
    "source": "https://openscad.org/cheatsheet/ and https://en.wikibooks.org/wiki/OpenSCAD_User_Manual"
  },
  "cheatSheet": {
    "syntax": [
      {
        "name": "var = value;",
        "description": "Syntax element",
        "links": [
          {
            "text": "var",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/General#Variables"
          },
          {
            "text": "value",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/General#Values_and_Data_Types"
          }
        ]
      },
      {
        "name": "var = cond ? value_if_true : value_if_false;",
        "description": "Syntax element",
        "links": [
          {
            "text": "var",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/General#Variables"
          },
          {
            "text": "?",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Conditional_and_Iterator_Functions#Conditional_?_:"
          },
          {
            "text": ":",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Conditional_and_Iterator_Functions#Conditional_?_:"
          }
        ]
      },
      {
        "name": "var = function (x) x + x;",
        "description": "Syntax element",
        "links": [
          {
            "text": "var",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/General#Variables"
          },
          {
            "text": "function",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/User-Defined_Functions_and_Modules#Function_Literals"
          }
        ]
      },
      {
        "name": "module name(…) { … }\n        name();",
        "description": "Syntax element",
        "links": [
          {
            "text": "module",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/User-Defined_Functions_and_Modules#Modules"
          }
        ]
      },
      {
        "name": "function name(…) = …\n        name();",
        "description": "Syntax element",
        "links": [
          {
            "text": "function",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/User-Defined_Functions_and_Modules#Functions"
          }
        ]
      },
      {
        "name": "include <….scad>",
        "description": "Syntax element",
        "links": [
          {
            "text": "include",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Include_Statement"
          }
        ]
      },
      {
        "name": "use <….scad>",
        "description": "Syntax element",
        "links": [
          {
            "text": "use",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Include_Statement"
          }
        ]
      },
      {
        "name": "undef",
        "description": "Syntax element",
        "links": [
          {
            "text": "undef",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/General#The_Undefined_Value"
          }
        ]
      },
      {
        "name": "PI",
        "description": "Syntax element",
        "links": [
          {
            "text": "PI",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/General#Numbers"
          }
        ]
      },
      {
        "name": "n + m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n + m",
            "href": "https://en.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/Mathematical_Operators#Scalar_Arithmetical_Operators"
          }
        ]
      },
      {
        "name": "n - m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n - m",
            "href": "https://en.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/Mathematical_Operators#Scalar_Arithmetical_Operators"
          }
        ]
      },
      {
        "name": "n * m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n * m",
            "href": "https://en.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/Mathematical_Operators#Scalar_Arithmetical_Operators"
          }
        ]
      },
      {
        "name": "n / m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n / m",
            "href": "https://en.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/Mathematical_Operators#Scalar_Arithmetical_Operators"
          }
        ]
      },
      {
        "name": "n % m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n % m",
            "href": "https://en.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/Mathematical_Operators#Scalar_Arithmetical_Operators"
          }
        ]
      },
      {
        "name": "n ^ m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n ^ m",
            "href": "https://en.wikibooks.org/w/index.php?title=OpenSCAD_User_Manual/Mathematical_Operators#Scalar_Arithmetical_Operators"
          }
        ]
      },
      {
        "name": "n < m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n < m",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators#Relational_Operators"
          }
        ]
      },
      {
        "name": "n <= m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n <= m",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators#Relational_Operators"
          }
        ]
      },
      {
        "name": "b == c",
        "description": "Syntax element",
        "links": [
          {
            "text": "b == c",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators#Relational_Operators"
          }
        ]
      },
      {
        "name": "b != c",
        "description": "Syntax element",
        "links": [
          {
            "text": "b != c",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators#Relational_Operators"
          }
        ]
      },
      {
        "name": "n >= m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n >= m",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators#Relational_Operators"
          }
        ]
      },
      {
        "name": "n > m",
        "description": "Syntax element",
        "links": [
          {
            "text": "n > m",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators#Relational_Operators"
          }
        ]
      },
      {
        "name": "b && c",
        "description": "Syntax element",
        "links": [
          {
            "text": "b && c",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators#Logical_Operators"
          }
        ]
      },
      {
        "name": "b || c",
        "description": "Syntax element",
        "links": [
          {
            "text": "b || c",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators#Logical_Operators"
          }
        ]
      },
      {
        "name": "!b",
        "description": "Syntax element",
        "links": [
          {
            "text": "!b",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Operators#Logical_Operators"
          }
        ]
      },
      {
        "name": "$fa",
        "description": "Syntax element",
        "links": [
          {
            "text": "$fa",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features#$fa"
          }
        ]
      },
      {
        "name": "$fs",
        "description": "Syntax element",
        "links": [
          {
            "text": "$fs",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features#$fs"
          }
        ]
      },
      {
        "name": "$fn",
        "description": "Syntax element",
        "links": [
          {
            "text": "$fn",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features#$fn"
          }
        ]
      },
      {
        "name": "$t",
        "description": "Syntax element",
        "links": [
          {
            "text": "$t",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features#$t"
          }
        ]
      },
      {
        "name": "$vpr",
        "description": "Syntax element",
        "links": [
          {
            "text": "$vpr",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features#$vpr"
          }
        ]
      },
      {
        "name": "$vpt",
        "description": "Syntax element",
        "links": [
          {
            "text": "$vpt",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features#$vpt"
          }
        ]
      },
      {
        "name": "$vpd",
        "description": "Syntax element",
        "links": [
          {
            "text": "$vpd",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features#$vpd"
          }
        ]
      },
      {
        "name": "$vpf",
        "description": "Syntax element",
        "links": [
          {
            "text": "$vpf",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features#$vpf"
          }
        ]
      },
      {
        "name": "$children",
        "description": "Syntax element",
        "links": [
          {
            "text": "$children",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/User-Defined_Functions_and_Modules#Children"
          }
        ]
      },
      {
        "name": "$preview",
        "description": "Syntax element",
        "links": [
          {
            "text": "$preview",
            "href": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features#$preview"
          }
        ]
      }
    ],
    "primitives2D": [],
    "primitives3D": [],
    "transformations": [],
    "operators": [],
    "mathFunctions": [],
    "specialVariables": [],
    "otherFunctions": []
  },
  "userManual": {
    "general": {
      "title": "General",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/General",
      "introduction": "OpenSCAD is a 2D/3D and solid modeling program that is based on a Functional programming language used to create models that are  previewed on the screen, and rendered into 3D mesh that can be exported in a variety of 2D/3D file formats.\n\nA script in the OpenSCAD language is used to create 2D or 3D models. This script is a free format list of action statements.\n\nobject();\n variable = value;\n operator()   action();\n operator() { action();    action(); }\n operator()   operator() { action(); action(); }\n operator() { operator()   action();\n              operator() { action(); action(); } }\n\nObjects\nObjects are the building blocks for models, created by 2D and 3D primitives. Objects end in a semicolon ';'.\nExamples are: cube(), sphere(), polygon(), circle(), etc.\n\nActions\nAction statements include creating objects using primitives and assigning values to variables. Action statements also end in a semicolon ';'.\nExample: a=1; b = a+7;\n\nOperators\nOperators, or transformations, modify the location, color and other properties of objects. Operators use braces '{}' when their scope covers more than one action. More than one operator may be used for the same action or group of actions. Multiple operators are processed Right to Left, that is, the operator closest to the action is processed first. Operators do not end in semicolons ';', but the individual actions they contain do.\nExamples:\n\ncube(5);\n   x = 4+y;\n   rotate(40) square(5,10);\n   translate([10,5]) { circle(5); square(4); }\n   rotate(60) color(\"red\") { circle(5); square(4); }\n   color(\"blue\") { translate([5,3,0]) sphere(5); rotate([45,0,45]) { cylinder(10); cube([5,6,7]); } }\n\nComments[edit | edit source]\n\nComments are a way of leaving notes within the script, or code, (either to yourself or to future programmers) describing how the code works, or what it does. Comments are not evaluated by the compiler, and should not be used to describe self-evident code.\n\nOpenSCAD uses C++-style comments:\n\n// This is a comment\n  \nmyvar = 10; // The rest of the line is a comment\n  \n/*\n   Multi-line comments\n   can span multiple lines.\n*/\n\nValues and data types[edit | edit source]\n\nA value in OpenSCAD is either a Number (like 42), a Boolean (like true), a String (like \"foo\"), a Range (like [0: 1: 10]), a Vector (like [1,2,3]), or the Undefined value (undef). Values can be stored in variables, passed as function arguments, and returned as function results.\n\n[OpenSCAD is a dynamically typed language with a fixed set of data types. There are no type names, and no user defined types.]\n\nNumbers[edit | edit source]\n\nNumbers are the most important type of value in OpenSCAD, and they are written in the familiar decimal notation used in other languages. Eg, -1, 42, 0.5, 2.99792458e+8. [OpenSCAD does not support octal or hexadecimal notation for numbers.]\n\nIn addition to decimal numerals, the following names for special numbers are defined:\n\nPI\n\nOpenSCAD has only a single kind of number, which is a 64 bit IEEE floating point number. OpenSCAD does not distinguish integers and floating point numbers as two different types, nor does it support complex numbers. Because OpenSCAD uses the IEEE floating point standard, there are a few deviations from the behaviour of numbers in mathematics:\n\nWe use binary floating point. A fractional number is not represented exactly unless the denominator is a power of 2. For example, 0.2 (2/10) does not have an exact internal representation, but 0.25 (1/4) and 0.125 (1/8) are represented exactly.\nThe largest representable number is about 1e308. If a numeric result is too large, then the result can be infinity (printed as inf by echo).\nThe smallest representable number is about -1e308. If a numeric result is too small, then the result can be -infinity (printed as -inf by echo).\nIf a numeric result is invalid, then the result can be Not A Number (printed as nan by echo).\nIf a non-zero numeric result is too close to zero to be representable, then the result is -0 if the result is negative, otherwise it is 0. Zero (0) and negative zero (-0) are treated as two distinct numbers by some of the math operations, and are printed differently by 'echo', although they compare as equal.\n\nThe constants inf and nan are not supported as numeric constants by OpenSCAD, even though you can compute numbers that are printed this way by 'echo'. You can define variables with these values by using:\n\ninf = 1e200 * 1e200;\nnan = 0 / 0;\necho(inf,nan);\n\nThe value nan is the only OpenSCAD value that is not equal to any other value, including itself. Although you can test if a variable 'x' has the undefined value using 'x == undef', you can't use 'x == 0/0' to test if x is Not A Number. Instead, you must use 'x != x' to test if x is nan.\n\nBoolean values[edit | edit source]\n\nBooleans are variables with two states, typically denoted in OpenSCAD as true and false.  \nBoolean variables are typically generated by conditional tests and are employed by conditional statement 'if()'. conditional operator '? :', \nand generated by logical operators ! (not), && (and), and || (or).  Statements such as if() actually accept non-boolean variables, but most values are converted to true in a boolean context. The values that count as false are:\n\nfalse\n0 and -0\n\"\"\n[]\nundef\n\nNote that \"false\" (the string), [0] (a numeric vector), \n[ [] ] (a vector containing an empty vector), [false] \n(a vector containing the Boolean value false) and 0/0 (not a number) all count as true.\n\nStrings[edit | edit source]\n\nA string is a sequence of zero or more unicode characters. String values are used to specify file names when importing a file, and to display text for debugging purposes when using echo(). Strings can also be used with the text() primitive, added in version 2015.03.\n\nA string literal is written as a sequence of characters enclosed in quotation marks \", like this: \"\" (an empty string), or \"this is a string\".\n\nTo include a \" character in a string literal, use \\\". To include a \\ character in a string literal, use \\\\. The following escape sequences beginning with \\ can be used within string literals:\n\n\\\" → \"\n\\\\ → \\\n\\t → tab\n\\n → newline\n\\r → carriage return\n\\x21 → ! - valid only in the range from \\x01 to \\x7f, \\x00 produces a space\n\\u03a9 → Ω - 4 digit unicode code point, see text() for further information on unicode characters\n\\U01f600 → 😀 - 6 digit unicode code point\n\nThis behavior is new since OpenSCAD-2011.04. You can upgrade old files using the following sed command: sed 's/\\\\/\\\\\\\\/g' non-escaped.scad > escaped.scad\n\nExample:\n\necho(\"The quick brown fox \\tjumps \\\"over\\\" the lazy dog.\\rThe quick brown fox.\\nThe \\\\lazy\\\\ dog.\");\n  \n result\n   ECHO: \"The quick brown fox     jumps \"over\" the lazy dog.\n   The quick brown fox.\n   The \\lazy\\ dog.\"\n  \n old result\n   ECHO: \"The quick brown fox \\tjumps \\\"over\\\" the lazy dog.\n   The quick brown fox.\\nThe \\\\lazy\\\\ dog.\"\n\nRanges[edit | edit source]\n\nRanges are used by  for() loops and children(). They have 2 varieties:\n\n[<start>:<end>]\n[<start>:<increment>:<end>]\n\nAlthough enclosed in square brackets [] , they are not vectors. They use colons : for separators rather than commas.\n\nr1 = [0:10];\nr2 = [0.5:2.5:20];\necho(r1); // ECHO: [0: 1: 10]\necho(r2); // ECHO: [0.5: 2.5: 20]\n\nYou should avoid step values that cannot be represented exactly as binary floating point numbers. Integers are okay, as are fractional values whose denominator is a power of two. For example, 0.25 (1/4) and 0.125 (1/8) are safe, but 0.2 (2/10) should be avoided. The problem with these step values is that your range may have too many or too few elements, due to inexact arithmetic.\n\nA missing <increment> defaults to 1. A range in the form  [<start>:<end>] with <start> greater than <end> generates a warning and is equivalent to [<end>: 1: <start>]. A range in the form  [<start>:1:<end>] with <start> greater than <end> does not generate a warning and is equivalent to []. The <increment> in a range may be negative (for versions after 2014).\n\nThe undefined value[edit | edit source]\n\nThe undefined value is a special value written as undef. It is the initial value of a variable that hasn't been assigned a value, and it is often returned as a result by functions or operations that are passed illegal arguments. Finally, undef can be used as a null value, equivalent to null or NULL in other programming languages.\n\nAll arithmetic expressions containing undef values evaluate as undef. In logical expressions, undef is equivalent to false. Relational operator expressions with undef evaluate as false except for undef==undef, which is true.\n\nNote that numeric operations may also return 'nan' (not-a-number) to indicate an illegal argument. For example, 0/false is undef, but 0/0 is 'nan'. Relational operators like < and > return false if passed illegal arguments. Although undef is a language value, 'nan' is not.\n\nVariables[edit | edit source]\n\nOpenSCAD variables are created by a statement with a name or identifier, assignment via an expression and a semicolon. The role of arrays, found in many imperative languages, is handled in OpenSCAD via vectors. Valid identifiers are composed of simple characters and underscores [a-zA-Z0-9_] and do not allow high-ascii or unicode characters.\n\nvar = 25;\nxx = 1.25 * cos(50);\ny = 2*xx+var;\nlogic = true;\nMyString = \"This is a string\";\na_vector = [1,2,3];\nrr = a_vector[2];      // member of vector\nrange1 = [-1.5:0.5:3]; // for() loop range\nxx = [0:5];            // alternate for() loop range\n\nOpenSCAD is a  Functional programming language, as such variables are bound to expressions and keep a single value during their entire lifetime due to the requirements of referential transparency. In imperative languages, such as C, the same behavior is seen as constants, which are typically contrasted with normal variables.\n\nIn other words OpenSCAD variables are more like constants, but with an important difference. If variables are assigned a value multiple times, only the last assigned value is used in all places in the code. See further discussion at Variables are set at compile-time, not run-time.  This behavior is due to the need to supply variable input on the command line, via the use of -D variable=value option. OpenSCAD currently places that assignment at the end of the source code, and thus must allow a variable's value to be changed for this purpose.\n\nValues cannot be modified during run time; all variables are effectively constants that do not change. Each variable retains its last assigned value at compile time, in line with Functional programming languages. Unlike Imperative languages, such as C, OpenSCAD is not an iterative language, and as such the concept of x = x + 1 is not valid. The only way an expression like this could work is if the x on the right comes from a parent scope, such as an argument list, and the assignment operation creates a new x in the current scope. Understanding this concept leads to understanding the beauty of OpenSCAD.\n\nBefore version 2015.03, it was not possible to do assignments at any place except the file top-level and module top-level. Inside an if/else  or for  loop, assign() was needed.\n\nSince version 2015.03, variables can now be assigned in any scope. Note that assignments are valid only within the scope in which they are defined - you are still not allowed to leak values to an outer scope. See Scope of variables for more details.\n\na=0;\nif (a==0) \n  {\n a=1; //  before 2015.03 this line would generate a Compile Error\n      //  since 2015.03  no longer an error, but the value a=1 is confined to within the braces {}\n  }\n\nUndefined variable[edit | edit source]\n\nA non assigned variable has the special value undef.\nIt could be tested in conditional expression, and returned by a function.\n\nExample\n  \n echo(\"Variable a is \", a);                // Variable a is undef\n if (a==undef) {\n   echo(\"Variable a is tested undefined\"); // Variable a is tested undefined\n }\n\nScope of variables[edit | edit source]\n\nWhen operators such as translate() and color() need to encompass more than one action ( actions end in ;), braces {} are needed to group the actions, creating a new, inner scope.\nWhen there is only one semicolon, braces are usually optional.\n\nEach pair of braces creates a new scope inside the scope where they were used. Since 2015.03, new variables can be created within this new scope. New values can be given to variables that were created in an outer scope. \nThese variables and their values are also available to further inner scopes created within this scope, but are not available to anything outside this scope. Variables still have only the last value assigned within a scope.\n\n// scope 1\n a = 6;                // create a\n echo(a,b);            //                6, undef\n translate([5,0,0]){   // scope 1.1\n   a= 10;\n   b= 16;              // create b\n   echo(a,b);          //              100, 16   a=10; was overridden by later a=100;\n   color(\"blue\") {     // scope 1.1.1\n     echo(a,b);        //              100, 20\n     cube();\n     b=20;\n   }                   // back to 1.1\n   echo(a,b);          //              100, 16\n   a=100;              // override a in 1.1\n }                     // back to 1   \n echo(a,b);            //                6, undef\n color(\"red\"){         // scope 1.2\n   cube();\n   echo(a,b);          //                6, undef\n }                     // back to 1\n echo(a,b);            //                6, undef\n  \n //In this example, scopes 1 and 1.1 are outer scopes to 1.1.1 but 1.2 is not.\n\nAnonymous scopes are not considered scopes:\n\n{\n   angle = 45;\n }\n rotate(angle) square(10);\n\nFor() loops are not an exception to the rule about variables having only one value within a scope. A copy of loop contents is created for each pass. Each pass is given its own scope, allowing any variables to have unique values for that pass. No, you still can't do a=a+1;\n\nVariables are set at compile-time, not run-time[edit | edit source]\n\nBecause OpenSCAD calculates its variable values at compile-time, not run-time, the last variable assignment within a scope applies everywhere in that scope or inner scopes thereof. It may be helpful to think of them as override-able constants rather than as variables.\n\n// The value of 'a' reflects only the last set value\n   a = 0;\n   echo(a);  // 5\n   a = 3;\n   echo(a);  // 5\n   a = 5;\n\nWhile this appears to be counter-intuitive, it allows you to do some interesting things: for instance, if you set up your shared library files to have default values defined as variables at their root level, when you include that file in your own code you can 're-define' or override those constants by simply assigning a new value to them. So changing constant values gives you more flexibility. If constants would never change, of course, you always can be sure having the value you see in any constant definition. Not so here.  If you see a constant value definition at any other place its value could be different. This allows for flexibility.\n\nThe preceding description appears to differ from the behaviour of OpenSCAD as at May 23 2022. At that date, running the above example causes the following output:\n\nWARNING: a was assigned on line 1 of \"Untitled\" but was overwritten in file Untitled, line 3\nExecution aborted\n\nCurrently, at least as of version 2025.01.04, the warning is slightly different and does not result in an execution abort.\n\nWARNING: a was assigned on line 1 but was overwritten in file untitled.scad, line 3\n\nSpecial variables[edit | edit source]\n\nSpecial variables provide an alternate means of passing arguments to modules and functions.\nAll variables starting with a '$' are special variables, similar to special variables in lisp.\nAs such they are more dynamic than regular variables.\n(for more details see Other Language Features)\n\nVectors[edit | edit source]\n\nA vector or list is a sequence of zero or more OpenSCAD values. Vectors are collections of numeric or boolean values, variables, vectors, strings or any combination thereof. They can also be expressions that evaluate to one of these. Vectors handle the role of arrays found in many imperative languages.\nThe information here also applies to lists and tables that use vectors for their data.\n\nA vector has square brackets, [] enclosing zero or more items (elements or members), separated by commas. A vector can contain vectors, which can contain vectors, etc.\n\nExamples\n\n[1,2,3]\n   [a,5,b]\n   []\n   [5.643]\n   [\"a\",\"b\",\"string\"]\n   [[1,r],[x,y,z,4,5]]\n   [3, 5, [6,7], [[8,9],[10,[11,12],13], c, \"string\"]\n   [4/3, 6*1.5, cos(60)]\n\nuse in OpenSCAD:\n\ncube( [width,depth,height] );           // optional spaces shown for clarity\n  translate( [x,y,z] )\n  polygon( [ [x0,y0],  [x1,y1],  [x2,y2] ] );\n\nCreation[edit | edit source]\n\nVectors are created by writing the list of elements, separated by commas, and enclosed in square brackets. Variables are replaced by their values.\n\ncube([10,15,20]);\n  a1 = [1,2,3];\n  a2 = [4,5];\n  a3 = [6,7,8,9];\n  b  = [a1,a2,a3];    // [ [1,2,3], [4,5], [6,7,8,9] ]  note increased nesting depth\n\nVectors can be initialized using a for loop enclosed in square brackets.\n\nThe following example initializes the vector result with a length n of 10 values to the value of a.\n\nn = 10;\na = 0;\n\nresult = [ for (i=[0:n-1]) a ];\necho(result); //ECHO: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\nThe following example shows a vector result with a n length of 10 initialized with values that are alternatively a or b respectively if the index position i is an even or an odd number.\n\nn = 10;\na = 0;\nb = 1;\nresult = [ for (i=[0:n-1]) (i % 2 == 0) ? a : b ];\necho(result); //ECHO: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n\nIndexing elements within vectors[edit | edit source]\n\nElements within vectors are numbered from 0 to n-1 where n is the length returned by len().\nAddress elements within vectors with the following notation:\n\ne[5]           // element no 5 (sixth) at   1st nesting level\ne[5][2]        // element 2 of element 5    2nd nesting level\ne[5][2][0]     // element 0 of 2 of 5       3rd nesting level\ne[5][2][0][1]  // element 1 of 0 of 2 of 5  4th nesting level\n\nexample elements with lengths from len()\n\ne = [ [1], [], [3,4,5], \"string\", \"x\", [[10,11],[12,13,14],[[15,16],[17]]] ];  // length 6\n\naddress       length  element\ne[0]          1       [1]\ne[1]          0       []\ne[5]          3       [ [10,11], [12,13,14], [[15,16],[17]] ]\ne[5][1]       3       [ 12, 13, 14 ]\ne[5][2]       2       [ [15,16], [17] ]\ne[5][2][0]    2       [ 15, 16 ]\ne[5][2][0][1] undef   16\n    \ne[3]          6       \"string\"\ne[3 ][2]      1       \"r\"\n  \ns = [2,0,5]; a = 2;\ns[a]          undef   5\ne[s[a]]       3       [ [10,11], [12,13,14], [[15,16],[17]] ]\n\nString indexing[edit | edit source]\n\nThe elements (characters) of a string can be accessed:\n\n\"string\"[2]    //resolves to \"r\"\n\nDot notation indexing[edit | edit source]\n\nThe first three elements of a vector can be accessed with an alternate dot notation:\n\ne.x    //equivalent to e[0]\ne.y    //equivalent to e[1]\ne.z    //equivalent to e[2]\n\nVector operators[edit | edit source]\n\nconcat[edit | edit source]\n\n[Note: Requires version 2015.03]\n\nconcat() combines the elements of 2 or more vectors into a single vector. No change in nesting level is made.\n\nvector1 = [1,2,3]; vector2 = [4]; vector3 = [5,6];\n new_vector = concat(vector1, vector2, vector3); // [1,2,3,4,5,6]\n  \n string_vector = concat(\"abc\",\"def\");                 // [\"abc\", \"def\"]\n one_string = str(string_vector[0],string_vector[1]); // \"abcdef\"\n\nlen[edit | edit source]\n\nlen() is a function that returns the length of vectors or strings. \nIndices of elements are from [0] to [length-1].\n\nvector\nReturns the number of elements at this level.\nSingle values, which are not vectors, raise an error.\nstring\nReturns the number of characters in a string.\n\na = [1,2,3]; echo(len(a));   //  3\n\nSee example elements with lengths\n\nMatrix[edit | edit source]\n\nA matrix is a vector of vectors.\n\nExample that defines a 2D rotation matrix\nmr = [\n     [cos(angle), -sin(angle)],\n     [sin(angle),  cos(angle)]\n    ];\n\nObjects[edit | edit source]\n\n[Note: Requires version Development snapshot]\n\nObjects store collections of data, like vectors, but the individual members are accessed by string names rather than by numeric indexes.  They are analogous to JavaScript objects or Python dictionaries.  There is currently a limited implementation of objects:  it is not possible for an OpenSCAD program to create an object, only to receive one as the return value from a function.\n\nRetrieving a value from an object[edit | edit source]\n\nobj.name\n\nRetrieves the named value from the object, for a name that is constant and syntactically suitable for use as an identifier.\n\nobj[\"name\"]\n\nRetrieves the named value from the object, for a name that is an arbitrary string expression.\n\nNote that members with identifier-like names can be accessed using either mechanism.  The choice depends on the particular use case.\n\nIterating over object members[edit | edit source]\n\nfor (name = obj) { ... }\n\niterates over the members of the object, in an unspecified order, setting name to the name of each member.  It is then typically desirable to access the value using obj[name].\n\nThis construct works for flow-control for, intersection_for(), and list-comprehension for.\n\nGetting input[edit | edit source]\n\nThere is no mechanism for variable input from keyboard or reading from arbitrary files.  There is no prompting mechanism, no input window, or input fields or any way to manually enter data while the script is running.\n\nVariables can be set via:\n\nassignments in the script\nthe Customizer\n-D at the command line interface\naccessing data in a few file formats (stl, dxf, png, etc).\n\nWith the exception of DXF files, data from files is not accessible to the script, although to a limited extent the script may be able to manipulate the data as a whole.  For example, STL files can be rendered in OpenSCAD, translated, clipped, etc.  But the internal data that constitutes the STL file is inaccessible.\n\nGetting a point from a drawing[edit | edit source]\n\nGetting a point is useful for reading an origin point in a 2D view in a technical drawing. The function dxf_cross reads the intersection of two lines on a layer you specify and returns the intersection point. This means that the point must be given with two lines in the DXF file, and not a point entity.\n\nOriginPoint = dxf_cross(file=\"drawing.dxf\", layer=\"SCAD.Origin\", \n                        origin=[0, 0], scale=1);\n\nGetting a dimension value[edit | edit source]\n\nYou can read dimensions from a technical drawing. This can be useful to read a rotation angle, an extrusion height, or spacing between parts. In the drawing, create a dimension that does not show the dimension value, but an identifier. To read the value, you specify this identifier from your program:\n\nTotalWidth = dxf_dim(file=\"drawing.dxf\", name=\"TotalWidth\",\n                        layer=\"SCAD.Origin\", origin=[0, 0], scale=1);\n\nFor a nice example of both functions, see Example009 and the image on the homepage of OpenSCAD.",
      "content": {},
      "codeExamples": [
        {
          "code": "object();\n variable = value;\n operator()   action();\n operator() { action();    action(); }\n operator()   operator() { action(); action(); }\n operator() { operator()   action();\n              operator() { action(); action(); } }",
          "context": "A script in the OpenSCAD language is used to create 2D or 3D models. This script is a free format list of action statements."
        },
        {
          "code": "cube(5);\n   x = 4+y;\n   rotate(40) square(5,10);\n   translate([10,5]) { circle(5); square(4); }\n   rotate(60) color(\"red\") { circle(5); square(4); }\n   color(\"blue\") { translate([5,3,0]) sphere(5); rotate([45,0,45]) { cylinder(10); cube([5,6,7]); } }",
          "context": "Operators\nOperators, or transformations, modify the location, color and other properties of objects. Operators use braces '{}' when their scope covers more than one action. More than one operator may be used for the same action or group of actions. Multiple operators are processed Right to Left, that is, the operator closest to the action is processed first. Operators do not end in semicolons ';', but the individual actions they contain do.\nExamples:"
        },
        {
          "code": "// This is a comment\n  \nmyvar = 10; // The rest of the line is a comment\n  \n/*\n   Multi-line comments\n   can span multiple lines.\n*/",
          "context": "OpenSCAD uses C++-style comments:"
        },
        {
          "code": "inf = 1e200 * 1e200;\nnan = 0 / 0;\necho(inf,nan);",
          "context": "The constants inf and nan are not supported as numeric constants by OpenSCAD, even though you can compute numbers that are printed this way by 'echo'. You can define variables with these values by using:"
        },
        {
          "code": "echo(\"The quick brown fox \\tjumps \\\"over\\\" the lazy dog.\\rThe quick brown fox.\\nThe \\\\lazy\\\\ dog.\");\n  \n result\n   ECHO: \"The quick brown fox     jumps \"over\" the lazy dog.\n   The quick brown fox.\n   The \\lazy\\ dog.\"\n  \n old result\n   ECHO: \"The quick brown fox \\tjumps \\\"over\\\" the lazy dog.\n   The quick brown fox.\\nThe \\\\lazy\\\\ dog.\"",
          "context": "This behavior is new since OpenSCAD-2011.04. You can upgrade old files using the following sed command: sed 's/\\\\/\\\\\\\\/g' non-escaped.scad > escaped.scad"
        },
        {
          "code": "r1 = [0:10];\nr2 = [0.5:2.5:20];\necho(r1); // ECHO: [0: 1: 10]\necho(r2); // ECHO: [0.5: 2.5: 20]",
          "context": "Although enclosed in square brackets [] , they are not vectors. They use colons : for separators rather than commas."
        },
        {
          "code": "var = 25;\nxx = 1.25 * cos(50);\ny = 2*xx+var;\nlogic = true;\nMyString = \"This is a string\";\na_vector = [1,2,3];\nrr = a_vector[2];      // member of vector\nrange1 = [-1.5:0.5:3]; // for() loop range\nxx = [0:5];            // alternate for() loop range",
          "context": "OpenSCAD variables are created by a statement with a name or identifier, assignment via an expression and a semicolon. The role of arrays, found in many imperative languages, is handled in OpenSCAD via vectors. Valid identifiers are composed of simple characters and underscores [a-zA-Z0-9_] and do not allow high-ascii or unicode characters."
        },
        {
          "code": "a=0;\nif (a==0) \n  {\n a=1; //  before 2015.03 this line would generate a Compile Error\n      //  since 2015.03  no longer an error, but the value a=1 is confined to within the braces {}\n  }",
          "context": "Since version 2015.03, variables can now be assigned in any scope. Note that assignments are valid only within the scope in which they are defined - you are still not allowed to leak values to an outer scope. See Scope of variables for more details."
        },
        {
          "code": "Example\n  \n echo(\"Variable a is \", a);                // Variable a is undef\n if (a==undef) {\n   echo(\"Variable a is tested undefined\"); // Variable a is tested undefined\n }",
          "context": "A non assigned variable has the special value undef.\nIt could be tested in conditional expression, and returned by a function."
        },
        {
          "code": "// scope 1\n a = 6;                // create a\n echo(a,b);            //                6, undef\n translate([5,0,0]){   // scope 1.1\n   a= 10;\n   b= 16;              // create b\n   echo(a,b);          //              100, 16   a=10; was overridden by later a=100;\n   color(\"blue\") {     // scope 1.1.1\n     echo(a,b);        //              100, 20\n     cube();\n     b=20;\n   }                   // back to 1.1\n   echo(a,b);          //              100, 16\n   a=100;              // override a in 1.1\n }                     // back to 1   \n echo(a,b);            //                6, undef\n color(\"red\"){         // scope 1.2\n   cube();\n   echo(a,b);          //                6, undef\n }                     // back to 1\n echo(a,b);            //                6, undef\n  \n //In this example, scopes 1 and 1.1 are outer scopes to 1.1.1 but 1.2 is not.",
          "context": "Each pair of braces creates a new scope inside the scope where they were used. Since 2015.03, new variables can be created within this new scope. New values can be given to variables that were created in an outer scope. \nThese variables and their values are also available to further inner scopes created within this scope, but are not available to anything outside this scope. Variables still have only the last value assigned within a scope."
        },
        {
          "code": "{\n   angle = 45;\n }\n rotate(angle) square(10);",
          "context": "Anonymous scopes are not considered scopes:"
        },
        {
          "code": "// The value of 'a' reflects only the last set value\n   a = 0;\n   echo(a);  // 5\n   a = 3;\n   echo(a);  // 5\n   a = 5;",
          "context": "Because OpenSCAD calculates its variable values at compile-time, not run-time, the last variable assignment within a scope applies everywhere in that scope or inner scopes thereof. It may be helpful to think of them as override-able constants rather than as variables."
        },
        {
          "code": "[1,2,3]\n   [a,5,b]\n   []\n   [5.643]\n   [\"a\",\"b\",\"string\"]\n   [[1,r],[x,y,z,4,5]]\n   [3, 5, [6,7], [[8,9],[10,[11,12],13], c, \"string\"]\n   [4/3, 6*1.5, cos(60)]",
          "context": "A vector has square brackets, [] enclosing zero or more items (elements or members), separated by commas. A vector can contain vectors, which can contain vectors, etc."
        },
        {
          "code": "cube( [width,depth,height] );           // optional spaces shown for clarity\n  translate( [x,y,z] )\n  polygon( [ [x0,y0],  [x1,y1],  [x2,y2] ] );",
          "context": "use in OpenSCAD:"
        },
        {
          "code": "cube([10,15,20]);\n  a1 = [1,2,3];\n  a2 = [4,5];\n  a3 = [6,7,8,9];\n  b  = [a1,a2,a3];    // [ [1,2,3], [4,5], [6,7,8,9] ]  note increased nesting depth",
          "context": "Vectors are created by writing the list of elements, separated by commas, and enclosed in square brackets. Variables are replaced by their values."
        },
        {
          "code": "n = 10;\na = 0;\n\nresult = [ for (i=[0:n-1]) a ];\necho(result); //ECHO: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",
          "context": "No specific context available"
        },
        {
          "code": "n = 10;\na = 0;\nb = 1;\nresult = [ for (i=[0:n-1]) (i % 2 == 0) ? a : b ];\necho(result); //ECHO: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]",
          "context": "No specific context available"
        },
        {
          "code": "e[5]           // element no 5 (sixth) at   1st nesting level\ne[5][2]        // element 2 of element 5    2nd nesting level\ne[5][2][0]     // element 0 of 2 of 5       3rd nesting level\ne[5][2][0][1]  // element 1 of 0 of 2 of 5  4th nesting level",
          "context": "Elements within vectors are numbered from 0 to n-1 where n is the length returned by len().\nAddress elements within vectors with the following notation:"
        },
        {
          "code": "e = [ [1], [], [3,4,5], \"string\", \"x\", [[10,11],[12,13,14],[[15,16],[17]]] ];  // length 6\n\naddress       length  element\ne[0]          1       [1]\ne[1]          0       []\ne[5]          3       [ [10,11], [12,13,14], [[15,16],[17]] ]\ne[5][1]       3       [ 12, 13, 14 ]\ne[5][2]       2       [ [15,16], [17] ]\ne[5][2][0]    2       [ 15, 16 ]\ne[5][2][0][1] undef   16\n    \ne[3]          6       \"string\"\ne[3 ][2]      1       \"r\"\n  \ns = [2,0,5]; a = 2;\ns[a]          undef   5\ne[s[a]]       3       [ [10,11], [12,13,14], [[15,16],[17]] ]",
          "context": "example elements with lengths from len()"
        },
        {
          "code": "\"string\"[2]    //resolves to \"r\"",
          "context": "The elements (characters) of a string can be accessed:"
        },
        {
          "code": "e.x    //equivalent to e[0]\ne.y    //equivalent to e[1]\ne.z    //equivalent to e[2]",
          "context": "The first three elements of a vector can be accessed with an alternate dot notation:"
        },
        {
          "code": "vector1 = [1,2,3]; vector2 = [4]; vector3 = [5,6];\n new_vector = concat(vector1, vector2, vector3); // [1,2,3,4,5,6]\n  \n string_vector = concat(\"abc\",\"def\");                 // [\"abc\", \"def\"]\n one_string = str(string_vector[0],string_vector[1]); // \"abcdef\"",
          "context": "concat() combines the elements of 2 or more vectors into a single vector. No change in nesting level is made."
        },
        {
          "code": "a = [1,2,3]; echo(len(a));   //  3",
          "context": "vector\nReturns the number of elements at this level.\nSingle values, which are not vectors, raise an error.\nstring\nReturns the number of characters in a string."
        },
        {
          "code": "Example that defines a 2D rotation matrix\nmr = [\n     [cos(angle), -sin(angle)],\n     [sin(angle),  cos(angle)]\n    ];",
          "context": "A matrix is a vector of vectors."
        },
        {
          "code": "obj.name",
          "context": "Retrieving a value from an object[edit | edit source]"
        },
        {
          "code": "obj[\"name\"]",
          "context": "Retrieves the named value from the object, for a name that is constant and syntactically suitable for use as an identifier."
        },
        {
          "code": "for (name = obj) { ... }",
          "context": "Iterating over object members[edit | edit source]"
        },
        {
          "code": "OriginPoint = dxf_cross(file=\"drawing.dxf\", layer=\"SCAD.Origin\", \n                        origin=[0, 0], scale=1);",
          "context": "No specific context available"
        },
        {
          "code": "TotalWidth = dxf_dim(file=\"drawing.dxf\", name=\"TotalWidth\",\n                        layer=\"SCAD.Origin\", origin=[0, 0], scale=1);",
          "context": "No specific context available"
        }
      ]
    },
    "primitives": {
      "title": "Primitive Solids",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Primitive_Solids",
      "introduction": "cube[edit | edit source]\n\nCreates a cube or rectangular prism (i.e., a \"box\") in the first octant. When center is true, the cube is centered on the origin. Argument names are optional if given in the order shown here.\n\ncube(size = [x,y,z], center = true/false);\ncube(size =  x ,     center = true/false);\n\nparameters:\n\nsize\nsingle value, cube with all sides this length\n3 value array [x,y,z], rectangular prism with dimensions x, y and z.\ncenter\nfalse (default), 1st (positive) octant, one corner at (0,0,0)\ntrue, cube is centered at (0,0,0)\n\ndefault values:  cube();   yields:  cube(size = [1, 1, 1], center = false);\n\nexamples:\n\nequivalent scripts for this example\n cube(size = 18);\n cube(18);\n cube([18,18,18]);\n .\n cube(18,false);\n cube([18,18,18],false);\n cube([18,18,18],center=false);\n cube(size = [18,18,18], center = false);\n cube(center = false,size = [18,18,18] );\n\nequivalent scripts for this example\n cube([18,28,8],true);\n box=[18,28,8];cube(box,true);\n\nsphere[edit | edit source]\n\nCreates a sphere at the origin of the coordinate system. The r argument name is optional. To use d instead of r, d must be named.\n\nParameters\n\nr\nRadius.  This is the radius of the sphere.  The resolution of the sphere is based on the size of the sphere and the $fa, $fs and $fn variables. For more information on these special variables look at: OpenSCAD_User_Manual/Other_Language_Features\nd\nDiameter.  This is the diameter of the sphere.\n$fa\nFragment angle in degrees\n$fs\nFragment size in mm\n$fn\nResolution\n\ndefault values:  sphere();   yields:   sphere($fn = 0, $fa = 12, $fs = 2, r = 1);\n\nUsage Examples\n\nsphere(r = 1);\nsphere(r = 5);\nsphere(r = 10);\nsphere(d = 2);\nsphere(d = 10);\nsphere(d = 20);\n\n// this creates a high resolution sphere with a 2mm radius\nsphere(2, $fn=100);\n\n// also creates a 2mm high resolution sphere but this one \n// does not have as many small triangles on the poles of the sphere\nsphere(2, $fa=5, $fs=0.1);\n\ncylinder[edit | edit source]\n\nCreates a cylinder or cone centered about the z axis. When center is true, it is also centered vertically along the z axis.\n\nParameter names are optional if given in the order shown here. If a parameter is named, all following parameters must also be named.\n\ncylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false);\n\nNOTES:\n\nThe 2nd & 3rd positional parameters are r1 & r2, if r, d, d1 or d2 are used they must be named.\n\nUsing r1 & r2 or d1 & d2 with either value of zero will make a cone shape, a non-zero non-equal value will produce a section of a cone (a Conical Frustum). r1 & d1 define the base width, at [0,0,0], and r2 & d2 define the top width.\n\nParameters\n\nh : height of the cylinder or cone\nr  : radius of cylinder. r1 = r2 = r.\nr1 : radius, bottom of cone.\nr2 : radius, top of cone.\nd  : diameter of cylinder. r1 = r2 = d / 2. [Note: Requires version 2014.03]\nd1 : diameter, bottom of cone. r1 = d1 / 2. [Note: Requires version 2014.03]\nd2 : diameter, top of cone. r2 = d2 / 2. [Note: Requires version 2014.03]\ncenter\nfalse (default), z ranges from 0 to h\ntrue,  z ranges from -h/2 to +h/2\n$fa : minimum angle (in degrees) of each fragment.\n$fs : minimum circumferential length of each fragment.\n$fn : fixed number of fragments in 360 degrees. Values of 3 or more override $fa and $fs\n$fa, $fs and $fn must be named parameters. click here for more details,.\n\ndefaults: cylinder();  yields: cylinder($fn = 0, $fa = 12, $fs = 2, h = 1, r1 = 1, r2 = 1, center = false);\n\nequivalent scripts\n cylinder(h=15, r1=9.5, r2=19.5, center=false);\n cylinder(  15,    9.5,    19.5, false);\n cylinder(  15,    9.5,    19.5);\n cylinder(  15,    9.5, d2=39  );\n cylinder(  15, d1=19,  d2=39  );\n cylinder(  15, d1=19,  r2=19.5);\n\nequivalent scripts\n cylinder(h=15, r1=10, r2=0, center=true);\n cylinder(  15,    10,    0,        true);\n cylinder(h=15, d1=20, d2=0, center=true);\n\ncenter = false\n\t\t\n\t\t\n\t\t\t\n\t\t\tcenter = true\n\nequivalent scripts\n cylinder(h=20, r=10, center=true);\n cylinder(  20,   10, 10,true);\n cylinder(  20, d=20, center=true);\n cylinder(  20,r1=10, d2=20, center=true);\n cylinder(  20,r1=10, d2=2*10, center=true);\n\nuse of $fn\n\nLarger values of $fn create smoother, more circular, surfaces at the cost of longer rendering time. Some use medium values during development for the faster rendering, then change to a larger value for the final F6 rendering.\n\nHowever, use of small values can produce some interesting non circular objects. A few examples are show here:\n\nscripts for these examples\n cylinder(20,20,20,$fn=3);\n cylinder(20,20,00,$fn=4);\n cylinder(20,20,10,$fn=4);\n\nundersized holes\n\nUsing cylinder() with difference() to place holes in objects creates undersized holes. This is because circular paths are approximated with polygons inscribed within in a circle. The points of the polygon are on the circle, but straight lines between are inside. To have all of the hole larger than the true circle, the polygon must lie wholly outside of the circle (circumscribed). Modules for circumscribed holes\n\nscript for this example\n poly_n = 6;\n color(\"blue\") translate([0, 0, 0.02]) linear_extrude(0.1) circle(10, $fn=poly_n);\n color(\"green\") translate([0, 0, 0.01]) linear_extrude(0.1) circle(10, $fn=360);\n color(\"purple\") linear_extrude(0.1) circle(10/cos(180/poly_n), $fn=poly_n);\n\nIn general, a polygon of radius \n  \n    \n      \n        r\n      \n    \n    {\\displaystyle r}\n  \n has a radius to the midpoint of any side as \n  \n    \n      \n        \n          r\n          \n            m\n          \n        \n        =\n        r\n        cos\n        ⁡\n        (\n        180\n        \n          /\n        \n        n\n        )\n      \n    \n    {\\displaystyle r_{m}=r\\cos(180/n)}\n  \n. If only the midpoint radius \n  \n    \n      \n        \n          r\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle r_{m}}\n  \n is known (for example, to fit a hex key into a hexagonal hole), then the polygon radius is \n  \n    \n      \n        r\n        =\n        \n          \n            \n              r\n              \n                m\n              \n            \n            \n              cos\n              ⁡\n              (\n              180\n              \n                /\n              \n              n\n              )\n            \n          \n        \n      \n    \n    {\\displaystyle r={\\frac {r_{m}}{\\cos(180/n)}}}\n  \n.\n\npolyhedron[edit | edit source]\n\nA polyhedron is the most general 3D primitive solid. It can be used to create any regular or irregular shape including those with concave as well as convex features. Curved surfaces are approximated by a series of flat surfaces.\n\npolyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], triangles = [ [P0, P1, P2], ... ], convexity = N);   // before 2014.03\npolyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N);   // 2014.03 & later\n\nParameters\npoints\nVector of 3d points or vertices. Each point is in turn a vector, [x,y,z], of its coordinates.\nPoints may be defined in any order. N points are referenced, in the order defined, as 0 to N-1.\n\ntriangles [Deprecated: triangles will be removed in future releases. Use faces parameter instead]\nVector of faces that collectively enclose the solid. Each face is a vector containing the indices (0 based) of 3 points from the points vector.\n\nfaces [Note: Requires version 2014.03]\nVector of faces that collectively enclose the solid. Each face is a vector containing the indices (0 based) of 3 or more points from the points vector.\nFaces may be defined in any order, but the points of each face must be ordered correctly (see below). Define enough faces to fully enclose the solid, with no overlap.\nIf points that describe a single face are not on the same plane, the face is automatically split into triangles as needed.\n\nconvexity\nInteger. The convexity parameter specifies the maximum number of faces a ray intersecting the object might penetrate. This parameter is needed only for correct display of the object in OpenCSG preview mode. It has no effect on the polyhedron rendering. For display problems, setting it to 10 should work fine for most cases.\n\ndefault values: polyhedron(); yields: polyhedron(points = undef, faces = undef, convexity = 1);\n\nIn the list of faces, for each face it is arbitrary which point you start with, but the points of the face (referenced by the index into the list of points) must be ordered in clockwise direction when looking at each face from outside inward. The back is viewed from the back, the bottom from the bottom, etc.\n\nAnother way to remember this ordering requirement is to use the left-hand rule. Using your left hand, stick your thumb up and curl your fingers as if giving the thumbs-up sign, point your thumb away from the face, and order the points in the direction your fingers curl (this is the opposite of the STL file format convention, which uses a \"right-hand rule\"). Try this on the example below.\n\nExample 1 Using polyhedron to generate cube( [ 10, 7, 5 ] );\n\npoint numbers for cube\n\nunfolded cube faces\n\nCubePoints = [\n  [  0,  0,  0 ],  //0\n  [ 10,  0,  0 ],  //1\n  [ 10,  7,  0 ],  //2\n  [  0,  7,  0 ],  //3\n  [  0,  0,  5 ],  //4\n  [ 10,  0,  5 ],  //5\n  [ 10,  7,  5 ],  //6\n  [  0,  7,  5 ]]; //7\n  \nCubeFaces = [\n  [0,1,2,3],  // bottom\n  [4,5,1,0],  // front\n  [7,6,5,4],  // top\n  [5,6,2,1],  // right\n  [6,7,3,2],  // back\n  [7,4,0,3]]; // left\n  \npolyhedron( CubePoints, CubeFaces );\n\nequivalent descriptions of the bottom face\n  [0,1,2,3],\n  [0,1,2,3,0],\n  [1,2,3,0],\n  [2,3,0,1],\n  [3,0,1,2],\n  [0,1,2],[2,3,0],   // 2 triangles with no overlap\n  [1,2,3],[3,0,1],\n  [1,2,3],[0,1,3],\n\nExample 2  A square base pyramid:\n\nA simple polyhedron, square base pyramid\n\npolyhedron(\n  points=[ [10,10,0],[10,-10,0],[-10,-10,0],[-10,10,0], // the four points at base\n           [0,0,10]  ],                                 // the apex point \n  faces=[ [0,1,4],[1,2,4],[2,3,4],[3,0,4],              // each triangle side\n              [1,0,3],[2,1,3] ]                         // two triangles for square base\n );\n\nExample 3  A triangular prism:\n\nA polyhedron triangular prism\n\nmodule prism(l, w, h){\n      polyhedron(//pt 0        1        2        3        4        5\n              points=[[0,0,0], [l,0,0], [l,w,0], [0,w,0], [0,w,h], [l,w,h]],\n              faces=[[0,1,2,3],[5,4,3,2],[0,4,5,1],[0,3,4],[5,2,1]]\n              );\n      \n      // preview unfolded (do not include in your function\n      z = 0.08;\n      separation = 2;\n      border = .2;\n      translate([0,w+separation,0])\n          cube([l,w,z]);\n      translate([0,w+separation+w+border,0])\n          cube([l,h,z]);\n      translate([0,w+separation+w+border+h+border,0])\n          cube([l,sqrt(w*w+h*h),z]);\n      translate([l+border,w+separation,0])\n          polyhedron(//pt 0       1       2        3       4       5\n                  points=[[0,0,0],[h,w,0],[0,w,0], [0,0,z],[h,w,z],[0,w,z]],\n                  faces=[[0,1,2], [3,5,4], [0,3,4,1], [1,4,5,2], [2,5,3,0]]\n                  );\n      translate([0-border,w+separation,0])\n          polyhedron(//pt 0       1         2        3       4         5\n                  points=[[0,0,0],[0-h,w,0],[0,w,0], [0,0,z],[0-h,w,z],[0,w,z]],\n                  faces=[[1,0,2],[5,3,4],[0,1,4,3],[1,2,5,4],[2,0,3,5]]\n                  );\n      }\n  \n  prism(10, 5, 3);\n\nDebugging polyhedra[edit | edit source]\n\nMistakes in defining polyhedra include not having all faces in clockwise order (viewed from outside - a bottom need to be viewed from below), overlap of faces and missing faces or portions of faces. As a general rule, the polyhedron faces should also satisfy manifold conditions:\n\nexactly two faces should meet at any polyhedron edge.\nif two faces have a vertex in common, they should be in the same cycle face-edge around the vertex.\n\nThe first rule eliminates polyhedra like two cubes with a common edge and not watertight models; the second excludes polyhedra like two cubes with a common vertex.\n\nWhen viewed from the outside, the points describing each face must be in the same clockwise order, and provides a mechanism for detecting counterclockwise.\nWhen the thrown together view (F12) is used with F5, CCW faces are shown in pink. Reorder the points for incorrect faces. Rotate the object to view all faces. The pink view can be turned off with F10.\n\nOpenSCAD allows, temporarily, commenting out part of the face descriptions so that only the remaining faces are displayed. Use // to comment out the rest of the line. Use /* and */ to start and end a comment block. This can be part of a line or extend over several lines. Viewing only part of the faces can be helpful in determining the right points for an individual face. Note that a solid is not shown, only the faces. If using F12, all faces have one pink side. Commenting some faces helps also to show any internal face.\n\nexample 1 showing only 2 faces\n\nCubeFaces = [\n/* [0,1,2,3],  // bottom\n   [4,5,1,0],  // front */\n   [7,6,5,4],  // top\n/* [5,6,2,1],  // right\n   [6,7,3,2],  // back */\n   [7,4,0,3]]; // left\n\nAfter defining a polyhedron, its preview may seem correct. The polyhedron alone may even render fine. However, to be sure it is a valid manifold and that it can generate a valid STL file, union it with any cube and render it (F6). If the polyhedron disappears, it means that it is not correct. Revise the winding order of all faces and the two rules stated above.\n\nMis-ordered faces[edit | edit source]\n\nExample 4  a more complex polyhedron with mis-ordered faces\n\nWhen you select 'Thrown together' from the view menu and compile (preview F5) the design\n(not compile and render!) the preview shows the mis-oriented polygons highlighted. Unfortunately this highlighting is not possible in the OpenCSG preview mode because it would interfere with the way the OpenCSG preview mode is implemented.)\n\nBelow you can see the code and the picture of such a problematic polyhedron, the bad polygons (faces or compositions of faces) are in pink.\n\n// Bad polyhedron\npolyhedron\n    (points = [\n\t       [0, -10, 60], [0, 10, 60], [0, 10, 0], [0, -10, 0], [60, -10, 60], [60, 10, 60], \n\t       [10, -10, 50], [10, 10, 50], [10, 10, 30], [10, -10, 30], [30, -10, 50], [30, 10, 50]\n\t       ], \n     faces = [\n\t\t  [0,2,3],   [0,1,2],  [0,4,5],  [0,5,1],   [5,4,2],  [2,4,3],\n                  [6,8,9],  [6,7,8],  [6,10,11], [6,11,7], [10,8,11],\n\t\t  [10,9,8], [0,3,9],  [9,0,6], [10,6, 0],  [0,4,10],\n                  [3,9,10], [3,10,4], [1,7,11],  [1,11,5], [1,7,8],  \n                  [1,8,2],  [2,8,11], [2,11,5]\n\t\t  ]\n     );\n\nPolyhedron with badly oriented polygons\n\nA correct polyhedron would be the following:\n\npolyhedron\n    (points = [\n\t       [0, -10, 60], [0, 10, 60], [0, 10, 0], [0, -10, 0], [60, -10, 60], [60, 10, 60], \n\t       [10, -10, 50], [10, 10, 50], [10, 10, 30], [10, -10, 30], [30, -10, 50], [30, 10, 50]\n\t       ], \n     faces = [\n\t\t  [0,3,2],  [0,2,1],  [4,0,5],  [5,0,1],  [5,2,4],  [4,2,3],\n                  [6,8,9],  [6,7,8],  [6,10,11],[6,11,7], [10,8,11],\n\t\t  [10,9,8], [3,0,9],  [9,0,6],  [10,6, 0],[0,4,10],\n                  [3,9,10], [3,10,4], [1,7,11], [1,11,5], [1,8,7],  \n                  [2,8,1],  [8,2,11], [5,11,2]\n\t\t  ]\n     );\n\nBeginner's tip\n\nIf you don't really understand \"orientation\", try to identify the mis-oriented pink faces and then invert the sequence of the references to the points vectors until you get it right. E.g. in the above example, the third triangle ([0,4,5]) was wrong and we fixed it as [4,0,5]. Remember that a face list is a circular list. In addition, you may select \"Show Edges\" from the \"View Menu\", print a screen capture and number both the points and the faces.  In our example, the points are annotated in black and the faces in blue. Turn the object around and make a second copy from the back if needed. This way you can keep track.\n\nClockwise technique\n\nOrientation is determined by clockwise circular indexing. This means that if you're looking at the triangle (in this case [4,0,5]) from the outside you'll see that the path is clockwise around the center of the face. The winding order [4,0,5] is clockwise and therefore good.  The winding order [0,4,5] is counter-clockwise and therefore bad. Likewise, any other clockwise order of [4,0,5] works: [5,4,0] & [0,5,4] are good too. If you use the clockwise technique, you'll always have your faces outside (outside of OpenSCAD, other programs do use counter-clockwise as the outside though).\n\nThink of it as a \"left hand rule\":\n\nIf you place your left hand on the face with your fingers curled in the direction of the order of the points, your thumb should point outward. If your thumb points inward, you need to reverse the winding order.\n\nPolyhedron with badly oriented polygons\n\nSuccinct description of a 'Polyhedron'\n\nPoints define all of the points/vertices in the shape.\nFaces is a list of polygons that connect up the points/vertices.\n\nEach point, in the point list, is defined with a 3-tuple x,y,z position specification. Points in the point list are automatically enumerated starting from zero for use in the faces list (0,1,2,3,... etc).\n\nEach face, in the faces list, is defined by selecting 3 or more of the points (using the point order number) out of the point list.\n\ne.g. faces=[ [0,1,2] ] defines a triangle from the first point (points are zero referenced) to the second point and then to the third point.\n\nWhen looking at any face from the outside, the face must list all points in a clockwise order.\n\nPoint repetitions in a polyhedron point list[edit | edit source]\n\nThe point list of the polyhedron definition may have repetitions. When two or more points have the same coordinates they are considered the same polyhedron vertex. So, the following polyhedron:\n\npoints = [[ 0, 0, 0], [10, 0, 0], [ 0,10, 0],\n          [ 0, 0, 0], [10, 0, 0], [ 0,10, 0],\n          [ 0,10, 0], [10, 0, 0], [ 0, 0,10],\n          [ 0, 0, 0], [ 0, 0,10], [10, 0, 0],\n          [ 0, 0, 0], [ 0,10, 0], [ 0, 0,10]];\npolyhedron(points, [[0,1,2], [3,4,5], [6,7,8], [9,10,11], [12,13,14]]);\n\ndefine the same tetrahedron as:\n\npoints = [[0,0,0], [0,10,0], [10,0,0], [0,0,10]];\npolyhedron(points, [[0,2,1], [0,1,3], [1,2,3], [0,3,2]]);",
      "content": {},
      "codeExamples": [
        {
          "code": "cube(size = [x,y,z], center = true/false);\ncube(size =  x ,     center = true/false);",
          "context": "Creates a cube or rectangular prism (i.e., a \"box\") in the first octant. When center is true, the cube is centered on the origin. Argument names are optional if given in the order shown here."
        },
        {
          "code": "default values:  cube();   yields:  cube(size = [1, 1, 1], center = false);",
          "context": "size\nsingle value, cube with all sides this length\n3 value array [x,y,z], rectangular prism with dimensions x, y and z.\ncenter\nfalse (default), 1st (positive) octant, one corner at (0,0,0)\ntrue, cube is centered at (0,0,0)"
        },
        {
          "code": "equivalent scripts for this example\n cube(size = 18);\n cube(18);\n cube([18,18,18]);\n .\n cube(18,false);\n cube([18,18,18],false);\n cube([18,18,18],center=false);\n cube(size = [18,18,18], center = false);\n cube(center = false,size = [18,18,18] );",
          "context": "default values:  cube();   yields:  cube(size = [1, 1, 1], center = false);"
        },
        {
          "code": "equivalent scripts for this example\n cube([18,28,8],true);\n box=[18,28,8];cube(box,true);",
          "context": "equivalent scripts for this example\n cube(size = 18);\n cube(18);\n cube([18,18,18]);\n .\n cube(18,false);\n cube([18,18,18],false);\n cube([18,18,18],center=false);\n cube(size = [18,18,18], center = false);\n cube(center = false,size = [18,18,18] );"
        },
        {
          "code": "default values:  sphere();   yields:   sphere($fn = 0, $fa = 12, $fs = 2, r = 1);",
          "context": "r\nRadius.  This is the radius of the sphere.  The resolution of the sphere is based on the size of the sphere and the $fa, $fs and $fn variables. For more information on these special variables look at: OpenSCAD_User_Manual/Other_Language_Features\nd\nDiameter.  This is the diameter of the sphere.\n$fa\nFragment angle in degrees\n$fs\nFragment size in mm\n$fn\nResolution"
        },
        {
          "code": "sphere(r = 1);\nsphere(r = 5);\nsphere(r = 10);\nsphere(d = 2);\nsphere(d = 10);\nsphere(d = 20);",
          "context": "Usage Examples"
        },
        {
          "code": "// this creates a high resolution sphere with a 2mm radius\nsphere(2, $fn=100);",
          "context": "sphere(r = 1);\nsphere(r = 5);\nsphere(r = 10);\nsphere(d = 2);\nsphere(d = 10);\nsphere(d = 20);"
        },
        {
          "code": "// also creates a 2mm high resolution sphere but this one \n// does not have as many small triangles on the poles of the sphere\nsphere(2, $fa=5, $fs=0.1);",
          "context": "// this creates a high resolution sphere with a 2mm radius\nsphere(2, $fn=100);"
        },
        {
          "code": "cylinder(h = height, r1 = BottomRadius, r2 = TopRadius, center = true/false);",
          "context": "Parameter names are optional if given in the order shown here. If a parameter is named, all following parameters must also be named."
        },
        {
          "code": "defaults: cylinder();  yields: cylinder($fn = 0, $fa = 12, $fs = 2, h = 1, r1 = 1, r2 = 1, center = false);",
          "context": "h : height of the cylinder or cone\nr  : radius of cylinder. r1 = r2 = r.\nr1 : radius, bottom of cone.\nr2 : radius, top of cone.\nd  : diameter of cylinder. r1 = r2 = d / 2. [Note: Requires version 2014.03]\nd1 : diameter, bottom of cone. r1 = d1 / 2. [Note: Requires version 2014.03]\nd2 : diameter, top of cone. r2 = d2 / 2. [Note: Requires version 2014.03]\ncenter\nfalse (default), z ranges from 0 to h\ntrue,  z ranges from -h/2 to +h/2\n$fa : minimum angle (in degrees) of each fragment.\n$fs : minimum circumferential length of each fragment.\n$fn : fixed number of fragments in 360 degrees. Values of 3 or more override $fa and $fs\n$fa, $fs and $fn must be named parameters. click here for more details,."
        },
        {
          "code": "equivalent scripts\n cylinder(h=15, r1=9.5, r2=19.5, center=false);\n cylinder(  15,    9.5,    19.5, false);\n cylinder(  15,    9.5,    19.5);\n cylinder(  15,    9.5, d2=39  );\n cylinder(  15, d1=19,  d2=39  );\n cylinder(  15, d1=19,  r2=19.5);",
          "context": "defaults: cylinder();  yields: cylinder($fn = 0, $fa = 12, $fs = 2, h = 1, r1 = 1, r2 = 1, center = false);"
        },
        {
          "code": "equivalent scripts\n cylinder(h=15, r1=10, r2=0, center=true);\n cylinder(  15,    10,    0,        true);\n cylinder(h=15, d1=20, d2=0, center=true);",
          "context": "equivalent scripts\n cylinder(h=15, r1=9.5, r2=19.5, center=false);\n cylinder(  15,    9.5,    19.5, false);\n cylinder(  15,    9.5,    19.5);\n cylinder(  15,    9.5, d2=39  );\n cylinder(  15, d1=19,  d2=39  );\n cylinder(  15, d1=19,  r2=19.5);"
        },
        {
          "code": "equivalent scripts\n cylinder(h=20, r=10, center=true);\n cylinder(  20,   10, 10,true);\n cylinder(  20, d=20, center=true);\n cylinder(  20,r1=10, d2=20, center=true);\n cylinder(  20,r1=10, d2=2*10, center=true);",
          "context": "center = false\n\t\t\n\t\t\n\t\t\t\n\t\t\tcenter = true"
        },
        {
          "code": "scripts for these examples\n cylinder(20,20,20,$fn=3);\n cylinder(20,20,00,$fn=4);\n cylinder(20,20,10,$fn=4);",
          "context": "However, use of small values can produce some interesting non circular objects. A few examples are show here:"
        },
        {
          "code": "script for this example\n poly_n = 6;\n color(\"blue\") translate([0, 0, 0.02]) linear_extrude(0.1) circle(10, $fn=poly_n);\n color(\"green\") translate([0, 0, 0.01]) linear_extrude(0.1) circle(10, $fn=360);\n color(\"purple\") linear_extrude(0.1) circle(10/cos(180/poly_n), $fn=poly_n);",
          "context": "Using cylinder() with difference() to place holes in objects creates undersized holes. This is because circular paths are approximated with polygons inscribed within in a circle. The points of the polygon are on the circle, but straight lines between are inside. To have all of the hole larger than the true circle, the polygon must lie wholly outside of the circle (circumscribed). Modules for circumscribed holes"
        },
        {
          "code": "polyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], triangles = [ [P0, P1, P2], ... ], convexity = N);   // before 2014.03\npolyhedron( points = [ [X0, Y0, Z0], [X1, Y1, Z1], ... ], faces = [ [P0, P1, P2, P3, ...], ... ], convexity = N);   // 2014.03 & later",
          "context": "A polyhedron is the most general 3D primitive solid. It can be used to create any regular or irregular shape including those with concave as well as convex features. Curved surfaces are approximated by a series of flat surfaces."
        },
        {
          "code": "default values: polyhedron(); yields: polyhedron(points = undef, faces = undef, convexity = 1);",
          "context": "convexity\nInteger. The convexity parameter specifies the maximum number of faces a ray intersecting the object might penetrate. This parameter is needed only for correct display of the object in OpenCSG preview mode. It has no effect on the polyhedron rendering. For display problems, setting it to 10 should work fine for most cases."
        },
        {
          "code": "CubePoints = [\n  [  0,  0,  0 ],  //0\n  [ 10,  0,  0 ],  //1\n  [ 10,  7,  0 ],  //2\n  [  0,  7,  0 ],  //3\n  [  0,  0,  5 ],  //4\n  [ 10,  0,  5 ],  //5\n  [ 10,  7,  5 ],  //6\n  [  0,  7,  5 ]]; //7\n  \nCubeFaces = [\n  [0,1,2,3],  // bottom\n  [4,5,1,0],  // front\n  [7,6,5,4],  // top\n  [5,6,2,1],  // right\n  [6,7,3,2],  // back\n  [7,4,0,3]]; // left\n  \npolyhedron( CubePoints, CubeFaces );",
          "context": "unfolded cube faces"
        },
        {
          "code": "equivalent descriptions of the bottom face\n  [0,1,2,3],\n  [0,1,2,3,0],\n  [1,2,3,0],\n  [2,3,0,1],\n  [3,0,1,2],\n  [0,1,2],[2,3,0],   // 2 triangles with no overlap\n  [1,2,3],[3,0,1],\n  [1,2,3],[0,1,3],",
          "context": "CubePoints = [\n  [  0,  0,  0 ],  //0\n  [ 10,  0,  0 ],  //1\n  [ 10,  7,  0 ],  //2\n  [  0,  7,  0 ],  //3\n  [  0,  0,  5 ],  //4\n  [ 10,  0,  5 ],  //5\n  [ 10,  7,  5 ],  //6\n  [  0,  7,  5 ]]; //7\n  \nCubeFaces = [\n  [0,1,2,3],  // bottom\n  [4,5,1,0],  // front\n  [7,6,5,4],  // top\n  [5,6,2,1],  // right\n  [6,7,3,2],  // back\n  [7,4,0,3]]; // left\n  \npolyhedron( CubePoints, CubeFaces );"
        },
        {
          "code": "polyhedron(\n  points=[ [10,10,0],[10,-10,0],[-10,-10,0],[-10,10,0], // the four points at base\n           [0,0,10]  ],                                 // the apex point \n  faces=[ [0,1,4],[1,2,4],[2,3,4],[3,0,4],              // each triangle side\n              [1,0,3],[2,1,3] ]                         // two triangles for square base\n );",
          "context": "A simple polyhedron, square base pyramid"
        },
        {
          "code": "module prism(l, w, h){\n      polyhedron(//pt 0        1        2        3        4        5\n              points=[[0,0,0], [l,0,0], [l,w,0], [0,w,0], [0,w,h], [l,w,h]],\n              faces=[[0,1,2,3],[5,4,3,2],[0,4,5,1],[0,3,4],[5,2,1]]\n              );\n      \n      // preview unfolded (do not include in your function\n      z = 0.08;\n      separation = 2;\n      border = .2;\n      translate([0,w+separation,0])\n          cube([l,w,z]);\n      translate([0,w+separation+w+border,0])\n          cube([l,h,z]);\n      translate([0,w+separation+w+border+h+border,0])\n          cube([l,sqrt(w*w+h*h),z]);\n      translate([l+border,w+separation,0])\n          polyhedron(//pt 0       1       2        3       4       5\n                  points=[[0,0,0],[h,w,0],[0,w,0], [0,0,z],[h,w,z],[0,w,z]],\n                  faces=[[0,1,2], [3,5,4], [0,3,4,1], [1,4,5,2], [2,5,3,0]]\n                  );\n      translate([0-border,w+separation,0])\n          polyhedron(//pt 0       1         2        3       4         5\n                  points=[[0,0,0],[0-h,w,0],[0,w,0], [0,0,z],[0-h,w,z],[0,w,z]],\n                  faces=[[1,0,2],[5,3,4],[0,1,4,3],[1,2,5,4],[2,0,3,5]]\n                  );\n      }\n  \n  prism(10, 5, 3);",
          "context": "A polyhedron triangular prism"
        },
        {
          "code": "CubeFaces = [\n/* [0,1,2,3],  // bottom\n   [4,5,1,0],  // front */\n   [7,6,5,4],  // top\n/* [5,6,2,1],  // right\n   [6,7,3,2],  // back */\n   [7,4,0,3]]; // left",
          "context": "example 1 showing only 2 faces"
        },
        {
          "code": "// Bad polyhedron\npolyhedron\n    (points = [\n\t       [0, -10, 60], [0, 10, 60], [0, 10, 0], [0, -10, 0], [60, -10, 60], [60, 10, 60], \n\t       [10, -10, 50], [10, 10, 50], [10, 10, 30], [10, -10, 30], [30, -10, 50], [30, 10, 50]\n\t       ], \n     faces = [\n\t\t  [0,2,3],   [0,1,2],  [0,4,5],  [0,5,1],   [5,4,2],  [2,4,3],\n                  [6,8,9],  [6,7,8],  [6,10,11], [6,11,7], [10,8,11],\n\t\t  [10,9,8], [0,3,9],  [9,0,6], [10,6, 0],  [0,4,10],\n                  [3,9,10], [3,10,4], [1,7,11],  [1,11,5], [1,7,8],  \n                  [1,8,2],  [2,8,11], [2,11,5]\n\t\t  ]\n     );",
          "context": "No specific context available"
        },
        {
          "code": "polyhedron\n    (points = [\n\t       [0, -10, 60], [0, 10, 60], [0, 10, 0], [0, -10, 0], [60, -10, 60], [60, 10, 60], \n\t       [10, -10, 50], [10, 10, 50], [10, 10, 30], [10, -10, 30], [30, -10, 50], [30, 10, 50]\n\t       ], \n     faces = [\n\t\t  [0,3,2],  [0,2,1],  [4,0,5],  [5,0,1],  [5,2,4],  [4,2,3],\n                  [6,8,9],  [6,7,8],  [6,10,11],[6,11,7], [10,8,11],\n\t\t  [10,9,8], [3,0,9],  [9,0,6],  [10,6, 0],[0,4,10],\n                  [3,9,10], [3,10,4], [1,7,11], [1,11,5], [1,8,7],  \n                  [2,8,1],  [8,2,11], [5,11,2]\n\t\t  ]\n     );",
          "context": "No specific context available"
        },
        {
          "code": "points = [[ 0, 0, 0], [10, 0, 0], [ 0,10, 0],\n          [ 0, 0, 0], [10, 0, 0], [ 0,10, 0],\n          [ 0,10, 0], [10, 0, 0], [ 0, 0,10],\n          [ 0, 0, 0], [ 0, 0,10], [10, 0, 0],\n          [ 0, 0, 0], [ 0,10, 0], [ 0, 0,10]];\npolyhedron(points, [[0,1,2], [3,4,5], [6,7,8], [9,10,11], [12,13,14]]);",
          "context": "No specific context available"
        },
        {
          "code": "points = [[0,0,0], [0,10,0], [10,0,0], [0,0,10]];\npolyhedron(points, [[0,2,1], [0,1,3], [1,2,3], [0,3,2]]);",
          "context": "No specific context available"
        }
      ]
    },
    "primitives2D": {
      "title": "2D Primitives",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/2D_Primitives",
      "introduction": "All 2D primitives can be transformed with 3D transformations. They are usually used as part of a 3D extrusion. Although they are infinitely thin, they are rendered with a 1-unit thickness.\n\nNote: Trying to subtract with difference() from 3D object will lead to unexpected results in final rendering.\n\nsquare[edit | edit source]\n\nCreates a square or rectangle in the first quadrant. When center is true the square is centered on the origin. Argument names are optional if given in the order shown here.\n\nsquare(size = [x, y], center = true/false);\nsquare(size =  x    , center = true/false);\n\nparameters:\n\nsize\nsingle value, square with both sides this length\n2 value array [x,y], rectangle with dimensions x and y\ncenter\nfalse (default), 1st (positive) quadrant, one corner at (0,0)\ntrue, square is centered at (0,0)\n\ndefault values:  square();   yields:  square(size = [1, 1], center = false);\n\nexamples:\n\nequivalent scripts for this example\n square(size = 10);\n square(10);\n square([10,10]);\n .\n square(10,false);\n square([10,10],false);\n square([10,10],center=false);\n square(size = [10, 10], center = false);\n square(center = false,size = [10, 10] );\n\nequivalent scripts for this example\n square([20,10],true);\n a=[20,10];square(a,true);\n\ncircle[edit | edit source]\n\nCreates a circle at the origin. All parameters, except r, must be named.\n\ncircle(r=radius | d=diameter);\n\nParameters\nr : circle radius. r name is the only one optional with circle.\ncircle resolution is based on size, using $fa or $fs.\n\nFor a small, high resolution circle you can make a large circle, then scale it down, or you could set $fn or other special variables. Note: These examples exceed the resolution of a 3d printer as well as of the display screen.\n\nscale([1/100, 1/100, 1/100]) circle(200); // create a high resolution circle with a radius of 2.\ncircle(2, $fn=50);                        // Another way.\n\nd   : circle diameter (only available in versions later than 2014.03).\n$fa : minimum angle (in degrees) of each fragment.\n$fs : minimum circumferential length of each fragment.\n$fn : fixed number of fragments in 360 degrees. Values of 3 or more override $fa and $fs.\nIf they are used, $fa, $fs and $fn must be named parameters. click here for more details,.\n\ndefaults:  circle(); yields:  circle($fn = 0, $fa = 12, $fs = 2, r = 1);\n\nEquivalent scripts for this example\n\ncircle(10);\n circle(r=10);\n circle(d=20);\n circle(d=2+9*2);\n\nEllipses[edit | edit source]\n\nAn ellipse can be created from a circle by using either scale() or resize() to make the x and y dimensions unequal.\nSee OpenSCAD User Manual/Transformations\n\nequivalent scripts for this example\n resize([30,10])circle(d=20);\n scale([1.5,.5])circle(d=20);\n\nRegular Polygons[edit | edit source]\n\nA regular polygon of 3 or more sides can be created by using circle() with $fn set to the number of sides. The following two pieces of code are equivalent.\n\ncircle(r=1, $fn=4);\n\nmodule regular_polygon(order = 4, r=1){\n     angles=[ for (i = [0:order-1]) i*(360/order) ];\n     coords=[ for (th=angles) [r*cos(th), r*sin(th)] ];\n     polygon(coords);\n }\n regular_polygon();\n\nThese result in the following shapes, where the polygon is inscribed within the circle with all sides (and angles) equal. One corner points to the positive x direction. For irregular shapes see the polygon primitive below.\n\nscript for these examples\n translate([-42,  0]){circle(20,$fn=3);%circle(20,$fn=90);}\n translate([  0,  0]) circle(20,$fn=4);\n translate([ 42,  0]) circle(20,$fn=5);\n translate([-42,-42]) circle(20,$fn=6);\n translate([  0,-42]) circle(20,$fn=8);\n translate([ 42,-42]) circle(20,$fn=12);\n \n color(\"black\"){\n     translate([-42,  0,1])text(\"3\",7,,center);\n     translate([  0,  0,1])text(\"4\",7,,center);\n     translate([ 42,  0,1])text(\"5\",7,,center);\n     translate([-42,-42,1])text(\"6\",7,,center);\n     translate([  0,-42,1])text(\"8\",7,,center);\n     translate([ 42,-42,1])text(\"12\",7,,center);\n }\n\npolygon[edit | edit source]\n\nThe function polygon() creates a multiple sided shape from a list of x,y coordinates. A polygon is the most powerful 2D object. It can create anything that circle and squares can, as well as much more. This includes irregular shapes with both concave and convex edges. In addition it can place holes within that shape.\n\npolygon(points = [ [x, y], ... ], paths = [ [p1, p2, p3..], ...], convexity = N);\n\nParameters\n\npoints\nThe list of x,y points of the polygon. : A vector of 2 element vectors.\nNote: points are indexed from 0 to n-1.\npaths\ndefault\nIf no path is specified, all points are used in the order listed.\nsingle vector\nThe order to traverse the points. Uses indices from 0 to n-1. May be in a different order and use all or part, of the points listed.\nmultiple vectors\nCreates primary and secondary shapes. Secondary shapes are subtracted from the primary shape (like difference()). Secondary shapes may be wholly or partially within the primary shape.\n\nA closed shape is created by returning from the last point specified to the first.\n\nconvexity\nInteger number of \"inward\" curves, ie. expected path crossings of an arbitrary line through the polygon. See below.\n\ndefaults:   polygon();  yields:  polygon(points = undef, paths = undef, convexity = 1);\n\nWithout holes[edit | edit source]\n\nequivalent scripts for this example\n polygon(points=[[0,0],[100,0],[130,50],[30,50]]);\n polygon([[0,0],[100,0],[130,50],[30,50]], paths=[[0,1,2,3]]);\n polygon([[0,0],[100,0],[130,50],[30,50]],[[3,2,1,0]]);\n polygon([[0,0],[100,0],[130,50],[30,50]],[[1,0,3,2]]);\n    \n a=[[0,0],[100,0],[130,50],[30,50]];\n b=[[3,0,1,2]];\n polygon(a);\n polygon(a,b);\n polygon(a,[[2,3,0,1,2]]);\n\nOne hole[edit | edit source]\n\nequivalent scripts for this example\n polygon(points=[[0,0],[100,0],[0,100],[10,10],[80,10],[10,80]], paths=[[0,1,2],[3,4,5]],convexity=10);\n\n triangle_points =[[0,0],[100,0],[0,100],[10,10],[80,10],[10,80]];\n triangle_paths =[[0,1,2],[3,4,5]];\n polygon(triangle_points,triangle_paths,10);\n\nThe 1st path vector, [0,1,2], selects the points, [0,0],[100,0],[0,100], for the primary shape.\nThe 2nd path vector, [3,4,5], selects the points, [10,10],[80,10],[10,80], for the secondary shape.\nThe secondary shape is subtracted from the primary ( think difference() ).\nSince the secondary is wholly within the primary, it leaves a shape with a hole.\n\nMulti hole[edit | edit source]\n\n[Note: Requires version 2015.03] (for use of concat())\n\n//example polygon with multiple holes\na0 = [[0,0],[100,0],[130,50],[30,50]];     // main\nb0 = [1,0,3,2];\na1 = [[20,20],[40,20],[30,30]];            // hole 1\nb1 = [4,5,6];\na2 = [[50,20],[60,20],[40,30]];            // hole 2\nb2 = [7,8,9];\na3 = [[65,10],[80,10],[80,40],[65,40]];    // hole 3\nb3 = [10,11,12,13];\na4 = [[98,10],[115,40],[85,40],[85,10]];   // hole 4\nb4 = [14,15,16,17];\na  = concat (a0,a1,a2,a3,a4);\nb  = [b0,b1,b2,b3,b4];\npolygon(a,b);\n      //alternate \npolygon(a,[b0,b1,b2,b3,b4]);\n\nExtruding a 3D shape from a polygon[edit | edit source]\n\ntranslate([0,-20,10]) {\n       rotate([90,180,90]) {\n           linear_extrude(50) {\n               polygon(\n                   points = [\n                      //x,y\n                       /*\n                                  O  .\n                       */\n                       [-2.8,0],\n                       /*\n                                O__X  .\n                       */\n                       [-7.8,0],\n                       /*\n                              O\n                               \\\n                                X__X  .\n                       */\n                       [-15.3633,10.30],\n                       /*\n                              X_______._____O\n                               \\         \n                                X__X  .\n                       */\n                       [15.3633,10.30],\n                       /*\n                              X_______._______X\n                               \\             /\n                                X__X  .     O\n                       */\n                       [7.8,0],\n                       /*\n                              X_______._______X\n                               \\             /\n                                X__X  .  O__X\n                       */\n                       [2.8,0],\n                       /*\n                           X__________.__________X\n                            \\                   /\n                             \\              O  /\n                              \\            /  /\n                               \\          /  /\n                                X__X  .  X__X\n                       */\n                       [5.48858,5.3],\n                       /*\n                           X__________.__________X\n                            \\                   /\n                             \\   O__________X  /\n                              \\            /  /\n                               \\          /  /\n                                X__X  .  X__X\n                       */\n                       [-5.48858,5.3],\n                                   ]\n                               );\n                           }\n       }\n   }\n\nconvexity[edit | edit source]\n\nThe convexity parameter specifies the maximum number of front sides (back sides) a ray intersecting the object might penetrate.\nThis parameter is needed only for correct display of the object in OpenCSG preview mode and has no effect on the polyhedron rendering.\n\nThis image shows a 2D shape with a convexity of 2, as the ray indicated in red crosses the 2D shapes outside⇒inside (or inside⇒outside) a maximum of 2 times. The convexity of a 3D shape would be determined in a similar way. Setting it to 10 should work fine for most cases.\n\nimport_dxf[edit | edit source]\n\n[Deprecated: import_dxf() will be removed in future releases. Use import() instead.]\n\nRead a DXF file and create a 2D shape.\n\nExample\n\nlinear_extrude(height = 5, center = true, convexity = 10)\n\t\timport_dxf(file = \"example009.dxf\", layer = \"plate\");",
      "content": {},
      "codeExamples": [
        {
          "code": "square(size = [x, y], center = true/false);\nsquare(size =  x    , center = true/false);",
          "context": "Creates a square or rectangle in the first quadrant. When center is true the square is centered on the origin. Argument names are optional if given in the order shown here."
        },
        {
          "code": "default values:  square();   yields:  square(size = [1, 1], center = false);",
          "context": "size\nsingle value, square with both sides this length\n2 value array [x,y], rectangle with dimensions x and y\ncenter\nfalse (default), 1st (positive) quadrant, one corner at (0,0)\ntrue, square is centered at (0,0)"
        },
        {
          "code": "equivalent scripts for this example\n square(size = 10);\n square(10);\n square([10,10]);\n .\n square(10,false);\n square([10,10],false);\n square([10,10],center=false);\n square(size = [10, 10], center = false);\n square(center = false,size = [10, 10] );",
          "context": "default values:  square();   yields:  square(size = [1, 1], center = false);"
        },
        {
          "code": "equivalent scripts for this example\n square([20,10],true);\n a=[20,10];square(a,true);",
          "context": "equivalent scripts for this example\n square(size = 10);\n square(10);\n square([10,10]);\n .\n square(10,false);\n square([10,10],false);\n square([10,10],center=false);\n square(size = [10, 10], center = false);\n square(center = false,size = [10, 10] );"
        },
        {
          "code": "circle(r=radius | d=diameter);",
          "context": "Creates a circle at the origin. All parameters, except r, must be named."
        },
        {
          "code": "scale([1/100, 1/100, 1/100]) circle(200); // create a high resolution circle with a radius of 2.\ncircle(2, $fn=50);                        // Another way.",
          "context": "For a small, high resolution circle you can make a large circle, then scale it down, or you could set $fn or other special variables. Note: These examples exceed the resolution of a 3d printer as well as of the display screen."
        },
        {
          "code": "defaults:  circle(); yields:  circle($fn = 0, $fa = 12, $fs = 2, r = 1);",
          "context": "d   : circle diameter (only available in versions later than 2014.03).\n$fa : minimum angle (in degrees) of each fragment.\n$fs : minimum circumferential length of each fragment.\n$fn : fixed number of fragments in 360 degrees. Values of 3 or more override $fa and $fs.\nIf they are used, $fa, $fs and $fn must be named parameters. click here for more details,."
        },
        {
          "code": "circle(10);\n circle(r=10);\n circle(d=20);\n circle(d=2+9*2);",
          "context": "Equivalent scripts for this example"
        },
        {
          "code": "equivalent scripts for this example\n resize([30,10])circle(d=20);\n scale([1.5,.5])circle(d=20);",
          "context": "An ellipse can be created from a circle by using either scale() or resize() to make the x and y dimensions unequal.\nSee OpenSCAD User Manual/Transformations"
        },
        {
          "code": "circle(r=1, $fn=4);",
          "context": "A regular polygon of 3 or more sides can be created by using circle() with $fn set to the number of sides. The following two pieces of code are equivalent."
        },
        {
          "code": "module regular_polygon(order = 4, r=1){\n     angles=[ for (i = [0:order-1]) i*(360/order) ];\n     coords=[ for (th=angles) [r*cos(th), r*sin(th)] ];\n     polygon(coords);\n }\n regular_polygon();",
          "context": "circle(r=1, $fn=4);"
        },
        {
          "code": "script for these examples\n translate([-42,  0]){circle(20,$fn=3);%circle(20,$fn=90);}\n translate([  0,  0]) circle(20,$fn=4);\n translate([ 42,  0]) circle(20,$fn=5);\n translate([-42,-42]) circle(20,$fn=6);\n translate([  0,-42]) circle(20,$fn=8);\n translate([ 42,-42]) circle(20,$fn=12);\n \n color(\"black\"){\n     translate([-42,  0,1])text(\"3\",7,,center);\n     translate([  0,  0,1])text(\"4\",7,,center);\n     translate([ 42,  0,1])text(\"5\",7,,center);\n     translate([-42,-42,1])text(\"6\",7,,center);\n     translate([  0,-42,1])text(\"8\",7,,center);\n     translate([ 42,-42,1])text(\"12\",7,,center);\n }",
          "context": "These result in the following shapes, where the polygon is inscribed within the circle with all sides (and angles) equal. One corner points to the positive x direction. For irregular shapes see the polygon primitive below."
        },
        {
          "code": "polygon(points = [ [x, y], ... ], paths = [ [p1, p2, p3..], ...], convexity = N);",
          "context": "The function polygon() creates a multiple sided shape from a list of x,y coordinates. A polygon is the most powerful 2D object. It can create anything that circle and squares can, as well as much more. This includes irregular shapes with both concave and convex edges. In addition it can place holes within that shape."
        },
        {
          "code": "defaults:   polygon();  yields:  polygon(points = undef, paths = undef, convexity = 1);",
          "context": "convexity\nInteger number of \"inward\" curves, ie. expected path crossings of an arbitrary line through the polygon. See below."
        },
        {
          "code": "equivalent scripts for this example\n polygon(points=[[0,0],[100,0],[130,50],[30,50]]);\n polygon([[0,0],[100,0],[130,50],[30,50]], paths=[[0,1,2,3]]);\n polygon([[0,0],[100,0],[130,50],[30,50]],[[3,2,1,0]]);\n polygon([[0,0],[100,0],[130,50],[30,50]],[[1,0,3,2]]);\n    \n a=[[0,0],[100,0],[130,50],[30,50]];\n b=[[3,0,1,2]];\n polygon(a);\n polygon(a,b);\n polygon(a,[[2,3,0,1,2]]);",
          "context": "Without holes[edit | edit source]"
        },
        {
          "code": "equivalent scripts for this example\n polygon(points=[[0,0],[100,0],[0,100],[10,10],[80,10],[10,80]], paths=[[0,1,2],[3,4,5]],convexity=10);\n\n triangle_points =[[0,0],[100,0],[0,100],[10,10],[80,10],[10,80]];\n triangle_paths =[[0,1,2],[3,4,5]];\n polygon(triangle_points,triangle_paths,10);",
          "context": "One hole[edit | edit source]"
        },
        {
          "code": "//example polygon with multiple holes\na0 = [[0,0],[100,0],[130,50],[30,50]];     // main\nb0 = [1,0,3,2];\na1 = [[20,20],[40,20],[30,30]];            // hole 1\nb1 = [4,5,6];\na2 = [[50,20],[60,20],[40,30]];            // hole 2\nb2 = [7,8,9];\na3 = [[65,10],[80,10],[80,40],[65,40]];    // hole 3\nb3 = [10,11,12,13];\na4 = [[98,10],[115,40],[85,40],[85,10]];   // hole 4\nb4 = [14,15,16,17];\na  = concat (a0,a1,a2,a3,a4);\nb  = [b0,b1,b2,b3,b4];\npolygon(a,b);\n      //alternate \npolygon(a,[b0,b1,b2,b3,b4]);",
          "context": "[Note: Requires version 2015.03] (for use of concat())"
        },
        {
          "code": "translate([0,-20,10]) {\n       rotate([90,180,90]) {\n           linear_extrude(50) {\n               polygon(\n                   points = [\n                      //x,y\n                       /*\n                                  O  .\n                       */\n                       [-2.8,0],\n                       /*\n                                O__X  .\n                       */\n                       [-7.8,0],\n                       /*\n                              O\n                               \\\n                                X__X  .\n                       */\n                       [-15.3633,10.30],\n                       /*\n                              X_______._____O\n                               \\         \n                                X__X  .\n                       */\n                       [15.3633,10.30],\n                       /*\n                              X_______._______X\n                               \\             /\n                                X__X  .     O\n                       */\n                       [7.8,0],\n                       /*\n                              X_______._______X\n                               \\             /\n                                X__X  .  O__X\n                       */\n                       [2.8,0],\n                       /*\n                           X__________.__________X\n                            \\                   /\n                             \\              O  /\n                              \\            /  /\n                               \\          /  /\n                                X__X  .  X__X\n                       */\n                       [5.48858,5.3],\n                       /*\n                           X__________.__________X\n                            \\                   /\n                             \\   O__________X  /\n                              \\            /  /\n                               \\          /  /\n                                X__X  .  X__X\n                       */\n                       [-5.48858,5.3],\n                                   ]\n                               );\n                           }\n       }\n   }",
          "context": "Extruding a 3D shape from a polygon[edit | edit source]"
        },
        {
          "code": "linear_extrude(height = 5, center = true, convexity = 10)\n\t\timport_dxf(file = \"example009.dxf\", layer = \"plate\");",
          "context": "Read a DXF file and create a 2D shape."
        }
      ]
    },
    "transformations": {
      "title": "Transformations",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Transformations",
      "introduction": "Basic concept[edit | edit source]\n\nTransformations affect their child nodes and as the name implies transform them in various ways such as moving, rotating or scaling the child.\nTransformations are written before the object they affect e.g.\n\ntranslate([10,20,30])\n    cube(10);\n\nNotice that there is no semicolon following transformation command.\nTransformations can be applied to a group of child nodes by using '{' and '}' to enclose the subtree e.g.\n\ntranslate([0,0,-5])\n{\n    cube(10);\n    cylinder(r=5,h=10);\n}\n\nCascading transformations are used to apply a variety of transforms to a final child. Cascading is achieved by nesting statements e.g.\n\nrotate([45,45,45])\n    translate([10,20,30])\n        cube(10);\n\nWhen combing transforms, order is important\n\nCombining transformations is a sequential process, going from right to left. Consider the following two transformations:\n\ncolor(\"red\")   translate([0,10,0])  rotate([45,0,0])     cube(5);\ncolor(\"green\") rotate([45,0,0])     translate([0,10,0])  cube(5);\n\nWhile these contain the same operations, the first rotates a cube around the origin and then moves it by the offset specified for the translate, before finally coloring it red.\nBy contrast, the second sequence first moves a cube, and then rotates it around the origin, before coloring it green. In this case the rotation causes the cube to move along an arc centered at the origin. The radius of this arc is the distance from the origin, which was set by the preceding translation. The different ordering of the rotate and translate transformations causes the cubes to end up in different places.\n\nAdvanced concept[edit | edit source]\n\nAs OpenSCAD uses different libraries to implement capabilities this can introduce some inconsistencies to the F5 preview behaviour of transformations. Traditional transforms (translate, rotate, scale, mirror & multimatrix) are performed using OpenGL in preview, while other more advanced transforms, such as resize, perform a CGAL operation, behaving like a CSG operation affecting the underlying object, not just transforming it. In particular this can affect the display of modifier characters, specifically \"#\" and \"%\", where the highlight may not display intuitively, such as highlighting the pre-resized object, but highlighting the post-scaled object.\n\nscale[edit | edit source]\n\nScales its child elements using the specified vector. The argument name is optional.\n\nUsage Example:\nscale(v = [x, y, z]) { ... }\n\ncube(10);\ntranslate([15,0,0]) scale([0.5,1,2]) cube(10);\n\nresize[edit | edit source]\n\nModifies the size of the child object to match the given x,y, and z.\n\nresize() is a CGAL operation, and like others such as render() operates with full geometry, so even in preview this takes time to process.\n\nUsage Example:\n\n// resize the sphere to extend 30 in x, 60 in y, and 10 in the z directions.\nresize(newsize=[30,60,10]) sphere(r=10);\n\nIf x,y, or z is 0 then that dimension is left as-is.\n\n// resize the 1x1x1 cube to 2x2x1\nresize([2,2,0]) cube();\n\nIf the 'auto' parameter is set to true, it auto-scales any 0-dimensions to match. For example.\n\n// resize the 1x2x0.5 cube to 7x14x3.5\nresize([7,0,0], auto=true) cube([1,2,0.5]);\n\nThe 'auto' parameter can also be used if you only wish to auto-scale a single dimension, and leave the other as-is.\n\n// resize to 10x8x1. Note that the z dimension is left alone.\nresize([10,0,0], auto=[true,true,false]) cube([5,4,1]);\n\nrotate[edit | edit source]\n\nRotates its child 'a' degrees about the axis of the coordinate system or around an arbitrary axis.\nThe argument names are optional if the arguments are given in the same order as specified.\n\n//Usage:\nrotate(a = deg_a, v = [x, y, z]) { ... }  \n// or\nrotate(deg_a, [x, y, z]) { ... }\nrotate(a = [deg_x, deg_y, deg_z]) { ... }\nrotate([deg_x, deg_y, deg_z]) { ... }\n\nThe 'a' argument (deg_a) can be an array, as expressed in the later usage above; when deg_a is an array, the 'v' argument is ignored. Where 'a' specifies multiple axes then the rotation is applied in the following order: x then y then z. That means the code:\n\nrotate(a=[ax,ay,az]) {...}\n\nis equivalent to:\n\nrotate(a=[0,0,az]) rotate(a=[0,ay,0]) rotate(a=[ax,0,0]) {...}\n\nFor example, to flip an object upside-down, you can rotate your object 180 degrees around the 'y' axis.\n\nrotate(a=[0,180,0]) { ... }\n\nThis is frequently simplified to\n\nrotate([0,180,0]) { ... }\n\nThe optional argument 'v' is a vector that determines an arbitrary axis about which the object is rotated.\n\nWhen specifying a single axis the 'v' argument allows you to specify which axis is the basis for rotation. For example, the equivalent to the above, to rotate just around y\n\nrotate(a=180, v=[0,1,0]) { ... }\n\nWhen specifying a single axis, 'v' is a vector defining an arbitrary axis for rotation; this is different from the multiple axis above. For example, rotate your object 45 degrees around the axis defined by the vector [1,1,0],\n\nrotate(a=45, v=[1,1,0]) { ... }\n\nRotate with a single scalar argument rotates around the Z axis. This is useful in 2D contexts where that is the only axis for rotation. For example:\n\nrotate(45) square(10);\n\nRotation rule help[edit | edit source]\n\nRight-hand grip rule\n\nFor the case of:\n\nrotate([a, b, c]) { ... };\n\n\"a\" is a rotation about the X axis, from the +Y axis, toward the +Z axis. \n\n\"b\" is a rotation about the Y axis, from the +Z axis, toward the +X axis.\n\n\"c\" is a rotation about the Z axis, from the +X axis, toward the +Y axis.\n\nThese are all cases of the  Right Hand Rule. Point your right thumb along the positive axis, your fingers show the direction of rotation.\n\nThus if \"a\" is fixed to zero, and \"b\" and \"c\" are manipulated appropriately, this is the spherical coordinate system.\n\nSo, to construct a cylinder from the origin to some other point (x,y,z):\n\nx= 10; y = 10; z = 10; // point coordinates of end of cylinder\n \nlength = norm([x,y,z]);  // radial distance\nb = acos(z/length); // inclination angle\nc = atan2(y,x);     // azimuthal angle\n\nrotate([0, b, c]) \n    cylinder(h=length, r=0.5);\n%cube([x,y,z]); // corner of cube should coincide with end of cylinder\n\ntranslate[edit | edit source]\n\nTranslates (moves) its child elements along the specified vector. The argument name is optional.\n\nExample:\ntranslate(v = [x, y, z]) { ... }\n\ncube(2,center = true); \ntranslate([5,0,0]) \n   sphere(1,center = true);\n\nmirror[edit | edit source]\n\nTransforms the child element to a mirror of the original, as if it were the mirror image seen through a plane intersecting the origin. The argument to mirror() is the normal vector of the origin-intersecting mirror plane used, meaning the vector coming perpendicularly out of the plane.  Each coordinate of the original object is altered such that it becomes equidistant on the other side of this plane from the closest point on the plane.  For example, mirror([1,0,0]), corresponding to a normal vector pointing in the x-axis direction, produces an object such that all positive x coordinates become negative x coordinates, and all negative x coordinates become positive x coordinates.\n\nFunction signature:[edit | edit source]\n\nmirror(v= [x, y, z] ) { ... }\n\nExamples[edit | edit source]\n\nThe original is on the right side. Note that mirror doesn't make a copy. Like rotate and scale, it changes the object.\n\nhand(); // originalmirror([1,0,0]) hand();\n\t\t\n\t\t\n\t\t\t\n\t\t\thand(); // originalmirror([1,1,0]) hand();\n\t\t\n\t\t\n\t\t\t\n\t\t\thand(); // originalmirror([1,1,1]) hand();\n\nrotate([0,0,10]) cube([3,2,1]);\nmirror([1,0,0]) translate([1,0,0]) rotate([0,0,10]) cube([3,2,1]);\n\nmultmatrix[edit | edit source]\n\nMultiplies the geometry of all child elements with the given affine transformation matrix, where the matrix is 4×3 - a vector of 3 row vectors with 4 elements each, or a 4×4 matrix with the 4th row always forced to [0,0,0,1].\n\nUsage: multmatrix(m = [...]) { ... }\n\nThis is a breakdown of what you can do with the independent elements in the matrix (for the first three rows):\n\nScale XShear X along YShear X along ZTranslate X\nShear Y along XScale YShear Y along ZTranslate Y\nShear Z along XShear Z along YScale ZTranslate Z\n\nThe fourth row is forced to [0,0,0,1] and can be omitted unless you are combining matrices before passing to multmatrix, as it is not processed in OpenSCAD.  Each matrix operates on the points of the given geometry as if each vertex is a 4 element vector consisting of a 3D vector with an implicit 1 as its 4th element, such as v=[x, y, z, 1].  The role of the implicit fourth row of m is to preserve the implicit 1 in the 4th element of the vectors, permitting the translations to work.  The operation of multmatrix therefore performs m*v for each vertex v.  Any elements (other than the 4th row) not specified in m are treated as zeros.\n\nThis example rotates by 45 degrees in the XY plane and translates by [10,20,30], i.e. the same as translate([10,20,30]) rotate([0,0,45]) would do.\n\nangle=45;\nmultmatrix(m = [ [cos(angle), -sin(angle), 0, 10],\n                 [sin(angle),  cos(angle), 0, 20],\n                 [         0,           0, 1, 30],\n                 [         0,           0, 0,  1]\n              ]) union() {\n   cylinder(r=10.0,h=10,center=false);\n   cube(size=[10,10,10],center=false);\n}\n\nThe following example demonstrates combining affine transformation matrices by matrix multiplication, producing in the final version a transformation equivalent to rotate([0, -35, 0]) translate([40, 0, 0]) Obj();.  Note that the signs on the sin function appear to be in a different order than the above example, because the positive one must be ordered as x into y, y into z, z into x for the rotation angles to correspond to rotation about the other axis in a right-handed coordinate system.\n\nmodule Obj() {\n   cylinder(r=10.0,h=10,center=false);\n   cube(size=[10,10,10],center=false);\n}\n\n// This itterates into the future 6 times and demonstrates how multimatrix is moving the object around the center point\nfor(time = [0 : 15 : 90]){\n    y_ang=-time;\n    mrot_y = [ [ cos(y_ang), 0,  sin(y_ang), 0],\n               [         0,  1,           0, 0],\n               [-sin(y_ang), 0,  cos(y_ang), 0],\n               [         0,  0,           0, 1]\n             ];\n    mtrans_x = [ [1, 0, 0, 40],\n                 [0, 1, 0,  0],\n                 [0, 0, 1,  0],\n                 [0, 0, 0,  1]\n               ];\n\n    echo(mrot_y*mtrans_x);\n    \n    // This is the object at [0,0,0]\n    Obj();\n    \n    // This is the starting object at the [40,0,0] coordinate\n    multmatrix(mtrans_x) Obj();\n    \n    // This is the one rotating and appears 6 times\n    multmatrix(mrot_y * mtrans_x) Obj();\n};\n\nThis example skews a model, which is not possible with the other transformations.\n\nM = [ [ 1  , 0  , 0  , 0   ],\n      [ 0  , 1  , 0.7, 0   ],  // The \"0.7\" is the skew value; pushed along the y axis as z changes.\n      [ 0  , 0  , 1  , 0   ],\n      [ 0  , 0  , 0  , 1   ] ] ;\nmultmatrix(M) {  union() {\n    cylinder(r=10.0,h=10,center=false);\n    cube(size=[10,10,10],center=false); \n} }\n\nThis example shows how a vector is transformed with a multmatrix vector, like this all points in a point array (polygon) can be transformed sequentially.\nVector (v) is transformed with a rotation matrix (m), resulting in a new vector (vtrans) which is now rotated and is moving the cube along a circular path radius=v around the z axis without rotating the cube.\n\nangle=45;\n m=[\n        [cos(angle), -sin(angle), 0, 0],\n        [sin(angle),  cos(angle), 0, 0],\n        [         0,           0, 1, 0]\n   ];\n              \nv=[10,0,0];\nvm=concat(v,[1]); // need to add [1]\nvtrans=m*vm;\necho(vtrans);\ntranslate(vtrans)cube();\n\nMore?[edit | edit source]\n\nLearn more about it here:\n\nAffine Transformations on wikipedia\nhttp://www.senocular.com/flash/tutorials/transformmatrix/\n\ncolor[edit | edit source]\n\nDisplays the child elements using the specified RGB color + alpha value. This is only used for the F5 preview as CGAL and STL (F6) do not currently support color. The alpha value defaults to 1.0 (opaque) if not specified.\n\nFunction signature:[edit | edit source]\n\ncolor( c = [r, g, b, a] ) { ... }\ncolor( c = [r, g, b], alpha = 1.0 ) { ... }\ncolor( \"#hexvalue\" ) { ... }\ncolor( \"colorname\", 1.0 ) { ... }\n\nNote that the r, g, b, a values are limited to floating point values in the range [0,1]  rather than the more traditional integers { 0 ... 255 }. However, nothing prevents you from using R, G, B values from {0 ... 255} with appropriate scaling: color([ R/255, G/255, B/255 ]) { ... }\n\n[Note: Requires version 2011.12]\nColors can also be defined by name (case insensitive). For example, to create a red sphere, you can write color(\"red\") sphere(5);. Alpha is specified as an extra parameter for named colors: color(\"Blue\",0.5) cube(5);\n\n[Note: Requires version 2019.05]\nHex values can be given in 4 formats, #rgb, #rgba, #rrggbb and #rrggbbaa. If the alpha value is given in both the hex value and as separate alpha parameter, the alpha parameter takes precedence.\n\nWarning: alpha processing (transparency) is order-sensitive.  Transparent objects must be listed after non-transparent objects to display them correctly.  Some combinations involving multiple transparent objects cannot be handled correctly.  See issue #1390.\n\nThe available color names are taken from the World Wide Web consortium's SVG color list. A chart of the color names is as follows, (note that both spellings of grey/gray including slategrey/slategray etc are valid):\n\nPurples\n\n\nLavender\n\n\nThistle\n\n\nPlum\n\n\nViolet\n\n\nOrchid\n\n\nFuchsia\n\n\nMagenta\n\n\nMediumOrchid\n\n\nMediumPurple\n\n\nBlueViolet\n\n\nDarkViolet\n\n\nDarkOrchid\n\n\nDarkMagenta\n\n\nPurple\n\n\nIndigo\n\n\nDarkSlateBlue\n\n\nSlateBlue\n\n\nMediumSlateBlue\n\n\nReds\n\n\nIndianRed\n\n\nLightCoral\n\n\nSalmon\n\n\nDarkSalmon\n\n\nLightSalmon\n\n\nRed\n\n\nCrimson\n\n\nFireBrick\n\n\nDarkRed\n\n\n\n\n\n\n\nBlues\n\n\nAqua\n\n\nCyan\n\n\nLightCyan\n\n\nPaleTurquoise\n\n\nAquamarine\n\n\nTurquoise\n\n\nMediumTurquoise\n\n\nDarkTurquoise\n\n\nCadetBlue\n\n\nSteelBlue\n\n\nLightSteelBlue\n\n\nPowderBlue\n\n\nLightBlue\n\n\nSkyBlue\n\n\nLightSkyBlue\n\n\nDeepSkyBlue\n\n\nDodgerBlue\n\n\nCornflowerBlue\n\n\nRoyalBlue\n\n\nBlue\n\n\nMediumBlue\n\n\nDarkBlue\n\n\nNavy\n\n\nMidnightBlue\n\n\nPinks\n\n\nPink\n\n\nLightPink\n\n\nHotPink\n\n\nDeepPink\n\n\nMediumVioletRed\n\n\nPaleVioletRed\n\n\n\n\n\n\n\nGreens\n\n\nGreenYellow\n\n\nChartreuse\n\n\nLawnGreen\n\n\nLime\n\n\nLimeGreen\n\n\nPaleGreen\n\n\nLightGreen\n\n\nMediumSpringGreen\n\n\nSpringGreen\n\n\nMediumSeaGreen\n\n\nSeaGreen\n\n\nForestGreen\n\n\nGreen\n\n\nDarkGreen\n\n\nYellowGreen\n\n\nOliveDrab\n\n\nOlive\n\n\nDarkOliveGreen\n\n\nMediumAquamarine\n\n\nDarkSeaGreen\n\n\nLightSeaGreen\n\n\nDarkCyan\n\n\nTeal\n\n\nOranges\n\n\nLightSalmon\n\n\nCoral\n\n\nTomato\n\n\nOrangeRed\n\n\nDarkOrange\n\n\nOrange\n\n\n\n\n\n\n\nYellows\n\n\nGold\n\n\nYellow\n\n\nLightYellow\n\n\nLemonChiffon\n\n\nLightGoldenrodYellow\n\n\nPapayaWhip\n\n\nMoccasin\n\n\nPeachPuff\n\n\nPaleGoldenrod\n\n\nKhaki\n\n\nDarkKhaki\n\n\nBrowns\n\n\nCornsilk\n\n\nBlanchedAlmond\n\n\nBisque\n\n\nNavajoWhite\n\n\nWheat\n\n\nBurlyWood\n\n\nTan\n\n\nRosyBrown\n\n\nSandyBrown\n\n\nGoldenrod\n\n\nDarkGoldenrod\n\n\nPeru\n\n\nChocolate\n\n\nSaddleBrown\n\n\nSienna\n\n\nBrown\n\n\nMaroon\n\n\n\n\n\n\n\n\n\n\nWhites\n\n\nWhite\n\n\nSnow\n\n\nHoneydew\n\n\nMintCream\n\n\nAzure\n\n\nAliceBlue\n\n\nGhostWhite\n\n\nWhiteSmoke\n\n\nSeashell\n\n\nBeige\n\n\nOldLace\n\n\nFloralWhite\n\n\nIvory\n\n\nAntiqueWhite\n\n\nLinen\n\n\nLavenderBlush\n\n\nMistyRose\n\n\nGrays\n\n\nGainsboro\n\n\nLightGrey\n\n\nSilver\n\n\nDarkGray\n\n\nGray\n\n\nDimGray\n\n\nLightSlateGray\n\n\nSlateGray\n\n\nDarkSlateGray\n\n\nBlack\n\nExample[edit | edit source]\n\nA 3-D multicolor sine wave\n\nHere's a code fragment that draws a wavy multicolor object\n\nfor(i=[0:36]) {\n    for(j=[0:36]) {\n      color( [0.5+sin(10*i)/2, 0.5+sin(10*j)/2, 0.5+sin(10*(i+j))/2] )\n      translate( [i, j, 0] )\n      cube( size = [1, 1, 11+10*cos(10*i)*sin(10*j)] );\n    }\n  }\n\n↗\nBeing that -1<=sin(x)<=1 then 0<=(1/2 + sin(x)/2)<=1 , allowing for the RGB components assigned to color to remain within the [0,1] interval.\n\nChart based on \"Web Colors\" from Wikipedia\n\nExample 2[edit | edit source]\n\nIn cases where you want to optionally set a color based on a parameter you can use the following trick:\n\nmodule myModule(withColors=false) {\n    c=withColors?\"red\":undef;\n    color(c) circle(r=10);\n }\n\nSetting the colorname to undef keeps the default colors.\n\noffset[edit | edit source]\n\n[Note: Requires version 2015.03]\n\nOffset generates a new 2d interior or exterior outline from an existing outline.\nThere are two modes of operation: radial and delta.\n\nThe radial method creates a new outline as if a circle of some radius is rotated around the exterior (r > 0) or interior (r < 0) of the original outline.\nThe delta method creates a new outline with sides having a fixed distance outward (delta > 0) or inward (delta < 0) from the original outline.\n\nThe construction methods produce an outline that is either inside or outside of the original outline.\nFor outlines using delta, when the outline goes around a corner, it can be given an optional chamfer.\n\nOffset is useful for making thin walls by subtracting a negative-offset construction from the original, or the original from a positive offset construction.\n\nOffset can be used to simulate some common solid modeling operations:\n\nFillet: offset(r=-3) offset(delta=+3) rounds all inside (concave) corners, and leaves flat walls unchanged.  However, holes less than 2*r in diameter vanish.\nRound: offset(r=+3) offset(delta=-3) rounds all outside (convex) corners, and leaves flat walls unchanged.  However, walls less than 2*r thick vanish.\n\nParameters\n\nThe first parameter may be passed without a name, in which case it is treated as the r parameter below. All other parameters must be named if used.\n\nr or delta\n\nNumber. Amount to offset the polygon. When negative, the polygon is offset inward.\nr (default parameter if not named) specifies the radius of the circle that is rotated about the outline, either inside or outside. This mode produces rounded corners. The name may be omitted; that is, offset(c) is equivalent to offset(r=c).\ndelta specifies the distance of the new outline from the original outline, and therefore reproduces angled corners. No inward perimeter is generated in places where the perimeter would cross itself.\n\nchamfer\nBoolean. (default false) When using the delta parameter, this flag defines if edges should be chamfered (cut off with a straight line) or not (extended to their intersection). This parameter has no effect on radial offsets.\n\n$fa, $fs, and $fn\n\nThe circle resolution special variables may be used to control the smoothness or facet size of curves generated by radial offsets. They have no effect on delta offsets.\n\nPositive r/delta valueNegative r/delta valueResult for different parameters. The black polygon is the input for the offset() operation.\n\nExamples\n\nExample 1: Result.\n\n// Example 1\n \nlinear_extrude(height = 60, twist = 90, slices = 60) {\n   difference() {\n     offset(r = 10) {\n      square(20, center = true);\n     }\n     offset(r = 8) {\n       square(20, center = true);\n     }\n   }\n }\n\n// Example 2\n \nmodule fillet(r) {\n   offset(r = -r) {\n     offset(delta = r) {\n       children();\n     }\n   }\n}\n\nfill[edit | edit source]\n\n[Note: Requires version Development snapshot]\n\nFill removes holes from polygons without changing the outline. For convex polygons the result is identical to hull().\n\nExamples\n\nExample 1: Result.\n\n// Example 1\n \nt = \"OpenSCAD\";\n\nlinear_extrude(15) {\n\ttext(t, 50);\n}\ncolor(\"darkslategray\") {\n\tlinear_extrude(2) {\n\t\toffset(4) {\n\t\t\tfill() {\n\t\t\t\ttext(t, 50);\n\t\t\t}\n\t\t}\n\t}\n}\n\nminkowski[edit | edit source]\n\nA box and a cylinder\n\nMinkowski sum of the box and cylinder\n\nDisplays the minkowski sum of child nodes.\n\nUsage example:\n\nSay you have a flat box, and you want a rounded edge. There are multiple ways to do this (for example, see hull below), but minkowski is elegant. Take your box, and a cylinder:\n\n$fn=50;\n cube([10,10,1]);\n cylinder(r=2,h=1);\n\nThen, do a minkowski sum of them (note that the outer dimensions of the box are now 10+2+2 = 14 units by 14 units by 2 units high as the heights of the objects are summed):\n\n$fn=50;\nminkowski()\n{\n  cube([10,10,1]);\n  cylinder(r=2,h=1);\n}\n\nNB: The origin of the second object is used for the addition. The following minkowski sums are different: the first expands the original cube by +1 in -x, +x, -y, +y from cylinder, expand 0.5 units in both -z, +z from cylinder. The second expands it by +1 in -x, +x, -y, +y and +z from cylinder, but expand 0 in the -z from cylinder.\n\nminkowski() {\n\tcube([10, 10, 1]);\n\tcylinder(1, center=true);\n}\n\nminkowski() {\n\tcube([10, 10, 1]);\n\tcylinder(1);\n}\n\nWarning: for high values of $fn the minkowski sum may end up consuming lots of CPU and memory, since it has to combine every child node of each element with all the nodes of each other element. So if for example $fn=100 and you combine two cylinders, then it does not just perform 200 operations as with two independent cylinders, but 100*100 = 10000 operations.\n\nWarning: if one of the inputs is compound, such as:\n\n{\n         translate([0, 0, collar])\n         sphere(ball);\n         cylinder(collar, ball, ball);\n    }\n\nit may be treated as two separate inputs, resulting in an output which is too large, and has features between surfaces that should be unaltered with respect to one another.  If so, use union().\n\nhull[edit | edit source]\n\nTwo cylinders\n\nConvex hull of two cylinders\n\nDisplays the convex hull of child nodes.\n\nUsage example:\n\nhull() {\n    translate([15,10,0]) circle(10);\n    circle(10);\n}\n\nThe Hull of 2D objects uses their projections (shadows) on the xy plane, and produces a result on the xy plane.  Their Z-height is not used in the operation.\n\nReferring to the illustration of a convex hull of two cylinders, it is computationally more efficient to use hull() on two 2D circles and linear_extrude the resulting 2D shape into a 3D shape, rather than using hull() on two cylinders, even though the resulting object appears identical. Complex geometries involving hull() can be rendered faster by starting out in 2D, if possible.",
      "content": {},
      "codeExamples": [
        {
          "code": "translate([10,20,30])\n    cube(10);",
          "context": "No specific context available"
        },
        {
          "code": "translate([0,0,-5])\n{\n    cube(10);\n    cylinder(r=5,h=10);\n}",
          "context": "No specific context available"
        },
        {
          "code": "rotate([45,45,45])\n    translate([10,20,30])\n        cube(10);",
          "context": "No specific context available"
        },
        {
          "code": "color(\"red\")   translate([0,10,0])  rotate([45,0,0])     cube(5);\ncolor(\"green\") rotate([45,0,0])     translate([0,10,0])  cube(5);",
          "context": "No specific context available"
        },
        {
          "code": "Usage Example:\nscale(v = [x, y, z]) { ... }",
          "context": "Scales its child elements using the specified vector. The argument name is optional."
        },
        {
          "code": "cube(10);\ntranslate([15,0,0]) scale([0.5,1,2]) cube(10);",
          "context": "No specific context available"
        },
        {
          "code": "// resize the sphere to extend 30 in x, 60 in y, and 10 in the z directions.\nresize(newsize=[30,60,10]) sphere(r=10);",
          "context": "No specific context available"
        },
        {
          "code": "// resize the 1x1x1 cube to 2x2x1\nresize([2,2,0]) cube();",
          "context": "No specific context available"
        },
        {
          "code": "// resize the 1x2x0.5 cube to 7x14x3.5\nresize([7,0,0], auto=true) cube([1,2,0.5]);",
          "context": "No specific context available"
        },
        {
          "code": "// resize to 10x8x1. Note that the z dimension is left alone.\nresize([10,0,0], auto=[true,true,false]) cube([5,4,1]);",
          "context": "No specific context available"
        },
        {
          "code": "//Usage:\nrotate(a = deg_a, v = [x, y, z]) { ... }  \n// or\nrotate(deg_a, [x, y, z]) { ... }\nrotate(a = [deg_x, deg_y, deg_z]) { ... }\nrotate([deg_x, deg_y, deg_z]) { ... }",
          "context": "No specific context available"
        },
        {
          "code": "rotate(a=[ax,ay,az]) {...}",
          "context": "The 'a' argument (deg_a) can be an array, as expressed in the later usage above; when deg_a is an array, the 'v' argument is ignored. Where 'a' specifies multiple axes then the rotation is applied in the following order: x then y then z. That means the code:"
        },
        {
          "code": "rotate(a=[0,0,az]) rotate(a=[0,ay,0]) rotate(a=[ax,0,0]) {...}",
          "context": "is equivalent to:"
        },
        {
          "code": "rotate(a=[0,180,0]) { ... }",
          "context": "For example, to flip an object upside-down, you can rotate your object 180 degrees around the 'y' axis."
        },
        {
          "code": "rotate([0,180,0]) { ... }",
          "context": "This is frequently simplified to"
        },
        {
          "code": "rotate(a=180, v=[0,1,0]) { ... }",
          "context": "When specifying a single axis the 'v' argument allows you to specify which axis is the basis for rotation. For example, the equivalent to the above, to rotate just around y"
        },
        {
          "code": "rotate(a=45, v=[1,1,0]) { ... }",
          "context": "When specifying a single axis, 'v' is a vector defining an arbitrary axis for rotation; this is different from the multiple axis above. For example, rotate your object 45 degrees around the axis defined by the vector [1,1,0],"
        },
        {
          "code": "rotate(45) square(10);",
          "context": "Rotate with a single scalar argument rotates around the Z axis. This is useful in 2D contexts where that is the only axis for rotation. For example:"
        },
        {
          "code": "rotate([a, b, c]) { ... };",
          "context": "For the case of:"
        },
        {
          "code": "x= 10; y = 10; z = 10; // point coordinates of end of cylinder\n \nlength = norm([x,y,z]);  // radial distance\nb = acos(z/length); // inclination angle\nc = atan2(y,x);     // azimuthal angle\n\nrotate([0, b, c]) \n    cylinder(h=length, r=0.5);\n%cube([x,y,z]); // corner of cube should coincide with end of cylinder",
          "context": "No specific context available"
        },
        {
          "code": "Example:\ntranslate(v = [x, y, z]) { ... }",
          "context": "Translates (moves) its child elements along the specified vector. The argument name is optional."
        },
        {
          "code": "cube(2,center = true); \ntranslate([5,0,0]) \n   sphere(1,center = true);",
          "context": "No specific context available"
        },
        {
          "code": "mirror(v= [x, y, z] ) { ... }",
          "context": "Function signature:[edit | edit source]"
        },
        {
          "code": "rotate([0,0,10]) cube([3,2,1]);\nmirror([1,0,0]) translate([1,0,0]) rotate([0,0,10]) cube([3,2,1]);",
          "context": "hand(); // originalmirror([1,0,0]) hand();\n\t\t\n\t\t\n\t\t\t\n\t\t\thand(); // originalmirror([1,1,0]) hand();\n\t\t\n\t\t\n\t\t\t\n\t\t\thand(); // originalmirror([1,1,1]) hand();"
        },
        {
          "code": "angle=45;\nmultmatrix(m = [ [cos(angle), -sin(angle), 0, 10],\n                 [sin(angle),  cos(angle), 0, 20],\n                 [         0,           0, 1, 30],\n                 [         0,           0, 0,  1]\n              ]) union() {\n   cylinder(r=10.0,h=10,center=false);\n   cube(size=[10,10,10],center=false);\n}",
          "context": "No specific context available"
        },
        {
          "code": "module Obj() {\n   cylinder(r=10.0,h=10,center=false);\n   cube(size=[10,10,10],center=false);\n}\n\n// This itterates into the future 6 times and demonstrates how multimatrix is moving the object around the center point\nfor(time = [0 : 15 : 90]){\n    y_ang=-time;\n    mrot_y = [ [ cos(y_ang), 0,  sin(y_ang), 0],\n               [         0,  1,           0, 0],\n               [-sin(y_ang), 0,  cos(y_ang), 0],\n               [         0,  0,           0, 1]\n             ];\n    mtrans_x = [ [1, 0, 0, 40],\n                 [0, 1, 0,  0],\n                 [0, 0, 1,  0],\n                 [0, 0, 0,  1]\n               ];\n\n    echo(mrot_y*mtrans_x);\n    \n    // This is the object at [0,0,0]\n    Obj();\n    \n    // This is the starting object at the [40,0,0] coordinate\n    multmatrix(mtrans_x) Obj();\n    \n    // This is the one rotating and appears 6 times\n    multmatrix(mrot_y * mtrans_x) Obj();\n};",
          "context": "No specific context available"
        },
        {
          "code": "M = [ [ 1  , 0  , 0  , 0   ],\n      [ 0  , 1  , 0.7, 0   ],  // The \"0.7\" is the skew value; pushed along the y axis as z changes.\n      [ 0  , 0  , 1  , 0   ],\n      [ 0  , 0  , 0  , 1   ] ] ;\nmultmatrix(M) {  union() {\n    cylinder(r=10.0,h=10,center=false);\n    cube(size=[10,10,10],center=false); \n} }",
          "context": "No specific context available"
        },
        {
          "code": "angle=45;\n m=[\n        [cos(angle), -sin(angle), 0, 0],\n        [sin(angle),  cos(angle), 0, 0],\n        [         0,           0, 1, 0]\n   ];\n              \nv=[10,0,0];\nvm=concat(v,[1]); // need to add [1]\nvtrans=m*vm;\necho(vtrans);\ntranslate(vtrans)cube();",
          "context": "No specific context available"
        },
        {
          "code": "color( c = [r, g, b, a] ) { ... }\ncolor( c = [r, g, b], alpha = 1.0 ) { ... }\ncolor( \"#hexvalue\" ) { ... }\ncolor( \"colorname\", 1.0 ) { ... }",
          "context": "Function signature:[edit | edit source]"
        },
        {
          "code": "for(i=[0:36]) {\n    for(j=[0:36]) {\n      color( [0.5+sin(10*i)/2, 0.5+sin(10*j)/2, 0.5+sin(10*(i+j))/2] )\n      translate( [i, j, 0] )\n      cube( size = [1, 1, 11+10*cos(10*i)*sin(10*j)] );\n    }\n  }",
          "context": "No specific context available"
        },
        {
          "code": "module myModule(withColors=false) {\n    c=withColors?\"red\":undef;\n    color(c) circle(r=10);\n }",
          "context": "No specific context available"
        },
        {
          "code": "// Example 1\n \nlinear_extrude(height = 60, twist = 90, slices = 60) {\n   difference() {\n     offset(r = 10) {\n      square(20, center = true);\n     }\n     offset(r = 8) {\n       square(20, center = true);\n     }\n   }\n }",
          "context": "No specific context available"
        },
        {
          "code": "// Example 2\n \nmodule fillet(r) {\n   offset(r = -r) {\n     offset(delta = r) {\n       children();\n     }\n   }\n}",
          "context": "No specific context available"
        },
        {
          "code": "// Example 1\n \nt = \"OpenSCAD\";\n\nlinear_extrude(15) {\n\ttext(t, 50);\n}\ncolor(\"darkslategray\") {\n\tlinear_extrude(2) {\n\t\toffset(4) {\n\t\t\tfill() {\n\t\t\t\ttext(t, 50);\n\t\t\t}\n\t\t}\n\t}\n}",
          "context": "No specific context available"
        },
        {
          "code": "$fn=50;\n cube([10,10,1]);\n cylinder(r=2,h=1);",
          "context": "No specific context available"
        },
        {
          "code": "$fn=50;\nminkowski()\n{\n  cube([10,10,1]);\n  cylinder(r=2,h=1);\n}",
          "context": "No specific context available"
        },
        {
          "code": "minkowski() {\n\tcube([10, 10, 1]);\n\tcylinder(1, center=true);\n}",
          "context": "No specific context available"
        },
        {
          "code": "minkowski() {\n\tcube([10, 10, 1]);\n\tcylinder(1);\n}",
          "context": "No specific context available"
        },
        {
          "code": "{\n         translate([0, 0, collar])\n         sphere(ball);\n         cylinder(collar, ball, ball);\n    }",
          "context": "No specific context available"
        },
        {
          "code": "hull() {\n    translate([15,10,0]) circle(10);\n    circle(10);\n}",
          "context": "No specific context available"
        }
      ]
    },
    "csgModeling": {
      "title": "CSG Modeling",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/CSG_Modelling",
      "introduction": "boolean overview[edit | edit source]\n\n2D examples[edit | edit source]\n\nunion ( or )            circle + square \n\t\t\n\t\t\n\t\t\t\n\t\t\t   difference ( and not )  square - circle\n\t\t\n\t\t\n\t\t\t\n\t\t\t difference ( and not )  circle - square\n\t\t\n\t\t\n\t\t\t\n\t\t\t intersection ( and )    circle - (circle - square)\n\nunion()       {square(10);circle(10);} // square or  circle\n difference()  {square(10);circle(10);} // square and not circle\n difference()  {circle(10);square(10);} // circle and not square\n intersection(){square(10);circle(10);} // square and circle\n\n3D examples[edit | edit source]\n\nunion ( or )            sphere + cube \n\t\t\n\t\t\n\t\t\t\n\t\t\t         difference ( and not )  cube - sphere\n\t\t\n\t\t\n\t\t\t\n\t\t\t difference ( and not )  sphere - cube\n\t\t\n\t\t\n\t\t\t\n\t\t\t intersection ( and )    sphere - (sphere - cube)\n\nunion()       {cube(12, center=true); sphere(8);} // cube or  sphere\n difference()  {cube(12, center=true); sphere(8);} // cube and not sphere\n difference()  {sphere(8); cube(12, center=true);} // sphere and not cube\n intersection(){cube(12, center=true); sphere(8);} // cube and sphere\n\nunion[edit | edit source]\n\nCreates a union of all its child nodes. This is the sum of all children (logical or).\nMay be used with either 2D or 3D objects, but don't mix them.\n\n//Usage example:\n union() {\n \tcylinder (h = 4, r=1, center = true, $fn=100);\n \trotate ([90,0,0]) cylinder (h = 4, r=0.9, center = true, $fn=100);\n }\n\nRemark: union is implicit when not used. But it is mandatory, for example, in difference to group first child nodes into one.\n\nNote: It is mandatory for all unions, explicit or implicit, that external faces to be merged not be coincident.  Failure to follow this rule results in a design with undefined behavior, and can result in a render which is not manifold (with zero volume portions, or portions inside out), which typically leads to a warning and sometimes removal of a portion of the design from the rendered output.  (This can also result in flickering effects during the preview.)  This requirement is not a bug, but an intrinsic property of floating point comparisons and the fundamental inability to exactly represent irrational numbers such as those resulting from most rotations.  As an example, this is an invalid OpenSCAD program, and will at least lead to a warning on most platforms:\n\n// Invalid!\n size = 10;\n rotation = 17;\n union() {\n    rotate([rotation, 0, 0])\n       cube(size);\n    rotate([rotation, 0, 0])\n       translate([0, 0, size])\n       cube([2, 3, 4]);\n }\n\nThe solution is to always use a small value called an epsilon when merging adjacent faces like this to guarantee overlap.  Note the 0.01 eps value used in TWO locations, so that the external result is equivalent to what was intended:\n\n// Correct!\n size = 10;\n rotation = 17;\n eps = 0.01;\n union() {\n    rotate([rotation, 0, 0])\n       cube(size);\n    rotate([rotation, 0, 0])\n       translate([0, 0, size-eps])\n       cube([2, 3, 4+eps]);\n }\n\ndifference[edit | edit source]\n\nSubtracts the 2nd (and all further) child nodes from the first one (logical and not).\nMay be used with either 2D or 3D objects, but don't mix them.\n\nUsage example:\ndifference() {\n\tcylinder (h = 4, r=1, center = true, $fn=100);\n\trotate ([90,0,0]) cylinder (h = 4, r=0.9, center = true, $fn=100);\n}\n\nNote: It is mandatory that surfaces that are to be removed by a difference operation have an overlap, and that the negative piece being removed extends fully outside of the volume it is removing that surface from.  Failure to follow this rule can cause preview artifacts and can result in non-manifold render warnings or the removal of pieces from the render output.  See the description above in union for why this is required and an example of how to do this by this using a small epsilon value.\n\ndifference with multiple children[edit | edit source]\n\nNote, in the second instance, the result of adding a union of the 1st and 2nd children.\n\n// Usage example for difference of multiple children:\n$fn=90;\ndifference(){\n                                            cylinder(r=5,h=20,center=true);\n    rotate([00,140,-45]) color(\"LightBlue\") cylinder(r=2,h=25,center=true);\n    rotate([00,40,-50])                     cylinder(r=2,h=30,center=true);\n    translate([0,0,-10])rotate([00,40,-50]) cylinder(r=1.4,h=30,center=true);\n}\n   \n// second instance with added union\ntranslate([10,10,0]){\n    difference(){\n      union(){        // combine 1st and 2nd children\n                                                cylinder(r=5,h=20,center=true);\n        rotate([00,140,-45]) color(\"LightBlue\") cylinder(r=2,h=25,center=true);\n      }\n      rotate([00,40,-50])                       cylinder(r=2,h=30,center=true);\n      translate([0,0,-10])rotate([00,40,-50])   cylinder(r=1.4,h=30,center=true);\n    }\n}\n\nintersection[edit | edit source]\n\nCreates the intersection of all child nodes. This keeps the overlapping portion (logical and).\n\nOnly the area which is common or shared by all children is retained.\nMay be used with either 2D or 3D objects, but don't mix them.\n\n//Usage example:\nintersection() {\n\tcylinder (h = 4, r=1, center = true, $fn=100);\n\trotate ([90,0,0]) cylinder (h = 4, r=0.9, center = true, $fn=100);\n}\n\nrender[edit | edit source]\n\nWarning: Using render, always calculates the CSG model for this tree (even in OpenCSG preview mode).\nThis can make previewing very slow and OpenSCAD to appear to hang/freeze.\n\nUsage example:\nrender(convexity = 1) { ... }\n\nconvexity\n\nInteger. The convexity parameter specifies the maximum number of front and back sides a ray intersecting the object might penetrate. This parameter is only needed for correctly displaying the object in OpenCSG preview mode and has no effect on the polyhedron rendering.\n\nThis image shows a 2D shape with a convexity of 4, as the ray indicated in red crosses the 2D shape a maximum of 4 times. The convexity of a 3D shape would be determined in a similar way. Setting it to 10 should work fine for most cases.",
      "content": {},
      "codeExamples": [
        {
          "code": "union()       {square(10);circle(10);} // square or  circle\n difference()  {square(10);circle(10);} // square and not circle\n difference()  {circle(10);square(10);} // circle and not square\n intersection(){square(10);circle(10);} // square and circle",
          "context": "No specific context available"
        },
        {
          "code": "union()       {cube(12, center=true); sphere(8);} // cube or  sphere\n difference()  {cube(12, center=true); sphere(8);} // cube and not sphere\n difference()  {sphere(8); cube(12, center=true);} // sphere and not cube\n intersection(){cube(12, center=true); sphere(8);} // cube and sphere",
          "context": "No specific context available"
        },
        {
          "code": "//Usage example:\n union() {\n \tcylinder (h = 4, r=1, center = true, $fn=100);\n \trotate ([90,0,0]) cylinder (h = 4, r=0.9, center = true, $fn=100);\n }",
          "context": "No specific context available"
        },
        {
          "code": "// Invalid!\n size = 10;\n rotation = 17;\n union() {\n    rotate([rotation, 0, 0])\n       cube(size);\n    rotate([rotation, 0, 0])\n       translate([0, 0, size])\n       cube([2, 3, 4]);\n }",
          "context": "No specific context available"
        },
        {
          "code": "// Correct!\n size = 10;\n rotation = 17;\n eps = 0.01;\n union() {\n    rotate([rotation, 0, 0])\n       cube(size);\n    rotate([rotation, 0, 0])\n       translate([0, 0, size-eps])\n       cube([2, 3, 4+eps]);\n }",
          "context": "No specific context available"
        },
        {
          "code": "Usage example:\ndifference() {\n\tcylinder (h = 4, r=1, center = true, $fn=100);\n\trotate ([90,0,0]) cylinder (h = 4, r=0.9, center = true, $fn=100);\n}",
          "context": "No specific context available"
        },
        {
          "code": "// Usage example for difference of multiple children:\n$fn=90;\ndifference(){\n                                            cylinder(r=5,h=20,center=true);\n    rotate([00,140,-45]) color(\"LightBlue\") cylinder(r=2,h=25,center=true);\n    rotate([00,40,-50])                     cylinder(r=2,h=30,center=true);\n    translate([0,0,-10])rotate([00,40,-50]) cylinder(r=1.4,h=30,center=true);\n}\n   \n// second instance with added union\ntranslate([10,10,0]){\n    difference(){\n      union(){        // combine 1st and 2nd children\n                                                cylinder(r=5,h=20,center=true);\n        rotate([00,140,-45]) color(\"LightBlue\") cylinder(r=2,h=25,center=true);\n      }\n      rotate([00,40,-50])                       cylinder(r=2,h=30,center=true);\n      translate([0,0,-10])rotate([00,40,-50])   cylinder(r=1.4,h=30,center=true);\n    }\n}",
          "context": "No specific context available"
        },
        {
          "code": "//Usage example:\nintersection() {\n\tcylinder (h = 4, r=1, center = true, $fn=100);\n\trotate ([90,0,0]) cylinder (h = 4, r=0.9, center = true, $fn=100);\n}",
          "context": "No specific context available"
        },
        {
          "code": "Usage example:\nrender(convexity = 1) { ... }",
          "context": "No specific context available"
        }
      ]
    },
    "extrusion": {
      "title": "Extrusion",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/2D_to_3D_Extrusion",
      "introduction": "Extrusion is the process of creating an object with a fixed cross-sectional profile.  OpenSCAD provides two commands to create 3D solids from a 2D shape: linear_extrude() and rotate_extrude(). Linear extrusion is similar to pushing Playdoh through a press with a die of a specific shape.\n\nlinear_extrude() works like a Playdoh extrusion press\n\nRotational extrusion is similar to the process of turning or \"throwing\" a bowl on the Potter's wheel.\n\nrotate_extrude() emulates throwing a vessel\n\nBoth extrusion methods work on a (possibly disjointed) 2D shape which exists on the X-Y plane. While transformations that operates on both 2D shapes and 3D solids can move a shape off the X-Y plane, when the extrusion is performed the end result is not very intuitive.  What actually happens is that any information in the third coordinate (the Z coordinate) is ignored for any 2D shape, this process amounts to an implicit projection() performed on any 2D shape before the extrusion is executed.  It is recommended to perform extrusion on shapes that remains strictly on the X-Y plane.\n\nlinear_extrude[edit | edit source]\n\nLinear Extrusion is an operation that takes a 2D object as input and generates a 3D object as a result.\n\nExtrusion follows the V vector which defaults to the Z axis, for specifying a custom value a version > 2021.01 is needed.\n\nIn OpenSCAD Extrusion is always performed on the projection (shadow) of the 2d object xy plane; so if you rotate or apply other transformations to the 2d object before extrusion, its shadow shape is what is extruded.\n\nAlthough the extrusion is linear along the V vector, a twist parameter is available that causes the object to be rotated around the V vector as it is extruding upward. This can be used to rotate the object at its center, as if it is a spiral pillar, or produce a helical extrusion around the V vector, like a pig's tail.\n\nA scale parameter is also included so that the object can be expanded or contracted over the extent of the extrusion, allowing extrusions to be flared inward or outward.\n\nUsage[edit | edit source]\n\nlinear_extrude(height = 5, v = [0, 0, 1], center = true, convexity = 10, twist = -fanrot, slices = 20, scale = 1.0, $fn = 16) {...}\n\nYou must use parameter names due to a backward compatibility issue.\n\nheight must be positive.\n\nv is a 3D vector that must point into positive Z direction [Note: Requires version Development snapshot]\n\n$fn is optional and specifies the resolution of the linear_extrude (higher number brings more \"smoothness\", but more computation time is needed).\n\nIf the extrusion fails for a non-trivial 2D shape, try setting the convexity parameter (the default is not 10, but 10 is a \"good\" value to try). See explanation further down.\n\nTwist[edit | edit source]\n\nTwist is the number of degrees of through which the shape is extruded. Setting the parameter twist = 360 extrudes through one revolution. The twist direction follows the left hand rule.\n\n0° of Twist\n\nlinear_extrude(height = 10, center = true, convexity = 10, twist = 0)\ntranslate([2, 0, 0])\ncircle(r = 1);\n\n-100° of Twist\n\nlinear_extrude(height = 10, center = true, convexity = 10, twist = -100)\ntranslate([2, 0, 0])\ncircle(r = 1);\n\n100° of Twist\n\nlinear_extrude(height = 10, center = true, convexity = 10, twist = 100)\ntranslate([2, 0, 0])\ncircle(r = 1);\n\n-500° of Twist\n\nlinear_extrude(height = 10, center = true, convexity = 10, twist = -500)\ntranslate([2, 0, 0])\ncircle(r = 1);\n\nCenter[edit | edit source]\n\nIt is similar to the parameter center of cylinders. If center is false the linear extrusion Z range is from 0 to height; if it is true, the range is from -height/2 to height/2.\n\ncenter = true\n\nlinear_extrude(height = 10, center = true, convexity = 10, twist = -500)\ntranslate([2, 0, 0])\ncircle(r = 1);\n\ncenter = false\n\nlinear_extrude(height = 10, center = false, convexity = 10, twist = -500)\ntranslate([2, 0, 0])\ncircle(r = 1);\n\nMesh Refinement[edit | edit source]\n\nThe slices parameter defines the number of intermediate points along the Z axis of the extrusion. Its default increases with the value of twist. Explicitly setting slices may improve the output refinement. Additional the segments parameter adds vertices (points) to the extruded polygon resulting in smoother twisted geometries. Segments need to be a multiple of the polygon's fragments to have an effect (6 or 9..  for a circle($fn=3), 8,12.. for a square() ).\n\nlinear_extrude(height = 10, center = false, convexity = 10, twist = 360, slices = 100)\ntranslate([2, 0, 0])\ncircle(r = 1);\n\nThe special variables $fn, $fs and $fa can also be used to improve the output. If slices is not defined, its value is taken from the defined $fn value.\n\nlinear_extrude(height = 10, center = false, convexity = 10, twist = 360, $fn = 100)\ntranslate([2, 0, 0])\ncircle(r = 1);\n\nScale[edit | edit source]\n\nScales the 2D shape by this value over the height of the extrusion. Scale can be a scalar or a vector:\n\nlinear_extrude(height = 10, center = true, convexity = 10, scale=3)\n translate([2, 0, 0])\n circle(r = 1);\n\nlinear_extrude(height = 10, center = true, convexity = 10, scale=[1,5], $fn=100)\n translate([2, 0, 0])\n circle(r = 1);\n\nNote that if scale is a vector, the resulting side walls may be nonplanar.  Use twist=0 and the slices parameter to avoid asymmetry.\n\nlinear_extrude(height=10, scale=[1,0.1], slices=20, twist=0)\n polygon(points=[[0,0],[20,10],[20,-10]]);\n\nUsing with imported SVG[edit | edit source]\n\nA common usage of this function is to import a 2D svg\n\nlinear_extrude(height = 10, center = true)\n import(\"knight.svg\");\n\nrotate_extrude[edit | edit source]\n\nRotational extrusion spins a 2D shape around the Z-axis to form a solid which has rotational symmetry.  One way to think of this operation is to imagine a Potter's wheel placed on the X-Y plane with its axis of rotation pointing up towards +Z.  Then place the to-be-made object on this virtual Potter's wheel (possibly extending down below the X-Y plane towards -Z). The to-be-made object is the cross-section of the object on the X-Y plane (keeping only the right half, X >= 0).  That is the 2D shape that will be fed to rotate_extrude() as the child in order to generate this solid.  Note that the object started on the X-Y plane but is tilted up (rotated +90 degrees about the X-axis) to extrude.\n\nSince a 2D shape is rendered by OpenSCAD on the X-Y plane, an alternative way to think of this operation is as follows: spins a 2D shape around the Y-axis to form a solid.  The resultant solid is placed so that its axis of rotation lies along the Z-axis.\n\nJust like the linear_extrude, the extrusion is always performed on the projection of the 2D polygon to the XY plane. \nTransformations like rotate, translate, etc. applied to the 2D polygon before extrusion modify the projection of the 2D polygon to the XY plane and therefore also modify the appearance of the final 3D object.\n\nA translation in Z of the 2D polygon has no effect on the result (as also the projection is not affected).\nA translation in X increases the diameter of the final object.\nA translation in Y results in a shift of the final object in Z direction.\nA rotation about the X or Y axis distorts the cross section of the final object, as also the projection to the XY plane is distorted.\n\nDon't get confused, as OpenSCAD displays 2D polygons with a certain height in the Z direction, so the 2D object (with its height) appears to have a bigger projection to the XY plane. \nBut for the projection to the XY plane and also for the later extrusion only the base polygon without height is used.\n\nIt can not be used to produce a helix or screw threads.  Those are surprisingly difficult to do right; it's best to find a library that does them for you.\n\nThe 2D shape must lie completely on either the right (recommended) or the left side of the Y-axis.  More precisely speaking, every vertex of the shape must have either x >= 0 or x <= 0.  If the shape spans the X axis a warning appears in the console windows and the rotate_extrude() is ignored. If the 2D shape touches the Y axis, i.e. at x=0, it must be a line that touches, not a point, as a point results in a zero thickness 3D object, which is invalid and results in a CGAL error. For OpenSCAD versions prior to 2016.xxxx, if the shape is in the negative axis the resulting faces are oriented inside-out, which may cause undesired effects.\n\nUsage[edit | edit source]\n\nrotate_extrude(angle = 360, start=0, convexity = 2) {...}\n\nRight-hand grip rule\n\nIn 2021.01 and previous, you must use parameter names due to a backward compatibility issue.\n\nconvexity : If the extrusion fails for a non-trival 2D shape, try setting the convexity parameter (the default is not 10, but 10 is a \"good\" value to try). See explanation further down.\nangle  [Note: Requires version 2019.05] : Defaults to 360. Specifies the number of degrees to sweep, starting at the positive X axis.  The direction of the sweep follows the  Right Hand Rule, hence a negative angle sweeps clockwise.\nstart [Note: Requires version Development snapshot] : Defaults to 0 if angle is specified, and 180 if not.  Specifies the starting angle of the extrusion, counter-clockwise from the positive X axis.\n$fa : minimum angle (in degrees) of each fragment.\n$fs : minimum circumferential length of each fragment.\n$fn : fixed number of fragments in 360 degrees. Values of 3 or more override $fa and $fs\n$fa, $fs and $fn must be named parameters. click here for more details,.\n\nExamples[edit | edit source]\n\n→\n\nA simple torus can be constructed using a rotational extrude.\n\nrotate_extrude(convexity = 10)\n    translate([2, 0, 0])\n        circle(r = 1);\n\nMesh Refinement[edit | edit source]\n\n→\n\nIncreasing the number of fragments composing the 2D shape improves the quality of the mesh, but takes longer to render.\n\nrotate_extrude(convexity = 10)\n    translate([2, 0, 0])\n        circle(r = 1, $fn = 100);\n\n→\n\nThe number of fragments used by the extrusion can also be increased.\n\nrotate_extrude(convexity = 10, $fn = 100)\n    translate([2, 0, 0])\n        circle(r = 1, $fn = 100);\n\nUsing the parameter angle (with OpenSCAD versions 2016.xx), a hook can be modeled .\n\nOpenSCAD - a hook\n\neps = 0.01;\ntranslate([eps, 60, 0])\n    rotate_extrude(angle=270, convexity=10)\n        translate([40, 0]) circle(10);\nrotate_extrude(angle=90, convexity=10)\n    translate([20, 0]) circle(10);\ntranslate([20, eps, 0])\n    rotate([90, 0, 0]) cylinder(r=10, h=80+eps);\n\nExtruding a Polygon[edit | edit source]\n\nExtrusion can also be performed on polygons with points chosen by the user.\n\nHere is a simple polygon and its 200 step rotational extrusion. (Note it has been rotated 90 degrees to show how the rotation appears; the rotate_extrude() needs it flat).\n\nrotate([90,0,0])        polygon( points=[[0,0],[2,1],[1,2],[1,3],[3,4],[0,5]] );\n\nrotate_extrude($fn=200) polygon( points=[[0,0],[2,1],[1,2],[1,3],[3,4],[0,5]] );\n\n→→\n\nFor more information on polygons, please see: 2D Primitives: Polygon.\n\nOrientation[edit | edit source]\n\nIf you're making a round 360 degree extrusion, it doesn't matter where it starts.  If, on the other hand, you're using $fn to make an extrusion with some specific number of sides, it can matter.  With an odd number of sides, there will be a vertex on either the left or the right, and a side opposite it.\n\nWith angle not specified, the extrusion starts along the negative X axis, to the left of the origin.  With an odd number of sides, there is a vertex on the left and a side on the right. (Note that this is inconsistent with the behavior for angle less than 360, and with the behavior for circle and other round primitives.)\n\nWith angle specified, and not equal to 360, the extrusion starts along the positive X axis, to the right of the origin.\n\nFor 2021.01 and earlier, if angle is equal to 360, the extrusion starts along the negative X axis, as for angle not being specified.\n\nFor the development snapshot, if angle is 360, the extrusion starts along the positive X axis, as for other cases where angle is specified. Explicitly specifying angle=360 thus yields results consistent with other round primitives.\n\nA future release may change this behavior so that when angle is not specified the extrusion starts along the positive X axis, making all of these cases consistent.\n\nstart directly controls the start point. [Note: Requires version Development snapshot]\n\nDescription of extrude parameters[edit | edit source]\n\nExtrude parameters for all extrusion modes[edit | edit source]\n\nconvexity\n\nInteger. The convexity parameter specifies the maximum number of front sides (or back sides) a ray intersecting the object might penetrate. This parameter is only needed for correctly displaying the object in OpenCSG preview mode when using the standard Goldfeather algorithm and has no effect on the polyhedron rendering (the mesh generation).\n\nThe convexity of a primitive is the maximum number of front (or back) faces of the primitive at a single position. For example, the convexity of a sphere is one and the convexity of a torus is two.\n\nThis image shows a 2D shape with a convexity of 2, as the ray indicated in red crosses the 2D shape a maximum of 4 times (2 front sides and 2 back sides). The convexity of a 3D shape would be determined in a similar way. Setting it to 10 should work fine for most cases. Just setting high numbers in general may result in slower preview rendering.\n\nExtrude parameters for linear extrusion only[edit | edit source]\n\nheight\n\nThe extrusion height\n\n\ncenter\n\nIf true, the solid is centered after extrusion\n\n\ntwist\n\nThe extrusion twist in degrees\n\n\nscale\n\nScales the 2D shape by this value over the height of the extrusion.\n\n\nslices\n\nSimilar to special variable $fn without being passed down to the child 2D shape.\n\n\nsegments\n\nSimilar to slices but adding points on the polygon's segments without changing the polygon's shape.",
      "content": {},
      "codeExamples": [
        {
          "code": "linear_extrude(height = 5, v = [0, 0, 1], center = true, convexity = 10, twist = -fanrot, slices = 20, scale = 1.0, $fn = 16) {...}",
          "context": "Usage[edit | edit source]"
        },
        {
          "code": "linear_extrude(height = 10, center = true, convexity = 10, twist = 0)\ntranslate([2, 0, 0])\ncircle(r = 1);",
          "context": "0° of Twist"
        },
        {
          "code": "linear_extrude(height = 10, center = true, convexity = 10, twist = -100)\ntranslate([2, 0, 0])\ncircle(r = 1);",
          "context": "-100° of Twist"
        },
        {
          "code": "linear_extrude(height = 10, center = true, convexity = 10, twist = 100)\ntranslate([2, 0, 0])\ncircle(r = 1);",
          "context": "100° of Twist"
        },
        {
          "code": "linear_extrude(height = 10, center = true, convexity = 10, twist = -500)\ntranslate([2, 0, 0])\ncircle(r = 1);",
          "context": "-500° of Twist"
        },
        {
          "code": "linear_extrude(height = 10, center = true, convexity = 10, twist = -500)\ntranslate([2, 0, 0])\ncircle(r = 1);",
          "context": "center = true"
        },
        {
          "code": "linear_extrude(height = 10, center = false, convexity = 10, twist = -500)\ntranslate([2, 0, 0])\ncircle(r = 1);",
          "context": "center = false"
        },
        {
          "code": "linear_extrude(height = 10, center = false, convexity = 10, twist = 360, slices = 100)\ntranslate([2, 0, 0])\ncircle(r = 1);",
          "context": "The slices parameter defines the number of intermediate points along the Z axis of the extrusion. Its default increases with the value of twist. Explicitly setting slices may improve the output refinement. Additional the segments parameter adds vertices (points) to the extruded polygon resulting in smoother twisted geometries. Segments need to be a multiple of the polygon's fragments to have an effect (6 or 9..  for a circle($fn=3), 8,12.. for a square() )."
        },
        {
          "code": "linear_extrude(height = 10, center = false, convexity = 10, twist = 360, $fn = 100)\ntranslate([2, 0, 0])\ncircle(r = 1);",
          "context": "The special variables $fn, $fs and $fa can also be used to improve the output. If slices is not defined, its value is taken from the defined $fn value."
        },
        {
          "code": "linear_extrude(height = 10, center = true, convexity = 10, scale=3)\n translate([2, 0, 0])\n circle(r = 1);",
          "context": "Scales the 2D shape by this value over the height of the extrusion. Scale can be a scalar or a vector:"
        },
        {
          "code": "linear_extrude(height = 10, center = true, convexity = 10, scale=[1,5], $fn=100)\n translate([2, 0, 0])\n circle(r = 1);",
          "context": "linear_extrude(height = 10, center = true, convexity = 10, scale=3)\n translate([2, 0, 0])\n circle(r = 1);"
        },
        {
          "code": "linear_extrude(height=10, scale=[1,0.1], slices=20, twist=0)\n polygon(points=[[0,0],[20,10],[20,-10]]);",
          "context": "Note that if scale is a vector, the resulting side walls may be nonplanar.  Use twist=0 and the slices parameter to avoid asymmetry."
        },
        {
          "code": "linear_extrude(height = 10, center = true)\n import(\"knight.svg\");",
          "context": "A common usage of this function is to import a 2D svg"
        },
        {
          "code": "rotate_extrude(angle = 360, start=0, convexity = 2) {...}",
          "context": "Usage[edit | edit source]"
        },
        {
          "code": "rotate_extrude(convexity = 10)\n    translate([2, 0, 0])\n        circle(r = 1);",
          "context": "A simple torus can be constructed using a rotational extrude."
        },
        {
          "code": "rotate_extrude(convexity = 10)\n    translate([2, 0, 0])\n        circle(r = 1, $fn = 100);",
          "context": "Increasing the number of fragments composing the 2D shape improves the quality of the mesh, but takes longer to render."
        },
        {
          "code": "rotate_extrude(convexity = 10, $fn = 100)\n    translate([2, 0, 0])\n        circle(r = 1, $fn = 100);",
          "context": "The number of fragments used by the extrusion can also be increased."
        },
        {
          "code": "eps = 0.01;\ntranslate([eps, 60, 0])\n    rotate_extrude(angle=270, convexity=10)\n        translate([40, 0]) circle(10);\nrotate_extrude(angle=90, convexity=10)\n    translate([20, 0]) circle(10);\ntranslate([20, eps, 0])\n    rotate([90, 0, 0]) cylinder(r=10, h=80+eps);",
          "context": "OpenSCAD - a hook"
        },
        {
          "code": "rotate([90,0,0])        polygon( points=[[0,0],[2,1],[1,2],[1,3],[3,4],[0,5]] );",
          "context": "Here is a simple polygon and its 200 step rotational extrusion. (Note it has been rotated 90 degrees to show how the rotation appears; the rotate_extrude() needs it flat)."
        },
        {
          "code": "rotate_extrude($fn=200) polygon( points=[[0,0],[2,1],[1,2],[1,3],[3,4],[0,5]] );",
          "context": "rotate([90,0,0])        polygon( points=[[0,0],[2,1],[1,2],[1,3],[3,4],[0,5]] );"
        }
      ]
    },
    "conditionalFunctions": {
      "title": "Conditional and Iterator Functions",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Conditional_and_Iterator_Functions",
      "introduction": "For loop[edit | edit source]\n\nEvaluate each value in a range or vector, or each name in an object, applying it to the following Action.\n\nfor(variable = [start : increment : end])\n for(variable = [start : end])\n for(variable = [vector])\n for(variable = object)\n\nFor each value in a range[edit | edit source]\n\nfor (variable = [ start : increment : end ])\n   for (variable = [ start : end ])\n\nNote: For range, values are separated by colons rather than commas used in vectors.\n\nThe Action is evaluated for each value in the range.\n\nstart - initial value\nincrement or step - amount to increase the value, optional, default = 1\nend - stop when next value would be past end\n\nexamples:\n\nfor (a =[3:5])echo(a);     // 3 4 5\n for (a =[3:0]){echo(a);}   // 0 1 2 3         start > end is invalid, deprecated by 2015.3\n for (a =[3:0.5:5])echo(a); // 3 3.5 4 4.5 5\n for (a =[0:2:5])echo(a);   // 0 2 4           a never equals end \n for (a =[3:-2:-1])echo(a); // 3 1 -1          negative increment requires 2015.3\n                                               be sure end < start\n\nFor each element of a vector[edit | edit source]\n\nThe Action is evaluated for each element of the vector.\n\nfor (a =[3,4,1,5])echo(a); // 3 4 1 5\n for (a =[0.3,PI,1,99]){echo(a);}    // 0.3 3.14159 1 99\n x1=2; x2=8; x3=5.5;\n for (a =[x1,x2,x3]){echo(a);} // 2 8 5.5 \n for (a =[[1,2],6,\"s\",[[3,4],[5,6]]])echo(a);  // [1,2] 6 \"s\" [[3,4],[5,6]]\n\nThe vector can be described elsewhere, like 'for each' in other languages.\n\nanimals = [\"elephants\", \"snakes\", \"tigers\", \"giraffes\"];\n   for(animal = animals)\n     echo(str(\"I've been to the zoo and saw \", animal));\n // \"I've been to the zoo and saw elephants\", for each animal\n\nFor each element of an object[edit | edit source]\n\n[Note: Requires version Development snapshot]\n\nThe Action is evaluated for the name of each element of the object, in an unspecified order.\n\ntm = textmetrics(\"Hello, World!\");\n   for (name = tm) echo(name, tm[name]);\n\nNotes[edit | edit source]\n\nfor() is an Operator. Operators require braces {} if more than one Action is within its scope. Actions end in semicolons, Operators do not.\n\nfor() is not an exception to the rule about variables having only one value within a scope. Each evaluation  is given its own scope, allowing any variables to have unique values. No, you still can't do a=a+1;\n\nRemember this is not an iterative language, the for() does not loop in the programmatic sense, it builds a tree of objects one branch for each item in the range/vector, inside each branch  the 'variable' is a specific and separate instantiation or scope.\n\nHence:\n\nfor (i=[0:3])\n   translate([i*10,0,0])\n     cube(i+1);\n\nProduces:\n[See Design/Display-CSG-Tree menu]\n\ngroup() {\n       group() {\n               multmatrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {\n                       cube(size = [1, 1, 1], center = false);\n               }\n               multmatrix([[1, 0, 0, 10], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {\n                       cube(size = [2, 2, 2], center = false);\n               }\n               multmatrix([[1, 0, 0, 20], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {\n                       cube(size = [3, 3, 3], center = false);\n               }\n               multmatrix([[1, 0, 0, 30], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {\n                       cube(size = [4, 4, 4], center = false);\n               }\n       }\n}\n\nWhile the group() is built sequentially, all instances of the for() exist as separate entities, they do not iterate one piece of code sequentially.\n\nNested for()[edit | edit source]\n\nWhile it is reasonable to nest multiple for() statements such as:\n\nfor(z=[-180:45:+180])\n  for(x=[10:5:50])\n    rotate([0,0,z]) translate([x,0,0]) cube(1);\n\ninstead, all ranges/vectors can be included in the same for() operator.\n\nfor ( variable1 = <range or vector> , variable2 = <range or vector> ) <do something using both variables>\n\nfor() loops nested 3 deep\n\nexample for() nested 3 deep\n \n color_vec = [\"black\",\"red\",\"blue\",\"green\",\"pink\",\"purple\"];\n for (x = [-20:10:20] )\n for (y = [0:4] )color(color_vec[y])\n for (z = [0,4,10] )\n     {translate([x,y*5-10,z])cube();}\n \n shorthand nesting for same result\n \n color_vec = [\"black\",\"red\",\"blue\",\"green\",\"pink\",\"purple\"];\n for (x = [-20:10:20],\n y = [0:4],\n z = [0,4,10] )\n     translate([x,y*5-10,z]){color(color_vec[y])cube();}\n\nExamples using vector of vectors\n\nexample 1 for() loop vector of vectors (rotation)\n\nexample 1 - iteration over a vector of vectors (rotation)\n  \n for(i = [ [  0,  0,   0],\n           [ 10, 20, 300],\n           [200, 40,  57],\n           [ 20, 88,  57] ])\n{\n   rotate(i)\n   cube([100, 20, 20], center = true);\n}\n\nexample 2 for() loop vector of vectors (translation)\n\nexample 2 - iteration over a vector of vectors (translation)\n  \nfor(i = [ [ 0,  0,  0],\n          [10, 12, 10],\n          [20, 24, 20],\n          [30, 36, 30],\n          [20, 48, 40],\n          [10, 60, 50] ])\n{\n   translate(i)\n   cube([50, 15, 10], center = true);\n}\n\nexample 3 for() loop vector of vectors\n\nexample 3 - iteration over a vector of vectors\nfor(i = [ [[ 0,  0,  0], 20],\n          [[10, 12, 10], 50],\n          [[20, 24, 20], 70],\n          [[30, 36, 30], 10],\n          [[20, 48, 40], 30],\n          [[10, 60, 50], 40] ])\n{\n  translate([i[0][0], 2*i[0][1], 0])\n  cube([10, 15, i[1]]);\n}\n\nIntersection For Loop[edit | edit source]\n\nIterate over the values in a range or vector and create the intersection of  objects created by each pass.\n\nBesides creating separate instances for each pass, the standard  for()  also groups all these instances creating an implicit union.\nintersection_for() is a work around because the implicit union prevents getting the expected results using a combination of the standard for() and intersection() statements.\n\nintersection_for() uses the same parameters, and works the same as a For Loop, \nother than replacing the implicit union with an intersection.\n\nexample 1 - loop over a range:\n\n\nintersection_for(n = [1 : 6])\n{\n    rotate([0, 0, n * 60])\n    {\n        translate([5,0,0])\n        sphere(r=12);\n    }\n}\n\n\nintersection_for()\n\neither intersection() for() or for() intersection()\n\nexample 2 - rotation :\n\n\n intersection_for(i = [ [  0,  0,   0],\n \t\t\t[ 10, 20, 300],\n \t\t\t[200, 40,  57],\n \t\t\t[ 20, 88,  57] ])\n{\n    rotate(i)\n    cube([100, 20, 20], center = true);\n}\n\n\nintersection_for()\n\nintersection()  for()\n\nIf Statement[edit | edit source]\n\nPerforms a test to determine if the actions in a sub scope should be performed or not.\n\nREALLY IMPORTANT. You can't change the value of Variables. If you have an assignment inside brackets, it creates a new variable that is lost as soon as you exit that scope.\n\nif (test) scope1\nif (test){scope1}\nif (test) scope1  else  scope2\nif (test){scope1} else {scope2}\n\nParameters\n\ntest: Usually a boolean expression, but can be any value or variable.\n See here for true or false state of values.\nSee here for boolean and logical operators\nDo not confuse the assignment operator '=' with the equal operator '=='\nscope1: one or more actions to take when test is true.\nscope2: one or more actions to take when test is false.\n\nif (b==a)  cube(4);\nif (b<a)  {cube(4); cylinder(6);}\nif (b&&a) {cube(4); cylinder(6);}\nif (b!=a)  cube(4); else cylinder(3);\nif (b)    {cube(4); cylinder(6);} else {cylinder(10,5,5);} \nif (!true){cube(4); cylinder(6);} else  cylinder(10,5,5); \nif (x>y)   cube(1, center=false); else {cube(size = 2, center = true);}\nif (a==4) {}                      else  echo(\"a is not 4\");\nif ((b<5)&&(a>8))  {cube(4);}     else {cylinder(3);}\nif (b<5&&a>8)       cube(4);      else  cylinder(3);\n\nSince 2015.03 variables can now be assigned in any scope. Note that assignments are only valid within the scope in which they are defined - you are still not allowed to leak values to an outer scope. See Scope of variables for more details.\n\nNested if\n\nThe scopes of both the if() portion and the else portion, can in turn contain if() statements. This nesting can be to any depth.\n\nif (test1) \n {\n   scope1 if (test2) {scope2.1}\n          else {scope2.2}\n }\n else\n{\n  scope2 if (test3) {scope3.1}\n         else {scope3.2}\n}\n\nWhen scope1 and scope2 contain only the if() statement, the outer sets of braces can be removed.\n\nif (test1)\n   if (test2) {scope2.1}\n   else {scope2.2}\n else\n   if (test3) {scope3.1}\n   else {scope3.2}\n\nOne evolution is this:\n\nelse if[edit | edit source]\n\nif(test1) {scope1}\n else if(test2) {scope2}\n else if(test3) {scope3}\n else if(test4) {scope4}\n else           {scope5}\n\nNote that else and if are two separate words. When working down the chain of tests, the first true uses its scope. All further tests are skipped.\n\nexample\n\nif((k<8)&&(m>1)) cube(10);\nelse if(y==6)   {sphere(6);cube(10);}\nelse if(y==7)    color(\"blue\")sphere(5);\nelse if(k+m!=8) {cylinder(15,5,0);sphere(8);}\nelse             color(\"green\"){cylinder(12,5,0);sphere(8);}\n\nConditional ? :[edit | edit source]\n\nA function that uses a test to determine which of 2 values to return.\n\na =   test ? TrueValue : FalseValue ;\n echo( test ? TrueValue : FalseValue );\n\nParameters\n\ntest: Usually a boolean expression, but can be any value or variable.\n See here for true or false state of values.\nSee here for boolean and logical operators\nDo not confuse assignment '=' with equal '=='\nTrueValue:  the value to return when test is true.\nFalseValue: the value to return when test is false.\nA value in OpenSCAD is either a Number (like 42), a Boolean (like true), a String (like \"foo\"), a Vector (like [1,2,3]), or the Undefined value (undef). Values can be stored in variables, passed as function arguments, and returned as function results.\n\nThis works like the ?: operator from the family of C-like programming languages.\n\nExamples\n\na=1; b=2; c= a==b ? 4 : 5 ;                  //  5\n a=1; b=2; c= a==b ? \"a==b\" : \"a!=b\" ;        //  \"a!=b\"\n  \n TrueValue = true; FalseValue = false;\n a=5; test = a==1;\n echo( test ? TrueValue : FalseValue );       // false\n  \n L = 75; R = 2; test = (L/R)>25;\n TrueValue =  [test,L,R,L/R,cos(30)];\n FalseValue = [test,L,R,sin(15)];\n a1 = test ? TrueValue : FalseValue ;         // [true, 75, 2, 37.5, 0.866025]\n\nSome forms of tail-recursion elimination are supported.\n\nRecursive function calls[edit | edit source]\n\nRecursive function calls are supported. Using the Conditional \"... ? ... : ... \" it's possible to ensure the recursion is terminated.\nNote: There is a built-in recursion limit to prevent an application crash. If the limit is hit, the function returns undef.\n\nexample\n\n// recursion - find the sum of the values in a vector (array) by calling itself\n // from the start (or s'th element) to the i'th element - remember elements are zero based\n\n function sumv(v, i, s = 0) = (i == s ? v[i] : v[i] + sumv(v, i-1, s));\n \n vec=[ 10, 20, 30, 40 ];\n echo(\"sum vec=\", sumv(vec, 2, 1)); // calculates 20+30=50\n\nFormatting complex usage[edit | edit source]\n\nMultiple nested conditionals can become difficult to understand.\nFormatting them like multi-line indented \"if/else\" statements is clearer.\n\n// find the maximum value in a vector\nfunction maxv(v, m=-999999999999, i=0) = \n    (i == len(v) ) \n    ?     m \n    :     (m > v[i]) \n          ?    maxv(v, m, i+1) \n          :    maxv(v, v[i], i+1);\n\nv=[7,3,9,3,5,6];\necho(\"max\",maxv(v));   // ECHO: \"max\", 9\n\nAssign Statement[edit | edit source]\n\n[Deprecated: assign() will be removed in future releases. Variables can now be assigned anywhere. If you prefer this way of setting values, the new Let Statement can be used instead.]\n\nSet variables to a new value for a sub-tree.\n\nParameters\n\nThe variables that should be (re-)assigned\n\nexample:\n\nfor (i = [10:50])\n{\n    assign (angle = i*360/20, distance = i*10, r = i*2)\n    {\n        rotate(angle, [1, 0, 0])\n        translate([0, distance, 0])\n        sphere(r = r);\n    }\n}\n\nfor (i = [10:50])\n{\n    angle = i*360/20;\n    distance = i*10;\n    r = i*2;\n    rotate(angle, [1, 0, 0])\n    translate([0, distance, 0])\n    sphere(r = r);\n}\n\nLet Statement[edit | edit source]\n\n[Note: Requires version 2019.05]\n\nSet variables to a new value for a sub-tree.\nThe parameters are evaluated sequentially and may depend on each other (as opposed to the deprecated assign() statement).\n\nParameters\n\nThe variables that should be set\n\nexample:\n\nfor (i = [10:50])\n{\n    let (angle = i*360/20, r= i*2, distance = r*5)\n    {\n        rotate(angle, [1, 0, 0])\n        translate([0, distance, 0])\n        sphere(r = r);\n    }\n}",
      "content": {},
      "codeExamples": [
        {
          "code": "for(variable = [start : increment : end])\n for(variable = [start : end])\n for(variable = [vector])\n for(variable = object)",
          "context": "Evaluate each value in a range or vector, or each name in an object, applying it to the following Action."
        },
        {
          "code": "for (variable = [ start : increment : end ])\n   for (variable = [ start : end ])",
          "context": "For each value in a range[edit | edit source]"
        },
        {
          "code": "for (a =[3:5])echo(a);     // 3 4 5\n for (a =[3:0]){echo(a);}   // 0 1 2 3         start > end is invalid, deprecated by 2015.3\n for (a =[3:0.5:5])echo(a); // 3 3.5 4 4.5 5\n for (a =[0:2:5])echo(a);   // 0 2 4           a never equals end \n for (a =[3:-2:-1])echo(a); // 3 1 -1          negative increment requires 2015.3\n                                               be sure end < start",
          "context": "start - initial value\nincrement or step - amount to increase the value, optional, default = 1\nend - stop when next value would be past end"
        },
        {
          "code": "for (a =[3,4,1,5])echo(a); // 3 4 1 5\n for (a =[0.3,PI,1,99]){echo(a);}    // 0.3 3.14159 1 99\n x1=2; x2=8; x3=5.5;\n for (a =[x1,x2,x3]){echo(a);} // 2 8 5.5 \n for (a =[[1,2],6,\"s\",[[3,4],[5,6]]])echo(a);  // [1,2] 6 \"s\" [[3,4],[5,6]]",
          "context": "The Action is evaluated for each element of the vector."
        },
        {
          "code": "animals = [\"elephants\", \"snakes\", \"tigers\", \"giraffes\"];\n   for(animal = animals)\n     echo(str(\"I've been to the zoo and saw \", animal));\n // \"I've been to the zoo and saw elephants\", for each animal",
          "context": "The vector can be described elsewhere, like 'for each' in other languages."
        },
        {
          "code": "tm = textmetrics(\"Hello, World!\");\n   for (name = tm) echo(name, tm[name]);",
          "context": "The Action is evaluated for the name of each element of the object, in an unspecified order."
        },
        {
          "code": "for (i=[0:3])\n   translate([i*10,0,0])\n     cube(i+1);",
          "context": "Remember this is not an iterative language, the for() does not loop in the programmatic sense, it builds a tree of objects one branch for each item in the range/vector, inside each branch  the 'variable' is a specific and separate instantiation or scope."
        },
        {
          "code": "group() {\n       group() {\n               multmatrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {\n                       cube(size = [1, 1, 1], center = false);\n               }\n               multmatrix([[1, 0, 0, 10], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {\n                       cube(size = [2, 2, 2], center = false);\n               }\n               multmatrix([[1, 0, 0, 20], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {\n                       cube(size = [3, 3, 3], center = false);\n               }\n               multmatrix([[1, 0, 0, 30], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) {\n                       cube(size = [4, 4, 4], center = false);\n               }\n       }\n}",
          "context": "Produces:\n[See Design/Display-CSG-Tree menu]"
        },
        {
          "code": "for(z=[-180:45:+180])\n  for(x=[10:5:50])\n    rotate([0,0,z]) translate([x,0,0]) cube(1);",
          "context": "While it is reasonable to nest multiple for() statements such as:"
        },
        {
          "code": "for ( variable1 = <range or vector> , variable2 = <range or vector> ) <do something using both variables>",
          "context": "instead, all ranges/vectors can be included in the same for() operator."
        },
        {
          "code": "example for() nested 3 deep\n \n color_vec = [\"black\",\"red\",\"blue\",\"green\",\"pink\",\"purple\"];\n for (x = [-20:10:20] )\n for (y = [0:4] )color(color_vec[y])\n for (z = [0,4,10] )\n     {translate([x,y*5-10,z])cube();}\n \n shorthand nesting for same result\n \n color_vec = [\"black\",\"red\",\"blue\",\"green\",\"pink\",\"purple\"];\n for (x = [-20:10:20],\n y = [0:4],\n z = [0,4,10] )\n     translate([x,y*5-10,z]){color(color_vec[y])cube();}",
          "context": "for() loops nested 3 deep"
        },
        {
          "code": "example 1 - iteration over a vector of vectors (rotation)\n  \n for(i = [ [  0,  0,   0],\n           [ 10, 20, 300],\n           [200, 40,  57],\n           [ 20, 88,  57] ])\n{\n   rotate(i)\n   cube([100, 20, 20], center = true);\n}",
          "context": "example 1 for() loop vector of vectors (rotation)"
        },
        {
          "code": "example 2 - iteration over a vector of vectors (translation)\n  \nfor(i = [ [ 0,  0,  0],\n          [10, 12, 10],\n          [20, 24, 20],\n          [30, 36, 30],\n          [20, 48, 40],\n          [10, 60, 50] ])\n{\n   translate(i)\n   cube([50, 15, 10], center = true);\n}",
          "context": "example 2 for() loop vector of vectors (translation)"
        },
        {
          "code": "example 3 - iteration over a vector of vectors\nfor(i = [ [[ 0,  0,  0], 20],\n          [[10, 12, 10], 50],\n          [[20, 24, 20], 70],\n          [[30, 36, 30], 10],\n          [[20, 48, 40], 30],\n          [[10, 60, 50], 40] ])\n{\n  translate([i[0][0], 2*i[0][1], 0])\n  cube([10, 15, i[1]]);\n}",
          "context": "example 3 for() loop vector of vectors"
        },
        {
          "code": "intersection_for(n = [1 : 6])\n{\n    rotate([0, 0, n * 60])\n    {\n        translate([5,0,0])\n        sphere(r=12);\n    }\n}",
          "context": "No specific context available"
        },
        {
          "code": "intersection_for(i = [ [  0,  0,   0],\n \t\t\t[ 10, 20, 300],\n \t\t\t[200, 40,  57],\n \t\t\t[ 20, 88,  57] ])\n{\n    rotate(i)\n    cube([100, 20, 20], center = true);\n}",
          "context": "No specific context available"
        },
        {
          "code": "if (test) scope1\nif (test){scope1}\nif (test) scope1  else  scope2\nif (test){scope1} else {scope2}",
          "context": "REALLY IMPORTANT. You can't change the value of Variables. If you have an assignment inside brackets, it creates a new variable that is lost as soon as you exit that scope."
        },
        {
          "code": "if (b==a)  cube(4);\nif (b<a)  {cube(4); cylinder(6);}\nif (b&&a) {cube(4); cylinder(6);}\nif (b!=a)  cube(4); else cylinder(3);\nif (b)    {cube(4); cylinder(6);} else {cylinder(10,5,5);} \nif (!true){cube(4); cylinder(6);} else  cylinder(10,5,5); \nif (x>y)   cube(1, center=false); else {cube(size = 2, center = true);}\nif (a==4) {}                      else  echo(\"a is not 4\");\nif ((b<5)&&(a>8))  {cube(4);}     else {cylinder(3);}\nif (b<5&&a>8)       cube(4);      else  cylinder(3);",
          "context": "test: Usually a boolean expression, but can be any value or variable.\n See here for true or false state of values.\nSee here for boolean and logical operators\nDo not confuse the assignment operator '=' with the equal operator '=='\nscope1: one or more actions to take when test is true.\nscope2: one or more actions to take when test is false."
        },
        {
          "code": "if (test1) \n {\n   scope1 if (test2) {scope2.1}\n          else {scope2.2}\n }\n else\n{\n  scope2 if (test3) {scope3.1}\n         else {scope3.2}\n}",
          "context": "The scopes of both the if() portion and the else portion, can in turn contain if() statements. This nesting can be to any depth."
        },
        {
          "code": "if (test1)\n   if (test2) {scope2.1}\n   else {scope2.2}\n else\n   if (test3) {scope3.1}\n   else {scope3.2}",
          "context": "When scope1 and scope2 contain only the if() statement, the outer sets of braces can be removed."
        },
        {
          "code": "if(test1) {scope1}\n else if(test2) {scope2}\n else if(test3) {scope3}\n else if(test4) {scope4}\n else           {scope5}",
          "context": "else if[edit | edit source]"
        },
        {
          "code": "if((k<8)&&(m>1)) cube(10);\nelse if(y==6)   {sphere(6);cube(10);}\nelse if(y==7)    color(\"blue\")sphere(5);\nelse if(k+m!=8) {cylinder(15,5,0);sphere(8);}\nelse             color(\"green\"){cylinder(12,5,0);sphere(8);}",
          "context": "Note that else and if are two separate words. When working down the chain of tests, the first true uses its scope. All further tests are skipped."
        },
        {
          "code": "a =   test ? TrueValue : FalseValue ;\n echo( test ? TrueValue : FalseValue );",
          "context": "A function that uses a test to determine which of 2 values to return."
        },
        {
          "code": "a=1; b=2; c= a==b ? 4 : 5 ;                  //  5\n a=1; b=2; c= a==b ? \"a==b\" : \"a!=b\" ;        //  \"a!=b\"\n  \n TrueValue = true; FalseValue = false;\n a=5; test = a==1;\n echo( test ? TrueValue : FalseValue );       // false\n  \n L = 75; R = 2; test = (L/R)>25;\n TrueValue =  [test,L,R,L/R,cos(30)];\n FalseValue = [test,L,R,sin(15)];\n a1 = test ? TrueValue : FalseValue ;         // [true, 75, 2, 37.5, 0.866025]",
          "context": "This works like the ?: operator from the family of C-like programming languages."
        },
        {
          "code": "Some forms of tail-recursion elimination are supported.",
          "context": "a=1; b=2; c= a==b ? 4 : 5 ;                  //  5\n a=1; b=2; c= a==b ? \"a==b\" : \"a!=b\" ;        //  \"a!=b\"\n  \n TrueValue = true; FalseValue = false;\n a=5; test = a==1;\n echo( test ? TrueValue : FalseValue );       // false\n  \n L = 75; R = 2; test = (L/R)>25;\n TrueValue =  [test,L,R,L/R,cos(30)];\n FalseValue = [test,L,R,sin(15)];\n a1 = test ? TrueValue : FalseValue ;         // [true, 75, 2, 37.5, 0.866025]"
        },
        {
          "code": "// recursion - find the sum of the values in a vector (array) by calling itself\n // from the start (or s'th element) to the i'th element - remember elements are zero based\n\n function sumv(v, i, s = 0) = (i == s ? v[i] : v[i] + sumv(v, i-1, s));\n \n vec=[ 10, 20, 30, 40 ];\n echo(\"sum vec=\", sumv(vec, 2, 1)); // calculates 20+30=50",
          "context": "Recursive function calls are supported. Using the Conditional \"... ? ... : ... \" it's possible to ensure the recursion is terminated.\nNote: There is a built-in recursion limit to prevent an application crash. If the limit is hit, the function returns undef."
        },
        {
          "code": "// find the maximum value in a vector\nfunction maxv(v, m=-999999999999, i=0) = \n    (i == len(v) ) \n    ?     m \n    :     (m > v[i]) \n          ?    maxv(v, m, i+1) \n          :    maxv(v, v[i], i+1);\n\nv=[7,3,9,3,5,6];\necho(\"max\",maxv(v));   // ECHO: \"max\", 9",
          "context": "Multiple nested conditionals can become difficult to understand.\nFormatting them like multi-line indented \"if/else\" statements is clearer."
        },
        {
          "code": "for (i = [10:50])\n{\n    assign (angle = i*360/20, distance = i*10, r = i*2)\n    {\n        rotate(angle, [1, 0, 0])\n        translate([0, distance, 0])\n        sphere(r = r);\n    }\n}",
          "context": "No specific context available"
        },
        {
          "code": "for (i = [10:50])\n{\n    angle = i*360/20;\n    distance = i*10;\n    r = i*2;\n    rotate(angle, [1, 0, 0])\n    translate([0, distance, 0])\n    sphere(r = r);\n}",
          "context": "No specific context available"
        },
        {
          "code": "for (i = [10:50])\n{\n    let (angle = i*360/20, r= i*2, distance = r*5)\n    {\n        rotate(angle, [1, 0, 0])\n        translate([0, distance, 0])\n        sphere(r = r);\n    }\n}",
          "context": "No specific context available"
        }
      ]
    },
    "mathFunctions": {
      "title": "Mathematical Functions",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Mathematical_Functions",
      "introduction": "Trigonometric functions[edit | edit source]\n\nThe trig functions use the C Language mathematics functions, which are based in turn on Binary Floating Point mathematics, which use approximations of Real Numbers during calculation. OpenSCAD's math functions use the C++ 'double' type, inside Value.h/Value.cc,\n\nA good resource for the specifics of the C library math functions, such as valid inputs/output ranges, can be found at the Open Group website math.h & acos\n\ncos[edit | edit source]\n\nMathematical cosine function of degrees. See Cosine\n\nParameters\n\n<degrees>\nDecimal.  Angle in degrees.\n\nUsage example:\n\n\n\n for(i=[0:36])\n    translate([i*10,0,0])\n       cylinder(r=5,h=cos(i*10)*50+60);\n\n\nOpenSCAD Cos Function‎\n\nsin[edit | edit source]\n\nMathematical sine function. See Sine\n\nParameters\n\n<degrees>\nDecimal. Angle in degrees.\n\nUsage example 1:\n\n\n\n for (i = [0:5]) {\n  echo(360*i/6, sin(360*i/6)*80, cos(360*i/6)*80);\n   translate([sin(360*i/6)*80, cos(360*i/6)*80, 0 ])\n    cylinder(h = 200, r=10);\n }\n\nUsage example 2:\n\n\n\n for(i=[0:36])\n    translate([i*10,0,0])\n       cylinder(r=5,h=sin(i*10)*50+60);\n\n\nOpenSCAD Sin Function\n\ntan[edit | edit source]\n\nMathematical tangent function. See Tangent\n\nParameters\n\n<degrees>\nDecimal.  Angle in degrees.\n\nUsage example:\n\n\n\n for (i = [0:5]) {\n  echo(360*i/6, tan(360*i/6)*80);\n   translate([tan(360*i/6)*80, 0, 0 ])\n    cylinder(h = 200, r=10);\n }\n\nacos[edit | edit source]\n\nMathematical arccosine, or inverse cosine, expressed in degrees. See: Inverse trigonometric functions\n\nasin[edit | edit source]\n\nMathematical arcsine, or inverse sine, expressed in degrees. See: Inverse trigonometric functions\n\natan[edit | edit source]\n\nMathematical arctangent, or inverse tangent, function. Returns the principal value of the arc tangent of x, expressed in degrees. atan cannot distinguish between y/x and -y/-x and returns angles from -90 to +90. See: atan2 and also Inverse trigonometric functions\n\natan2[edit | edit source]\n\nMathematical two-argument atan function atan2(y,x) that spans the full 360 degrees.  This function returns the full angle between the x axis and the vector(x,y) expressed in degrees, in the range \n  \n    \n      \n        −\n        180\n        <\n        a\n        n\n        g\n        l\n        e\n        ≤\n        180\n      \n    \n    {\\displaystyle -180<angle\\leq 180}\n  \n.\n\nUsage examples:\n\natan2(5.0,-5.0);     //result: 135 degrees. atan() would give -45\natan2(y,x);          //angle between (1,0) and (x,y) = angle around z-axis\n\nOther Mathematical Functions[edit | edit source]\n\nabs[edit | edit source]\n\nMathematical absolute value function. Returns the positive value of a signed decimal number.\n\nUsage examples:\n\nabs(-5.0);  returns 5.0\nabs(0);     returns 0.0\nabs(8.0);   returns 8.0\n\nceil[edit | edit source]\n\nMathematical ceiling function.\n\nReturns the next highest integer value by rounding up value if necessary.\n\nSee: Ceil Function\n\necho(ceil(4.4),ceil(-4.4));     // produces ECHO: 5, -4\n\nconcat[edit | edit source]\n\n[Note: Requires version 2015.03]\n\nReturn a new vector that is the result of appending the elements of the supplied vectors.\n\nWhere an argument is a vector the elements of the vector are individually appended to the result vector.\nStrings are distinct from vectors in this case.\n\nUsage examples:\n\necho(concat(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"));          // produces ECHO: [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\necho(concat([\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"]));      // produces ECHO: [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\necho(concat(1,2,3,4,5,6));                      // produces ECHO: [1, 2, 3, 4, 5, 6]\n\nVector of vectors\n\necho(concat([ [1],[2] ], [ [3] ]));             // produces ECHO: [[1], [2], [3]]\n\nNote: All vectors passed to the function  lose one nesting level. When adding something like a single element [x, y, z] tuples (which are vectors, too), the tuple needs to be enclosed in a vector (i.e. an extra set of brackets) before the concatenation. in the exmple below, a fourth point is added to the polygon path, which used to resemble a triangle, making it a square now:\n\npolygon(concat([[0,0],[0,5],[5,5]], [[5,0]]));\n\nContrast with strings\n\necho(concat([1,2,3],[4,5,6]));                   // produces ECHO: [1, 2, 3, 4, 5, 6]\necho(concat(\"abc\",\"def\"));                       // produces ECHO: [\"abc\", \"def\"]\necho(str(\"abc\",\"def\"));                          // produces ECHO: \"abcdef\"\n\ncross[edit | edit source]\n\nCalculates the cross product of two vectors in 3D or 2D space. If both vectors are in the 3D, the result is a vector that is perpendicular to both of the input vectors. If both vectors are in 2D space, their cross product has the form [0,0,z] and the cross function returns just the z value of the cross product:\n\ncross([x,y], [u,v]) = x*v - y*u\n\nNote that this is the determinant of the 2×2 matrix [[x,y],[u,v]].  Using any other types, vectors with lengths different from 2 or 3, or vectors not of the same length produces 'undef'.\n\nUsage examples:\n\necho(cross([2, 3, 4], [5, 6, 7]));     // produces ECHO: [-3, 6, -3]\necho(cross([2, 1, -3], [0, 4, 5]));    // produces ECHO: [17, -10, 8]\necho(cross([2, 1], [0, 4]));           // produces ECHO: 8\necho(cross([1, -3], [4, 5]));          // produces ECHO: 17\necho(cross([2, 1, -3], [4, 5]));       // produces ECHO: undef\necho(cross([2, 3, 4], \"5\"));           // produces ECHO: undef\n\nFor any two vectors a and b in 2D or in 3D, the following holds:\n\ncross(a,b) == -cross(b,a)\n\nexp[edit | edit source]\n\nMathematical exp function. Returns the base-e exponential function of x, which is the number e raised to the power x. See: Exponent\n\necho(exp(1),exp(ln(3)*4));    // produces ECHO: 2.71828, 81\n\nfloor[edit | edit source]\n\nMathematical floor function.  floor(x) =  is the largest integer not greater than x\n\nSee: Floor Function\n\necho(floor(4.4),floor(-4.4));    // produces ECHO: 4, -5\n\nln[edit | edit source]\n\nMathematical natural logarithm.  See: Natural logarithm\n\nlen[edit | edit source]\n\nMathematical length function.  Returns the length of an array, a vector or a string parameter.\n\nUsage examples:\n\nstr1=\"abcdef\"; len_str1=len(str1);\necho(str1,len_str1);\n\na=6; len_a=len(a);\necho(a,len_a);\n\narray1=[1,2,3,4,5,6,7,8]; len_array1=len(array1);\necho(array1,len_array1);\n\narray2=[[0,0],[0,1],[1,0],[1,1]]; len_array2=len(array2);\necho(array2,len_array2);\n\nlen_array2_2=len(array2[2]);\necho(array2[2],len_array2_2);\n\nResults:\n\nWARNING: len() parameter could not be converted in file , line 4\nECHO: \"abcdef\", 6\nECHO: 6, undef\nECHO: [1, 2, 3, 4, 5, 6, 7, 8], 8\nECHO: [[0, 0], [0, 1], [1, 0], [1, 1]], 4\nECHO: [1, 0], 2\n\nThis function allows (e.g.) the parsing of an array, a vector or a string.\n\nUsage examples:\n\nstr2=\"4711\";\nfor (i=[0:len(str2)-1])\n\techo(str(\"digit \",i+1,\"  :  \",str2[i]));\n\nResults:\n\nECHO: \"digit 1  :  4\"\nECHO: \"digit 2  :  7\"\nECHO: \"digit 3  :  1\"\nECHO: \"digit 4  :  1\"\n\nNote that the len() function is not defined and raises a warning when a simple variable is passed as the parameter.\n\nThis is useful when handling parameters to a module, similar to how shapes can be defined as a single number, or as an [x,y,z] vector; i.e. cube(5) or cube([5,5,5])\n\nFor example\n\nmodule doIt(size) {\n\tif (len(size) == undef) {\n\t\t// size is a number, use it for x,y & z. (or could be undef)\n\t\tdo([size,size,size]);\n\t} else { \n\t\t// size is a vector, (could be a string but that would be stupid)\n\t\tdo(size);\n\t}\n }\n \ndoIt(5);\t// equivalent to [5,5,5]\ndoIt([5,5,5]);\t// similar to cube(5) v's cube([5,5,5])\n\nlet[edit | edit source]\n\n[Note: Requires version 2015.03]\n\nSequential assignment of variables inside an expression. The following expression is evaluated in context of the let assignments and can use the variables. This is mainly useful to make complicated expressions more readable by assigning interim results to variables.\n\nParameters\n\nlet (var1 = value1, var2 = f(var1), var3 = g(var1, var2)) expression\n\nUsage example:\n\necho(let(a = 135, s = sin(a), c = cos(a)) [ s, c ]); // ECHO: [0.707107, -0.707107]\n\nLet can also be used to create variables in a Function. (See also: \"Let Statement\")\n\nlog[edit | edit source]\n\nMathematical logarithm to the base 10. Example: log(1000) = 3. See: Logarithm\n\nlookup[edit | edit source]\n\nLook up value in table, and linearly interpolate if there's no exact match.  The first argument is the value to look up.  The second is the lookup table -- a vector of key-value pairs.\n\nParameters\n\nkey\nA lookup key\n<key,value> array\nkeys and values\n\nThere is a bug in which out-of-range keys return the first value in the list. Newer versions of Openscad should use the top or bottom end of the table as appropriate instead.\n\nUsage example: Create a 3D chart made from cylinders of different heights.\n\nfunction get_cylinder_h(p) = lookup(p, [\n \t\t[ -200, 5 ],\n \t\t[ -50, 20 ],\n \t\t[ -20, 18 ],\n \t\t[ +80, 25 ],\n \t\t[ +150, 2 ]\n \t]);\n \n for (i = [-100:5:+100]) {\n \t// echo(i, get_cylinder_h(i));\n \ttranslate([ i, 0, -30 ]) cylinder(r1 = 6, r2 = 2, h = get_cylinder_h(i)*3);\n }\n\n\nOpenSCAD Lookup Function\n\nmax[edit | edit source]\n\nReturns the maximum of the parameters. If a single vector is given as parameter, returns the maximum element of that vector.\n\nParameters\n\nmax(n,n{,n}...)\nmax(vector)\n\n<n>\nTwo or more decimals\n<vector>\nSingle vector of decimals [Note: Requires version 2014.06].\n\nUsage example:\n\nmax(3.0,5.0)\nmax(8.0,3.0,4.0,5.0)\nmax([8,3,4,5])\n\nResults:\n\n5\n8\n8\n\nmin[edit | edit source]\n\nReturns the minimum of the parameters. If a single vector is given as parameter, returns the minimum element of that vector.\n\nParameters\n\nmin(n,n{,n}...)\nmin(vector)\n\n<n>\nTwo or more decimals\n<vector>\nSingle vector of decimals [Note: Requires version 2014.06].\n\nUsage example:\n\nmin(3.0,5.0)\nmin(8.0,3.0,4.0,5.0)\nmin([8,3,4,5])\n\nResults:\n\n3\n3\n3\n\nmod[edit | edit source]\n\nIncluded in this document only for clarity. The 'modulo' operation exists in OpenSCAD as an operator %, and not as function. See modulo operator (%)\n\nnorm[edit | edit source]\n\nReturns the euclidean norm of a vector. Note this returns the actual numeric length while len returns the number of elements in the vector or array.\n\nUsage examples:\n\na=[1,2,3,4];\nb=\"abcd\";\nc=[];\nd=\"\";\ne=[[1,2,3,4],[1,2,3],[1,2],[1]];\necho(norm(a)); //5.47723\necho(norm(b)); //undef\necho(norm(c)); //0\necho(norm(d)); //undef\necho(norm(e[0])); //5.47723\necho(norm(e[1])); //3.74166\necho(norm(e[2])); //2.23607\necho(norm(e[3])); //1\n\nResults:\n\nECHO: 5.47723\nECHO: undef\nECHO: 0\nECHO: undef\nECHO: 5.47723\nECHO: 3.74166\nECHO: 2.23607\nECHO: 1\n\npow[edit | edit source]\n\nMathematical power function.\n\nAs of version 2021.01 you can use the exponentiation operator ^ instead.\n\nParameters\n\n<base>\nDecimal.  Base.\n<exponent>\nDecimal.  Exponent.\n\nUsage examples:\n\nfor (i = [0:5]) {\n translate([i*25,0,0]) {\n   cylinder(h = pow(2,i)*5, r=10);\n   echo (i, pow(2,i));\n }\n}\n\necho(pow(10,2)); // means 10^2 or 10*10\n// result: ECHO: 100\n\necho(pow(10,3)); // means 10^3 or 10*10*10\n// result: ECHO: 1000\n\necho(pow(125,1/3)); // means 125^(0.333...), which calculates the cube root of 125\n// result: ECHO: 5\n\nrands[edit | edit source]\n\nRandom number generator.\nGenerates a constant vector of pseudo random numbers, much like an array. The numbers are doubles not integers.\nWhen generating only one number, you still call it with variable[0].\n\nParameters\n\nmin_value\nMinimum value of random number range\nmax_value\nMaximum value of random number range\nvalue_count\nNumber of random numbers to return as a vector\nseed_value (optional)\nSeed value for random number generator for repeatable results. On versions before late 2015, seed_value gets rounded to the nearest integer\n\nUsage examples:\n\n// get a single number\nsingle_rand = rands(0,10,1)[0];\necho(single_rand);\n\n// get a vector of 4 numbers\nseed=42;\nrandom_vect=rands(5,15,4,seed);\necho( \"Random Vector: \",random_vect);\nsphere(r=5);\nfor(i=[0:3]) {\n rotate(360*i/4) {\n   translate([10+random_vect[i],0,0])\n     sphere(r=random_vect[i]/2);\n }\n}\n// ECHO: \"Random Vector: \", [8.7454, 12.9654, 14.5071, 6.83435]\n\nround[edit | edit source]\n\nThe \"round\" operator returns the greatest or least integer part, respectively, if the numeric input is positive or negative.\n\nUsage examples:\n\nround(5.4);\nround(5.5);\nround(5.6);\nround(-5.4);\nround(-5.5);\nround(-5.6);\n\nResults:\n\n5\n6\n6\n-5\n-6\n-6\n\nsign[edit | edit source]\n\nMathematical signum function. Returns a unit value that extracts the sign of a value see: Signum function\n\nParameters\n\n<x>\nDecimal.  Value to find the sign of.\n\nUsage examples:\n\nsign(-5.0);\nsign(0);\nsign(8.0);\n\nResults:\n\n-1.0\n0.0\n1.0\n\nsqrt[edit | edit source]\n\nMathematical square root function.\n\nUsage example\n\ntranslate([sqrt(100),0,0])sphere(100);\n\nInfinities and NaNs[edit | edit source]\n\nHow does OpenSCAD deal with inputs like (1/0)? Basically, the behavior is inherited from the language OpenSCAD was written in, the C++ language, and its floating point number types and the associated C math library. This system allows representation of both positive and negative infinity by the special values \"Inf\" or \"-Inf\". It also allow representation of creatures like sqrt(-1) or 0/0 as \"NaN\", an abbreviation for \"Not A Number\". Explanations can be found on the web, for example the Open Group's site on math.h or  Wikipedia's page on the IEEE 754 number format. However, OpenSCAD is its own language so it may not exactly match everything that happens in C. For example, OpenSCAD uses degrees instead of radians for trigonometric functions. Another example is that sin() does not throw a \"domain error\" when the input is 1/0, although it does return NaN.\n\nHere are some examples of infinite input to OpenSCAD math functions and the resulting output, taken from OpenSCAD's regression test system in late 2015.\n\n0/0: nan\nsin(1/0): nan\nasin(1/0): nan\nln(1/0): inf\nround(1/0): inf\n\n\n-0/0: nan\ncos(1/0): nan\nacos(1/0): nan\nln(-1/0): nan\nround(-1/0): -inf\n\n\n0/-0: nan\ntan(1/0): nan\natan(1/0): 90\nlog(1/0): inf\nsign(1/0): 1\n\n\n1/0: inf\nceil(-1/0): -inf\natan(-1/0): -90\nlog(-1/0): nan\nsign(-1/0): -1\n\n\n1/-0: -inf\nceil(1/0): inf\natan2(1/0, -1/0): 135\nmax(-1/0, 1/0): inf\nsqrt(1/0): inf\n\n\n-1/0: -inf\nfloor(-1/0): -inf\nexp(1/0): inf\nmin(-1/0, 1/0): -inf\nsqrt(-1/0): nan\n\n\n-1/-0: inf\nfloor(1/0): inf\nexp(-1/0): 0\npow(2, 1/0): inf\npow(2, -1/0): 0",
      "content": {},
      "codeExamples": [
        {
          "code": "for(i=[0:36])\n    translate([i*10,0,0])\n       cylinder(r=5,h=cos(i*10)*50+60);",
          "context": "No specific context available"
        },
        {
          "code": "for (i = [0:5]) {\n  echo(360*i/6, sin(360*i/6)*80, cos(360*i/6)*80);\n   translate([sin(360*i/6)*80, cos(360*i/6)*80, 0 ])\n    cylinder(h = 200, r=10);\n }",
          "context": "No specific context available"
        },
        {
          "code": "for(i=[0:36])\n    translate([i*10,0,0])\n       cylinder(r=5,h=sin(i*10)*50+60);",
          "context": "No specific context available"
        },
        {
          "code": "for (i = [0:5]) {\n  echo(360*i/6, tan(360*i/6)*80);\n   translate([tan(360*i/6)*80, 0, 0 ])\n    cylinder(h = 200, r=10);\n }",
          "context": "No specific context available"
        },
        {
          "code": "atan2(5.0,-5.0);     //result: 135 degrees. atan() would give -45\natan2(y,x);          //angle between (1,0) and (x,y) = angle around z-axis",
          "context": "Usage examples:"
        },
        {
          "code": "abs(-5.0);  returns 5.0\nabs(0);     returns 0.0\nabs(8.0);   returns 8.0",
          "context": "Usage examples:"
        },
        {
          "code": "echo(ceil(4.4),ceil(-4.4));     // produces ECHO: 5, -4",
          "context": "See: Ceil Function"
        },
        {
          "code": "echo(concat(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\"));          // produces ECHO: [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\necho(concat([\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"]));      // produces ECHO: [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"]\necho(concat(1,2,3,4,5,6));                      // produces ECHO: [1, 2, 3, 4, 5, 6]",
          "context": "Usage examples:"
        },
        {
          "code": "echo(concat([ [1],[2] ], [ [3] ]));             // produces ECHO: [[1], [2], [3]]",
          "context": "Vector of vectors"
        },
        {
          "code": "polygon(concat([[0,0],[0,5],[5,5]], [[5,0]]));",
          "context": "Note: All vectors passed to the function  lose one nesting level. When adding something like a single element [x, y, z] tuples (which are vectors, too), the tuple needs to be enclosed in a vector (i.e. an extra set of brackets) before the concatenation. in the exmple below, a fourth point is added to the polygon path, which used to resemble a triangle, making it a square now:"
        },
        {
          "code": "echo(concat([1,2,3],[4,5,6]));                   // produces ECHO: [1, 2, 3, 4, 5, 6]\necho(concat(\"abc\",\"def\"));                       // produces ECHO: [\"abc\", \"def\"]\necho(str(\"abc\",\"def\"));                          // produces ECHO: \"abcdef\"",
          "context": "Contrast with strings"
        },
        {
          "code": "echo(cross([2, 3, 4], [5, 6, 7]));     // produces ECHO: [-3, 6, -3]\necho(cross([2, 1, -3], [0, 4, 5]));    // produces ECHO: [17, -10, 8]\necho(cross([2, 1], [0, 4]));           // produces ECHO: 8\necho(cross([1, -3], [4, 5]));          // produces ECHO: 17\necho(cross([2, 1, -3], [4, 5]));       // produces ECHO: undef\necho(cross([2, 3, 4], \"5\"));           // produces ECHO: undef",
          "context": "Usage examples:"
        },
        {
          "code": "echo(exp(1),exp(ln(3)*4));    // produces ECHO: 2.71828, 81",
          "context": "Mathematical exp function. Returns the base-e exponential function of x, which is the number e raised to the power x. See: Exponent"
        },
        {
          "code": "echo(floor(4.4),floor(-4.4));    // produces ECHO: 4, -5",
          "context": "See: Floor Function"
        },
        {
          "code": "str1=\"abcdef\"; len_str1=len(str1);\necho(str1,len_str1);\n\na=6; len_a=len(a);\necho(a,len_a);\n\narray1=[1,2,3,4,5,6,7,8]; len_array1=len(array1);\necho(array1,len_array1);\n\narray2=[[0,0],[0,1],[1,0],[1,1]]; len_array2=len(array2);\necho(array2,len_array2);\n\nlen_array2_2=len(array2[2]);\necho(array2[2],len_array2_2);",
          "context": "Usage examples:"
        },
        {
          "code": "WARNING: len() parameter could not be converted in file , line 4\nECHO: \"abcdef\", 6\nECHO: 6, undef\nECHO: [1, 2, 3, 4, 5, 6, 7, 8], 8\nECHO: [[0, 0], [0, 1], [1, 0], [1, 1]], 4\nECHO: [1, 0], 2",
          "context": "str1=\"abcdef\"; len_str1=len(str1);\necho(str1,len_str1);\n\na=6; len_a=len(a);\necho(a,len_a);\n\narray1=[1,2,3,4,5,6,7,8]; len_array1=len(array1);\necho(array1,len_array1);\n\narray2=[[0,0],[0,1],[1,0],[1,1]]; len_array2=len(array2);\necho(array2,len_array2);\n\nlen_array2_2=len(array2[2]);\necho(array2[2],len_array2_2);"
        },
        {
          "code": "str2=\"4711\";\nfor (i=[0:len(str2)-1])\n\techo(str(\"digit \",i+1,\"  :  \",str2[i]));",
          "context": "Usage examples:"
        },
        {
          "code": "ECHO: \"digit 1  :  4\"\nECHO: \"digit 2  :  7\"\nECHO: \"digit 3  :  1\"\nECHO: \"digit 4  :  1\"",
          "context": "str2=\"4711\";\nfor (i=[0:len(str2)-1])\n\techo(str(\"digit \",i+1,\"  :  \",str2[i]));"
        },
        {
          "code": "module doIt(size) {\n\tif (len(size) == undef) {\n\t\t// size is a number, use it for x,y & z. (or could be undef)\n\t\tdo([size,size,size]);\n\t} else { \n\t\t// size is a vector, (could be a string but that would be stupid)\n\t\tdo(size);\n\t}\n }\n \ndoIt(5);\t// equivalent to [5,5,5]\ndoIt([5,5,5]);\t// similar to cube(5) v's cube([5,5,5])",
          "context": "For example"
        },
        {
          "code": "let (var1 = value1, var2 = f(var1), var3 = g(var1, var2)) expression",
          "context": "Sequential assignment of variables inside an expression. The following expression is evaluated in context of the let assignments and can use the variables. This is mainly useful to make complicated expressions more readable by assigning interim results to variables."
        },
        {
          "code": "echo(let(a = 135, s = sin(a), c = cos(a)) [ s, c ]); // ECHO: [0.707107, -0.707107]",
          "context": "Usage example:"
        },
        {
          "code": "function get_cylinder_h(p) = lookup(p, [\n \t\t[ -200, 5 ],\n \t\t[ -50, 20 ],\n \t\t[ -20, 18 ],\n \t\t[ +80, 25 ],\n \t\t[ +150, 2 ]\n \t]);\n \n for (i = [-100:5:+100]) {\n \t// echo(i, get_cylinder_h(i));\n \ttranslate([ i, 0, -30 ]) cylinder(r1 = 6, r2 = 2, h = get_cylinder_h(i)*3);\n }",
          "context": "No specific context available"
        },
        {
          "code": "max(n,n{,n}...)\nmax(vector)",
          "context": "Returns the maximum of the parameters. If a single vector is given as parameter, returns the maximum element of that vector."
        },
        {
          "code": "max(3.0,5.0)\nmax(8.0,3.0,4.0,5.0)\nmax([8,3,4,5])",
          "context": "Usage example:"
        },
        {
          "code": "5\n8\n8",
          "context": "max(3.0,5.0)\nmax(8.0,3.0,4.0,5.0)\nmax([8,3,4,5])"
        },
        {
          "code": "min(n,n{,n}...)\nmin(vector)",
          "context": "Returns the minimum of the parameters. If a single vector is given as parameter, returns the minimum element of that vector."
        },
        {
          "code": "min(3.0,5.0)\nmin(8.0,3.0,4.0,5.0)\nmin([8,3,4,5])",
          "context": "Usage example:"
        },
        {
          "code": "3\n3\n3",
          "context": "min(3.0,5.0)\nmin(8.0,3.0,4.0,5.0)\nmin([8,3,4,5])"
        },
        {
          "code": "a=[1,2,3,4];\nb=\"abcd\";\nc=[];\nd=\"\";\ne=[[1,2,3,4],[1,2,3],[1,2],[1]];\necho(norm(a)); //5.47723\necho(norm(b)); //undef\necho(norm(c)); //0\necho(norm(d)); //undef\necho(norm(e[0])); //5.47723\necho(norm(e[1])); //3.74166\necho(norm(e[2])); //2.23607\necho(norm(e[3])); //1",
          "context": "Usage examples:"
        },
        {
          "code": "ECHO: 5.47723\nECHO: undef\nECHO: 0\nECHO: undef\nECHO: 5.47723\nECHO: 3.74166\nECHO: 2.23607\nECHO: 1",
          "context": "a=[1,2,3,4];\nb=\"abcd\";\nc=[];\nd=\"\";\ne=[[1,2,3,4],[1,2,3],[1,2],[1]];\necho(norm(a)); //5.47723\necho(norm(b)); //undef\necho(norm(c)); //0\necho(norm(d)); //undef\necho(norm(e[0])); //5.47723\necho(norm(e[1])); //3.74166\necho(norm(e[2])); //2.23607\necho(norm(e[3])); //1"
        },
        {
          "code": "for (i = [0:5]) {\n translate([i*25,0,0]) {\n   cylinder(h = pow(2,i)*5, r=10);\n   echo (i, pow(2,i));\n }\n}",
          "context": "Usage examples:"
        },
        {
          "code": "echo(pow(10,2)); // means 10^2 or 10*10\n// result: ECHO: 100\n\necho(pow(10,3)); // means 10^3 or 10*10*10\n// result: ECHO: 1000\n\necho(pow(125,1/3)); // means 125^(0.333...), which calculates the cube root of 125\n// result: ECHO: 5",
          "context": "for (i = [0:5]) {\n translate([i*25,0,0]) {\n   cylinder(h = pow(2,i)*5, r=10);\n   echo (i, pow(2,i));\n }\n}"
        },
        {
          "code": "// get a single number\nsingle_rand = rands(0,10,1)[0];\necho(single_rand);",
          "context": "Usage examples:"
        },
        {
          "code": "// get a vector of 4 numbers\nseed=42;\nrandom_vect=rands(5,15,4,seed);\necho( \"Random Vector: \",random_vect);\nsphere(r=5);\nfor(i=[0:3]) {\n rotate(360*i/4) {\n   translate([10+random_vect[i],0,0])\n     sphere(r=random_vect[i]/2);\n }\n}\n// ECHO: \"Random Vector: \", [8.7454, 12.9654, 14.5071, 6.83435]",
          "context": "// get a single number\nsingle_rand = rands(0,10,1)[0];\necho(single_rand);"
        },
        {
          "code": "round(5.4);\nround(5.5);\nround(5.6);\nround(-5.4);\nround(-5.5);\nround(-5.6);",
          "context": "Usage examples:"
        },
        {
          "code": "5\n6\n6\n-5\n-6\n-6",
          "context": "round(5.4);\nround(5.5);\nround(5.6);\nround(-5.4);\nround(-5.5);\nround(-5.6);"
        },
        {
          "code": "sign(-5.0);\nsign(0);\nsign(8.0);",
          "context": "Usage examples:"
        },
        {
          "code": "-1.0\n0.0\n1.0",
          "context": "sign(-5.0);\nsign(0);\nsign(8.0);"
        },
        {
          "code": "translate([sqrt(100),0,0])sphere(100);",
          "context": "Usage example"
        }
      ]
    },
    "stringFunctions": {
      "title": "String Functions",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/String_Functions",
      "introduction": "str[edit | edit source]\n\nConvert all arguments to strings and concatenate.\n\nUsage examples:\n\nnumber=2;\necho (\"This is \",number,3,\" and that's it.\");\necho (str(\"This is \",number,3,\" and that's it.\"));\n\nResults:\n\nECHO: \"This is \", 2, 3, \" and that's it.\"\nECHO: \"This is 23 and that's it.\"\n\nThis can be used for simple conversion of numbers to strings\n\ns = str(n);\n\nchr[edit | edit source]\n\n[Note: Requires version 2015.03]\n\nConvert numbers to a string containing character with the corresponding code. OpenSCAD uses Unicode, so the number is interpreted as Unicode code point. Numbers outside the valid code point range produce an empty string.\n\nParameters\n\nchr(Number)\nConvert one code point to a string of length 1 (number of bytes depending on UTF-8 encoding) if the code point is valid.\n\nchr(Vector)\nConvert all code points given in the argument vector to a string.\n\nchr(Range)\nConvert all code points produced by the range argument to a string.\n\nExamples\n\necho(chr(65), chr(97));      // ECHO: \"A\", \"a\"\necho(chr(65, 97));           // ECHO: \"Aa\"\necho(chr([66, 98]));         // ECHO: \"Bb\"\necho(chr([97 : 2 : 102]));   // ECHO: \"ace\"\necho(chr(-3));               // ECHO: \"\"\necho(chr(9786), chr(9788));  // ECHO: \"☺\", \"☼\"\necho(len(chr(9788)));        // ECHO: 1\n\nNote: When used with echo() the output to the console for character codes greater than 127 is platform dependent.\n\nord[edit | edit source]\n\n[Note: Requires version 2019.05]\n\nConvert a character to a number representing the Unicode code point. If the parameter is not a string, the ord() returns undef.\n\nParameters\n\nord(String)\nConvert the first character of the given string to a Unicode code point.\n\nExamples\n\necho(ord(\"a\"));\n// ECHO: 97\n\necho(ord(\"BCD\"));\n// ECHO: 66\n\necho([for (c = \"Hello! 🙂\") ord(c)]);\n// ECHO: [72, 101, 108, 108, 111, 33, 32, 128578]\n\ntxt=\"1\";\necho(ord(txt)-48,txt);\n// ECHO: 1,\"1\" // only converts 1 character\n\nlen[edit | edit source]\n\nreturns the number of characters in a text.\n\necho(len(\"Hello world\"));    // 11\n\nAlso See search()[edit | edit source]\n\nsearch() for text searching.\n\nis_string(value)[edit | edit source]\n\nThe function is_string(value) return true if the value is a string, false else\n\necho(is_string(\"alpha\")); //true\necho(is_string(22)); //false\n\nUser defined functions[edit | edit source]\n\nTo complement native functions, you can define your own functions, some suggestions:\n\n//-- Lower case all chars of a string -- does not work with accented characters\nfunction strtolower (string) = \n  chr([for(s=string) let(c=ord(s)) c<91 && c>64 ?c+32:c]); \n\n//-- Replace char(not string) in a string  \nfunction char_replace (s,old=\" \",new=\"_\") = \n  chr([for(i=[0:len(s)-1]) s[i]==old?ord(new):ord(s[i])]);\n\n//-- Replace last chars of a string (can be used for file extension replacement of same length)\nfunction str_rep_last (s,new=\".txt\") = \n  str(chr([for(i=[0 :len(s)-len(new)-1])ord(s[i])]),new);\n\n//-- integer value from string ---------- \n//Parameters ret and i are for function internal use (recursion)\nfunction strtoint (s, ret=0, i=0) =\n  i >= len(s)\n  ? ret\n  : strtoint(s, ret*10 + ord(s[i]) - ord(\"0\"), i+1);\n\nNote here the use of chr() to recompose a string from unknown number of caracters defined by their ascii code. This avoid using recursive modules as was required before list management came in.",
      "content": {},
      "codeExamples": [
        {
          "code": "number=2;\necho (\"This is \",number,3,\" and that's it.\");\necho (str(\"This is \",number,3,\" and that's it.\"));",
          "context": "Usage examples:"
        },
        {
          "code": "ECHO: \"This is \", 2, 3, \" and that's it.\"\nECHO: \"This is 23 and that's it.\"",
          "context": "number=2;\necho (\"This is \",number,3,\" and that's it.\");\necho (str(\"This is \",number,3,\" and that's it.\"));"
        },
        {
          "code": "s = str(n);",
          "context": "This can be used for simple conversion of numbers to strings"
        },
        {
          "code": "echo(chr(65), chr(97));      // ECHO: \"A\", \"a\"\necho(chr(65, 97));           // ECHO: \"Aa\"\necho(chr([66, 98]));         // ECHO: \"Bb\"\necho(chr([97 : 2 : 102]));   // ECHO: \"ace\"\necho(chr(-3));               // ECHO: \"\"\necho(chr(9786), chr(9788));  // ECHO: \"☺\", \"☼\"\necho(len(chr(9788)));        // ECHO: 1",
          "context": "No specific context available"
        },
        {
          "code": "echo(ord(\"a\"));\n// ECHO: 97\n\necho(ord(\"BCD\"));\n// ECHO: 66\n\necho([for (c = \"Hello! 🙂\") ord(c)]);\n// ECHO: [72, 101, 108, 108, 111, 33, 32, 128578]\n\ntxt=\"1\";\necho(ord(txt)-48,txt);\n// ECHO: 1,\"1\" // only converts 1 character",
          "context": "No specific context available"
        },
        {
          "code": "echo(len(\"Hello world\"));    // 11",
          "context": "No specific context available"
        },
        {
          "code": "echo(is_string(\"alpha\")); //true\necho(is_string(22)); //false",
          "context": "No specific context available"
        },
        {
          "code": "//-- Lower case all chars of a string -- does not work with accented characters\nfunction strtolower (string) = \n  chr([for(s=string) let(c=ord(s)) c<91 && c>64 ?c+32:c]); \n\n//-- Replace char(not string) in a string  \nfunction char_replace (s,old=\" \",new=\"_\") = \n  chr([for(i=[0:len(s)-1]) s[i]==old?ord(new):ord(s[i])]);\n\n//-- Replace last chars of a string (can be used for file extension replacement of same length)\nfunction str_rep_last (s,new=\".txt\") = \n  str(chr([for(i=[0 :len(s)-len(new)-1])ord(s[i])]),new);\n\n//-- integer value from string ---------- \n//Parameters ret and i are for function internal use (recursion)\nfunction strtoint (s, ret=0, i=0) =\n  i >= len(s)\n  ? ret\n  : strtoint(s, ret*10 + ord(s[i]) - ord(\"0\"), i+1);",
          "context": "No specific context available"
        }
      ]
    },
    "userDefinedFunctions": {
      "title": "User Defined Functions",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/User-Defined_Functions_and_Modules",
      "introduction": "Users can extend the language by defining their own functions and modules. This allows grouping portions of script for easy reuse with different values. \nWell chosen names also help document your script.\n\nFunctions return values.\n\nModules perform actions, but do not return values.\n\nOpenSCAD calculates the value of variables  at compile-time, not run-time.\nThe last variable assignment within a scope applies everywhere in that scope. It also applies to any inner scopes, or children, thereof. \nSee Scope of variables for more details.\nIt may be helpful to think of them as override-able constants rather than as variables.\n\nFor functions and modules OpenSCAD makes copies of pertinent portions of the script for each use. \nEach copy has its own scope, which contains fixed values for variables and expressions unique to that instance.\n\nThe name of functions and modules is case sensitive, therefore test() and TEST() refer to different functions/modules.\n\nScope[edit | edit source]\n\nModules and functions can be defined within a module definition, where they are visible only in the scope of that module.\n\nFor example\n\nfunction parabola(f,x) = ( 1/(4*f) ) * x*x; \nmodule plotParabola(f,wide,steps=1) {\n  function y(x) = parabola(f,x);\n  module plot(x,y) {\n    translate([x,y])\n      circle(1,$fn=12);\n  }\n  xAxis=[-wide/2:steps:wide/2];\n  for (x=xAxis) \n    plot(x, y(x));\n}\ncolor(\"red\")  plotParabola(10, 100, 5);\ncolor(\"blue\") plotParabola(4,  60,  2);\n\nThe function y() and module plot() cannot be called in the global scope.\n\nFunctions[edit | edit source]\n\nFunctions operate on values to calculate and return new values.\n\nfunction definition\n\nfunction name ( parameters ) = value ;\n\nname\nYour name for this function. A meaningful name is helpful later.   Currently valid names can only be composed of simple characters and underscores [a-zA-Z0-9_] and do not allow high-ascii or unicode characters.\nparameters\nZero or more arguments. Parameters can be assigned default values, to use in case they are omitted in the call. Parameter names are local and do not conflict with external variables of the same name.\nvalue\nan expression that calculates a value. This value can be a vector.\n\nFunction use[edit | edit source]\n\nWhen used, functions are treated as values, and do not themselves end with a semicolon ;.\n\n// example 1\n    \nfunction func0() = 5;\nfunction func1(x=3) = 2*x+1;\nfunction func2() = [1,2,3,4];\nfunction func3(y=7) = (y==7) ? 5 : 2 ;\nfunction func4(p0,p1,p2,p3) = [p0,p1,p2,p3];\n    \necho(func0());            // 5\na =   func1();            // 7\nb =   func1(5);           // 11\necho(func2());            // [1, 2, 3, 4]\necho(func3(2), func3());  // 2, 5\n   \nz = func4(func0(), func1(), func2(), func3());\n//  [5, 7, [1, 2, 3, 4], 5]\n   \ntranslate([0, -4*func0(), 0])\n  cube([func0(), 2*func0(), func0()]);\n// same as translate([0,-20,0]) cube([5,10,5]);\n\n// example 2  creates for() range to give desired no of steps to cover range\n  \nfunction steps(start, no_steps, end) =\n  [start : (end-start)/(no_steps-1) : end];\n  \necho(steps(10, 3, 5));                // [10 : -2.5 : 5]\nfor (i = steps(10, 3, 5))  echo(i);   //  10 7.5 5\n  \necho(steps(10, 3, 15));               // [10 : 2.5 : 15]\nfor (i = steps(10, 3, 15)) echo(i);   // 10 12.5 15\n  \necho(steps(0, 5, 5));                // [0 : 1.25 : 5]\nfor (i = steps(0, 5, 5))   echo(i);  // 0 1.25 2.5 3.75 5\n\nExample 3\n\n// example 3     rectangle with top pushed over, keeping same y\n  \nfunction rhomboid(x=1, y=1, angle=90)\n  = [[0,0],[x,0],\n    [x+x*cos(angle)/sin(angle),y],\n    [x*cos(angle)/sin(angle),y]];\n    \necho (v1); v1 = rhomboid(10,10,35);  // [[0, 0], \n                                     // [10, 0], \n                                     // [24.2815, 10],\n                                     // [14.2815, 10]]\npolygon(v1);\npolygon(rhomboid(10,10,35));         // alternate\n\n//performing the same action with a module\n   \nmodule parallelogram(x=1,y=1,angle=90)\n    {polygon([[0,0],[x,0],\n              [x+x*cos(angle)/sin(angle),y],\n              [x*cos(angle)/sin(angle),y]]);};\n  \nparallelogram(10,10,35);\n\nYou can also use the let statement to create variables in a function:\n\nfunction get_square_triangle_perimeter(p1, p2) =\n  let (hypotenuse = sqrt(p1*p1+p2*p2))\n    p1 + p2 + hypotenuse;\n\nIt can be used to store values in recursive functions. See the wikipedia page for more information on the general concept.\n\nRecursive functions[edit | edit source]\n\nRecursive function calls are supported. Using the Conditional Operator \"... ? ... : ... \", it is possible to ensure the recursion is terminated.\n\n// recursion example: add all integers up to n\nfunction add_up_to(n) = ( n==0 ? 0 : n + add_up_to(n-1) );\n\nThere is a built-in recursion limit to prevent an application crash (a few thousands). If the limit is hit, you get an error like: ERROR: Recursion detected calling function ... .\n\nFor all tail-recursive functions that calls itself, OpenSCAD is able to eliminate internally the recursion transforming it in an iterative loop. The previous example code is not a tail call as an \"add\" operation need to be calculated after calling. But the following is entitled to tail-recursion elimination:\n\n// tail-recursion elimination example: add all integers up to n\nfunction add_up_to(n, sum=0) =\n    n==0 ?\n        sum :\n        add_up_to(n-1, sum+n);\n \necho(sum=add_up_to(100000));\n// ECHO: sum = 5.00005e+009\n\nTail-recursion elimination allows much higher recursion limits (up to 1000000).\n\nFunction literals[edit | edit source]\n\n[Note: Requires version 2021.01]\n\nFunction literals are expressions that define functions, other names for this are lambdas or closures.\n\nfunction literal\n\nfunction (x) x + x\n\nFunction literals can be assigned to variables and passed around like any value. Calling the function uses the normal function call syntax with parenthesis.\n\nfunc = function (x) x * x;\necho(func(5)); // ECHO: 25\n\nIt's possible to define functions that return functions. Unbound variables are captured by lexical scope.\n\na = 1;\nselector = function (which)\n             which == \"add\"\n             ? function (x) x + x + a\n             : function (x) x * x + a;\n             \necho(selector(\"add\"));     // ECHO: function(x) ((x + x) + a)\necho(selector(\"add\")(5));  // ECHO: 11\n\necho(selector(\"mul\"));     // ECHO: function(x) ((x * x) + a)\necho(selector(\"mul\")(5));  // ECHO: 26\n\nOverwriting built-in functions[edit | edit source]\n\nIt is possible to overwrite the built-in functions. Note that definitions are handled first, so the evaluation does indeed return true for both echo() calls as those are evaluated in a later processing step.\n\nSource Code\n\nConsole output\n\n\necho (sin(1));\nfunction sin(x) = true;\necho (sin(1));\n\n\nCompiling design (CSG Tree generation)...\nECHO: true\nECHO: true\nCompiling design (CSG Products generation)...\n\nModules[edit | edit source]\n\nModules can be used to define objects or, using children(), define operators.\nOnce defined, modules are temporarily added to the language.\n\nmodule definition\n\nmodule name ( parameters ) { actions }\n\nname\nYour name for this module. Try to pick something meaningful.  Currently valid names can only be composed of simple characters and underscores [a-zA-Z0-9_] and do not allow high-ascii or unicode characters.\nparameters\nZero or more arguments. Parameters may be assigned default values, to use in case they are omitted in the call. Parameter names are local and do not conflict with external variables of the same name.\nactions\nNearly any statement valid outside a module can be included within a module. This includes the definition of functions and other modules. Such functions and modules can be called only from within the enclosing module.\n\nVariables can be assigned, but their scope is limited to within each individual use of the module. There is no mechanism in OpenSCAD for modules to return values to the outside.\nSee Scope of variables for more details.\n\nObject modules[edit | edit source]\n\nObject modules use one or more primitives, with associated operators, to define new objects.\n\nIn use, object modules are actions ending with a semi-colon ';'.\n\nname ( parameter values );\n\nColor bar\n\n//example 1\n   \ntranslate([-30,-20,0])\n   ShowColorBars(Expense);\n   \nColorBreak=[[0,\"\"],\n           [20,\"lime\"],  // upper limit of color range\n           [40,\"greenyellow\"],\n           [60,\"yellow\"],\n           [75,\"LightCoral\"],\n           [200,\"red\"]];\nExpense=[16,20,25,85,52,63,45];\n   \nmodule ColorBar(value,period,range){  // 1 color on 1 bar\n   RangeHi = ColorBreak[range][0];\n   RangeLo = ColorBreak[range-1][0];\n   color( ColorBreak[range][1] ) \n   translate([10*period,0,RangeLo])\n      if (value > RangeHi)      cube([5,2,RangeHi-RangeLo]);\n      else if (value > RangeLo) cube([5,2,value-RangeLo]);\n  }  \nmodule ShowColorBars(values){\n    for (month = [0:len(values)-1], range = [1:len(ColorBreak)-1])\n      ColorBar(values[month],month,range);\n}\n\nHouse\n\n//example 2\nmodule house(roof=\"flat\",paint=[1,0,0]) {\n   color(paint)\n   if(roof==\"flat\") { translate([0,-1,0]) cube(); }\n   else if(roof==\"pitched\") {\n     rotate([90,0,0]) linear_extrude(height=1)\n     polygon(points=[[0,0],[0,1],[0.5,1.5],[1,1],[1,0]]); }\n   else if(roof==\"domical\") {\n     translate([0,-1,0]){\n       translate([0.5,0.5,1]) sphere(r=0.5,$fn=20); cube(); }\n} }\n\n                   house();\ntranslate([2,0,0]) house(\"pitched\");\ntranslate([4,0,0]) house(\"domical\",[0,1,0]);\ntranslate([6,0,0]) house(roof=\"pitched\",paint=[0,0,1]);\ntranslate([0,3,0]) house(paint=[0,0,0],roof=\"pitched\");\ntranslate([2,3,0]) house(roof=\"domical\");\ntranslate([4,3,0]) house(paint=[0,0.5,0.5]);\n\n//example 3\n   \nelement_data = [[0,\"\",\"\",0],  // must be in order\n    [1,\"Hydrogen\",\"H\",1.008],   // indexed via atomic number\n    [2,\"Helium\",  \"He\",4.003]   // redundant atomic number to preserve your sanity later\n];\n   \nHydrogen = 1;\nHelium   = 2;\n      \nmodule coaster(atomic_number){\n    element     = element_data[atomic_number][1];\n    symbol      = element_data[atomic_number][2];\n    atomic_mass = element_data[atomic_number][3];\n    //rest of script\n}\n\nOperator modules[edit | edit source]\n\nChildren[edit | edit source]\n\nUse of children() allows modules to act as operators applied to any or all of the objects within this module instantiation. \nIn use, operator modules do not end with a semi-colon.\n\nname ( parameter values ){scope of operator}\n\nBasicly the children() command is used to apply modifications to objects that are focused by a scope:\n\nmodule myModification() { rotate([0,45,0]) children(); } \n \n myModification()                 // The modification\n {                                // Begin focus\n   cylinder(10,4,4);              // First child\n   cube([20,2,2], true);          // Second child\n }                                // End focus\n\nObjects are indexed via integers from 0 to $children-1. OpenSCAD sets $children to the total number of objects within the scope.\nObjects grouped into a sub scope are treated as one child. \nSee example of separate children below and Scope of variables. Note that children(), echo() and empty block statements (including ifs) count as $children objects, even if no geometry is present (as of v2017.12.23).\n\nchildren();                         all children\n children(index);                    value or variable to select one child\n children([start : step : end]);     select from start to end incremented by step\n children([start : end]);            step defaults to 1 or -1\n children([vector]);                 selection of several children\n\nDeprecated child() module\n\nUp to release 2013.06 the now deprecated child() module was used instead. This can be translated to the new children() according to the table:\n\nup to 2013.06\n2014.03 and later\n\n\nchild()\nchildren(0)\n\n\nchild(x)\nchildren(x)\n\n\nfor (a = [0:$children-1]) child(a)\nchildren([0:$children-1])\n\nUse all children\n\nExamples\n\n//Use all children\n    \nmodule move(x=0,y=0,z=0,rx=0,ry=0,rz=0)\n{ translate([x,y,z])rotate([rx,ry,rz]) children(); }\n   \nmove(10)           cube(10,true);\nmove(-10)          cube(10,true);\nmove(z=7.07, ry=45)cube(10,true);\nmove(z=-7.07,ry=45)cube(10,true);\n\nUse only the first child, multiple times\n\n//Use only the first child, multiple times\n  \nmodule lineup(num, space) {\n   for (i = [0 : num-1])\n     translate([ space*i, 0, 0 ]) children(0);\n}\n\nlineup(5, 65){ sphere(30);cube(35);}\n\nSeparate action for each child\n\n//Separate action for each child\n   \n  module SeparateChildren(space){\n    for ( i= [0:1:$children-1])   // step needed in case $children < 2  \n      translate([i*space,0,0]) {children(i);text(str(i));}\n  }\n   \n  SeparateChildren(-20){\n    cube(5);              // 0\n    sphere(5);            // 1\n    translate([0,20,0]){  // 2\n      cube(5);\n      sphere(5);\n    }     \n    cylinder(15);         // 3\n    cube(8,true);         // 4\n  }\n  translate([0,40,0])color(\"lightblue\")\n    SeparateChildren(20){cube(3,true);}\n\nMultiple ranges\n\n//Multiple ranges\nmodule MultiRange(){\n   color(\"lightblue\") children([0:1]);\n   color(\"lightgreen\")children([2:$children-2]);\n   color(\"lightpink\") children($children-1);\n}\n   \nMultiRange()\n{\n   cube(5);              // 0\n   sphere(5);            // 1\n   translate([0,20,0]){  // 2\n     cube(5);\n     sphere(5);\n   }     \n   cylinder(15);         // 3\n   cube(8,true);         // 4\n}\n\nFurther module examples[edit | edit source]\n\nObjects\n\nmodule arrow(){\n    cylinder(10);\n    cube([4,.5,3],true);\n    cube([.5,4,3],true);\n    translate([0,0,10]) cylinder(4,2,0,true);\n}\n  \nmodule cannon(){\n    difference(){union()\n      {sphere(10);cylinder(40,10,8);} cylinder(41,4,4);\n} }\n  \nmodule base(){\n    difference(){\n      cube([40,30,20],true);\n      translate([0,0,5])  cube([50,20,15],true);\n} }\n\nOperators\n\nRotary Clusters\n\nmodule aim(elevation,azimuth=0)\n    { rotate([0,0,azimuth])\n      { rotate([0,90-elevation,0]) children(0);\n      children([1:1:$children-1]);   // step needed in case $children < 2\n} }\n   \naim(30,20)arrow();\naim(35,270)cannon();\naim(15){cannon();base();}\n\nmodule RotaryCluster(radius=30,number=8)\n    for (azimuth =[0:360/number:359])\n      rotate([0,0,azimuth])    \n        translate([radius,0,0]) { children();\n          translate([40,0,30]) text(str(azimuth)); }\n   \nRotaryCluster(200,7) color(\"lightgreen\") aim(15){cannon();base();}\nrotate([0,0,110]) RotaryCluster(100,4.5) aim(35)cannon();\ncolor(\"LightBlue\")aim(55,30){cannon();base();}\n\nRecursive modules[edit | edit source]\n\nLike functions, modules may contain recursive calls. However, there is no tail-recursion elimination for recursive modules.\n\nThe code below generates a crude model of a tree. Each tree branch is itself a modified version of the tree and produced by recursion. Be careful to keep the recursion depth (branching) n below 7 as the number of primitives and the preview time grow exponentially.\n\nA simple tree created with a recursive OpenSCAD module\n\nmodule simple_tree(size, dna, n) {   \n        if (n > 0) {\n            // trunk\n            cylinder(r1=size/10, r2=size/12, h=size, $fn=24);\n            // branches\n            translate([0,0,size])\n                for(bd = dna) {\n                    angx = bd[0];\n                    angz = bd[1];\n                    scal = bd[2];\n                        rotate([angx,0,angz])\n                            simple_tree(scal*size, dna, n-1);\n                }\n        }\n        else { // leaves\n            color(\"green\")\n            scale([1,1,3])\n                translate([0,0,size/6]) \n                    rotate([90,0,0]) \n                        cylinder(r=size/6,h=size/10);\n        }\n    }\n    // dna is a list of branching data bd of the tree:\n    //      bd[0] - inclination of the branch\n    //      bd[1] - Z rotation angle of the branch\n    //      bd[2] - relative scale of the branch\n    dna = [ [12,  80, 0.85], [55,    0, 0.6], \n            [62, 125, 0.6], [57, -125, 0.6] ];\n    simple_tree(50, dna, 5);\n\nAnother example of recursive module may be found in Tips and Tricks\n\nOverwriting built-in modules[edit | edit source]\n\nIt is possible to overwrite the built-in modules.\n\nA simple, but pointless example would be:\n\nmodule sphere(){\n    square();\n}\nsphere();\n\nNote that the built-in sphere module can not be called when over written.\n\nA more sensible way to use this language feature is to overwrite the 3D primitives with extruded 2D-primitives.\nThis allows additional to customize the default parameters and to add additional parameters.",
      "content": {},
      "codeExamples": [
        {
          "code": "function parabola(f,x) = ( 1/(4*f) ) * x*x; \nmodule plotParabola(f,wide,steps=1) {\n  function y(x) = parabola(f,x);\n  module plot(x,y) {\n    translate([x,y])\n      circle(1,$fn=12);\n  }\n  xAxis=[-wide/2:steps:wide/2];\n  for (x=xAxis) \n    plot(x, y(x));\n}\ncolor(\"red\")  plotParabola(10, 100, 5);\ncolor(\"blue\") plotParabola(4,  60,  2);",
          "context": "No specific context available"
        },
        {
          "code": "function name ( parameters ) = value ;",
          "context": "function definition"
        },
        {
          "code": "// example 1\n    \nfunction func0() = 5;\nfunction func1(x=3) = 2*x+1;\nfunction func2() = [1,2,3,4];\nfunction func3(y=7) = (y==7) ? 5 : 2 ;\nfunction func4(p0,p1,p2,p3) = [p0,p1,p2,p3];\n    \necho(func0());            // 5\na =   func1();            // 7\nb =   func1(5);           // 11\necho(func2());            // [1, 2, 3, 4]\necho(func3(2), func3());  // 2, 5\n   \nz = func4(func0(), func1(), func2(), func3());\n//  [5, 7, [1, 2, 3, 4], 5]\n   \ntranslate([0, -4*func0(), 0])\n  cube([func0(), 2*func0(), func0()]);\n// same as translate([0,-20,0]) cube([5,10,5]);",
          "context": "No specific context available"
        },
        {
          "code": "// example 2  creates for() range to give desired no of steps to cover range\n  \nfunction steps(start, no_steps, end) =\n  [start : (end-start)/(no_steps-1) : end];\n  \necho(steps(10, 3, 5));                // [10 : -2.5 : 5]\nfor (i = steps(10, 3, 5))  echo(i);   //  10 7.5 5\n  \necho(steps(10, 3, 15));               // [10 : 2.5 : 15]\nfor (i = steps(10, 3, 15)) echo(i);   // 10 12.5 15\n  \necho(steps(0, 5, 5));                // [0 : 1.25 : 5]\nfor (i = steps(0, 5, 5))   echo(i);  // 0 1.25 2.5 3.75 5",
          "context": "No specific context available"
        },
        {
          "code": "// example 3     rectangle with top pushed over, keeping same y\n  \nfunction rhomboid(x=1, y=1, angle=90)\n  = [[0,0],[x,0],\n    [x+x*cos(angle)/sin(angle),y],\n    [x*cos(angle)/sin(angle),y]];\n    \necho (v1); v1 = rhomboid(10,10,35);  // [[0, 0], \n                                     // [10, 0], \n                                     // [24.2815, 10],\n                                     // [14.2815, 10]]\npolygon(v1);\npolygon(rhomboid(10,10,35));         // alternate",
          "context": "No specific context available"
        },
        {
          "code": "//performing the same action with a module\n   \nmodule parallelogram(x=1,y=1,angle=90)\n    {polygon([[0,0],[x,0],\n              [x+x*cos(angle)/sin(angle),y],\n              [x*cos(angle)/sin(angle),y]]);};\n  \nparallelogram(10,10,35);",
          "context": "No specific context available"
        },
        {
          "code": "function get_square_triangle_perimeter(p1, p2) =\n  let (hypotenuse = sqrt(p1*p1+p2*p2))\n    p1 + p2 + hypotenuse;",
          "context": "No specific context available"
        },
        {
          "code": "// recursion example: add all integers up to n\nfunction add_up_to(n) = ( n==0 ? 0 : n + add_up_to(n-1) );",
          "context": "No specific context available"
        },
        {
          "code": "// tail-recursion elimination example: add all integers up to n\nfunction add_up_to(n, sum=0) =\n    n==0 ?\n        sum :\n        add_up_to(n-1, sum+n);\n \necho(sum=add_up_to(100000));\n// ECHO: sum = 5.00005e+009",
          "context": "No specific context available"
        },
        {
          "code": "function (x) x + x",
          "context": "function literal"
        },
        {
          "code": "func = function (x) x * x;\necho(func(5)); // ECHO: 25",
          "context": "Function literals can be assigned to variables and passed around like any value. Calling the function uses the normal function call syntax with parenthesis."
        },
        {
          "code": "a = 1;\nselector = function (which)\n             which == \"add\"\n             ? function (x) x + x + a\n             : function (x) x * x + a;\n             \necho(selector(\"add\"));     // ECHO: function(x) ((x + x) + a)\necho(selector(\"add\")(5));  // ECHO: 11\n\necho(selector(\"mul\"));     // ECHO: function(x) ((x * x) + a)\necho(selector(\"mul\")(5));  // ECHO: 26",
          "context": "It's possible to define functions that return functions. Unbound variables are captured by lexical scope."
        },
        {
          "code": "echo (sin(1));\nfunction sin(x) = true;\necho (sin(1));",
          "context": "No specific context available"
        },
        {
          "code": "Compiling design (CSG Tree generation)...\nECHO: true\nECHO: true\nCompiling design (CSG Products generation)...",
          "context": "No specific context available"
        },
        {
          "code": "module name ( parameters ) { actions }",
          "context": "module definition"
        },
        {
          "code": "name ( parameter values );",
          "context": "In use, object modules are actions ending with a semi-colon ';'."
        },
        {
          "code": "//example 1\n   \ntranslate([-30,-20,0])\n   ShowColorBars(Expense);\n   \nColorBreak=[[0,\"\"],\n           [20,\"lime\"],  // upper limit of color range\n           [40,\"greenyellow\"],\n           [60,\"yellow\"],\n           [75,\"LightCoral\"],\n           [200,\"red\"]];\nExpense=[16,20,25,85,52,63,45];\n   \nmodule ColorBar(value,period,range){  // 1 color on 1 bar\n   RangeHi = ColorBreak[range][0];\n   RangeLo = ColorBreak[range-1][0];\n   color( ColorBreak[range][1] ) \n   translate([10*period,0,RangeLo])\n      if (value > RangeHi)      cube([5,2,RangeHi-RangeLo]);\n      else if (value > RangeLo) cube([5,2,value-RangeLo]);\n  }  \nmodule ShowColorBars(values){\n    for (month = [0:len(values)-1], range = [1:len(ColorBreak)-1])\n      ColorBar(values[month],month,range);\n}",
          "context": "No specific context available"
        },
        {
          "code": "//example 2\nmodule house(roof=\"flat\",paint=[1,0,0]) {\n   color(paint)\n   if(roof==\"flat\") { translate([0,-1,0]) cube(); }\n   else if(roof==\"pitched\") {\n     rotate([90,0,0]) linear_extrude(height=1)\n     polygon(points=[[0,0],[0,1],[0.5,1.5],[1,1],[1,0]]); }\n   else if(roof==\"domical\") {\n     translate([0,-1,0]){\n       translate([0.5,0.5,1]) sphere(r=0.5,$fn=20); cube(); }\n} }\n\n                   house();\ntranslate([2,0,0]) house(\"pitched\");\ntranslate([4,0,0]) house(\"domical\",[0,1,0]);\ntranslate([6,0,0]) house(roof=\"pitched\",paint=[0,0,1]);\ntranslate([0,3,0]) house(paint=[0,0,0],roof=\"pitched\");\ntranslate([2,3,0]) house(roof=\"domical\");\ntranslate([4,3,0]) house(paint=[0,0.5,0.5]);",
          "context": "No specific context available"
        },
        {
          "code": "//example 3\n   \nelement_data = [[0,\"\",\"\",0],  // must be in order\n    [1,\"Hydrogen\",\"H\",1.008],   // indexed via atomic number\n    [2,\"Helium\",  \"He\",4.003]   // redundant atomic number to preserve your sanity later\n];\n   \nHydrogen = 1;\nHelium   = 2;\n      \nmodule coaster(atomic_number){\n    element     = element_data[atomic_number][1];\n    symbol      = element_data[atomic_number][2];\n    atomic_mass = element_data[atomic_number][3];\n    //rest of script\n}",
          "context": "No specific context available"
        },
        {
          "code": "name ( parameter values ){scope of operator}",
          "context": "Use of children() allows modules to act as operators applied to any or all of the objects within this module instantiation. \nIn use, operator modules do not end with a semi-colon."
        },
        {
          "code": "module myModification() { rotate([0,45,0]) children(); } \n \n myModification()                 // The modification\n {                                // Begin focus\n   cylinder(10,4,4);              // First child\n   cube([20,2,2], true);          // Second child\n }                                // End focus",
          "context": "Basicly the children() command is used to apply modifications to objects that are focused by a scope:"
        },
        {
          "code": "children();                         all children\n children(index);                    value or variable to select one child\n children([start : step : end]);     select from start to end incremented by step\n children([start : end]);            step defaults to 1 or -1\n children([vector]);                 selection of several children",
          "context": "Objects are indexed via integers from 0 to $children-1. OpenSCAD sets $children to the total number of objects within the scope.\nObjects grouped into a sub scope are treated as one child. \nSee example of separate children below and Scope of variables. Note that children(), echo() and empty block statements (including ifs) count as $children objects, even if no geometry is present (as of v2017.12.23)."
        },
        {
          "code": "//Use all children\n    \nmodule move(x=0,y=0,z=0,rx=0,ry=0,rz=0)\n{ translate([x,y,z])rotate([rx,ry,rz]) children(); }\n   \nmove(10)           cube(10,true);\nmove(-10)          cube(10,true);\nmove(z=7.07, ry=45)cube(10,true);\nmove(z=-7.07,ry=45)cube(10,true);",
          "context": "No specific context available"
        },
        {
          "code": "//Use only the first child, multiple times\n  \nmodule lineup(num, space) {\n   for (i = [0 : num-1])\n     translate([ space*i, 0, 0 ]) children(0);\n}\n\nlineup(5, 65){ sphere(30);cube(35);}",
          "context": "No specific context available"
        },
        {
          "code": "//Separate action for each child\n   \n  module SeparateChildren(space){\n    for ( i= [0:1:$children-1])   // step needed in case $children < 2  \n      translate([i*space,0,0]) {children(i);text(str(i));}\n  }\n   \n  SeparateChildren(-20){\n    cube(5);              // 0\n    sphere(5);            // 1\n    translate([0,20,0]){  // 2\n      cube(5);\n      sphere(5);\n    }     \n    cylinder(15);         // 3\n    cube(8,true);         // 4\n  }\n  translate([0,40,0])color(\"lightblue\")\n    SeparateChildren(20){cube(3,true);}",
          "context": "No specific context available"
        },
        {
          "code": "//Multiple ranges\nmodule MultiRange(){\n   color(\"lightblue\") children([0:1]);\n   color(\"lightgreen\")children([2:$children-2]);\n   color(\"lightpink\") children($children-1);\n}\n   \nMultiRange()\n{\n   cube(5);              // 0\n   sphere(5);            // 1\n   translate([0,20,0]){  // 2\n     cube(5);\n     sphere(5);\n   }     \n   cylinder(15);         // 3\n   cube(8,true);         // 4\n}",
          "context": "No specific context available"
        },
        {
          "code": "module arrow(){\n    cylinder(10);\n    cube([4,.5,3],true);\n    cube([.5,4,3],true);\n    translate([0,0,10]) cylinder(4,2,0,true);\n}\n  \nmodule cannon(){\n    difference(){union()\n      {sphere(10);cylinder(40,10,8);} cylinder(41,4,4);\n} }\n  \nmodule base(){\n    difference(){\n      cube([40,30,20],true);\n      translate([0,0,5])  cube([50,20,15],true);\n} }",
          "context": "No specific context available"
        },
        {
          "code": "module aim(elevation,azimuth=0)\n    { rotate([0,0,azimuth])\n      { rotate([0,90-elevation,0]) children(0);\n      children([1:1:$children-1]);   // step needed in case $children < 2\n} }\n   \naim(30,20)arrow();\naim(35,270)cannon();\naim(15){cannon();base();}\n\nmodule RotaryCluster(radius=30,number=8)\n    for (azimuth =[0:360/number:359])\n      rotate([0,0,azimuth])    \n        translate([radius,0,0]) { children();\n          translate([40,0,30]) text(str(azimuth)); }\n   \nRotaryCluster(200,7) color(\"lightgreen\") aim(15){cannon();base();}\nrotate([0,0,110]) RotaryCluster(100,4.5) aim(35)cannon();\ncolor(\"LightBlue\")aim(55,30){cannon();base();}",
          "context": "No specific context available"
        },
        {
          "code": "module simple_tree(size, dna, n) {   \n        if (n > 0) {\n            // trunk\n            cylinder(r1=size/10, r2=size/12, h=size, $fn=24);\n            // branches\n            translate([0,0,size])\n                for(bd = dna) {\n                    angx = bd[0];\n                    angz = bd[1];\n                    scal = bd[2];\n                        rotate([angx,0,angz])\n                            simple_tree(scal*size, dna, n-1);\n                }\n        }\n        else { // leaves\n            color(\"green\")\n            scale([1,1,3])\n                translate([0,0,size/6]) \n                    rotate([90,0,0]) \n                        cylinder(r=size/6,h=size/10);\n        }\n    }\n    // dna is a list of branching data bd of the tree:\n    //      bd[0] - inclination of the branch\n    //      bd[1] - Z rotation angle of the branch\n    //      bd[2] - relative scale of the branch\n    dna = [ [12,  80, 0.85], [55,    0, 0.6], \n            [62, 125, 0.6], [57, -125, 0.6] ];\n    simple_tree(50, dna, 5);",
          "context": "No specific context available"
        },
        {
          "code": "module sphere(){\n    square();\n}\nsphere();",
          "context": "No specific context available"
        }
      ]
    },
    "listComprehensions": {
      "title": "List Comprehensions",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/List_Comprehensions",
      "introduction": "[Note: Requires version 2015.03]\n\nBasic Syntax[edit | edit source]\n\nThe list comprehensions provide a flexible way to generate lists using the general syntax\n\n[ list-definition expression ]\n\nThe following elements are supported to construct the list definition\n\nfor (i = sequence)\nIteration over a range or an existing list\nfor (init;condition;next)\nSimple recursive call represented as C-style for\neach\nTakes a sequence value as argument, and adds each element to the list being constructed. each x is equivalent to  `for (i = x) i`\nif (condition)\nSelection criteria, when true the expression is calculated and added to the result list\nlet (x = value)\nLocal variable assignment\n\nmultiple generator expressions[edit | edit source]\n\n[Note: Requires version 2019.05]\n\nThe list comprehension syntax is generalized to allow multiple expressions. This allows to easily construct lists from multiple sub lists generated by different list comprehension expressions avoiding concat.\n\nsteps = 50;\n\npoints = [\n\t// first expression generating the points in the positive Y quadrant\n\tfor (a = [0 : steps]) [ a, 10 * sin(a * 360 / steps) + 10 ],\n\t// second expression generating the points in the negative Y quadrant\n\tfor (a = [steps : -1 : 0]) [ a, 10 * cos(a * 360 / steps) - 20 ],\n\t// additional list of fixed points\n\t[ 10, -3 ], [ 3, 0 ], [ 10, 3 ]\n];\n\npolygon(points);\n\nfor[edit | edit source]\n\nThe for element defines the input values for the list generation. The syntax is the same as used by the for iterator. The sequence to the right of the equals sign can be any list. The for element iterates over all the members of the list. The variable on the left of the equals sign take on the value of each member of the sequence in turn. This value can then be processed in the child of the for element, and each result becomes a member of the final list that is produced.\n\nIf the sequence has more than one dimension, for iterates over the first dimension only. Deeper dimensions can be accessed by nesting for elements.\n\nSeveral common usage patterns are presented here.\n\n[ for (i = [start : step : end]) i ]\nGenerate output based on a range definition, this version is mainly useful to calculate list values or access existing lists using the range value as index.\n\nExamples\n\n// generate a list with all values defined by a range\nlist1 = [ for (i = [0 : 2 : 10]) i ];\necho(list1); // ECHO: [0, 2, 4, 6, 8, 10]\n\n// extract every second character of a string\nstr = \"SomeText\";\nlist2 = [ for (i = [0 : 2 : len(str) - 1]) str[i] ];\necho(list2); // ECHO: [\"S\", \"m\", \"T\", \"x\"]\n\n// indexed list access, using function to map input values to output values\nfunction func(x) = x < 1 ? 0 : x + func(x - 1);\ninput = [1, 3, 5, 8];\noutput = [for (a = [ 0 : len(input) - 1 ]) func(input[a]) ];\necho(output); // ECHO: [1, 6, 15, 36]\n\n[ for (i = [a, b, c, ...]) i ]\nUse list parameter as input, this version can be used to map input values to calculated output values.\n\nExamples\n\n// iterate over an existing list\nfriends = [\"John\", \"Mary\", \"Alice\", \"Bob\"];\nlist = [ for (i = friends) len(i)];\necho(list); // ECHO: [4, 4, 5, 3]\n\n// map input list to output list\nlist = [ for (i = [2, 3, 5, 7, 11]) i * i ];\necho(list); // ECHO: [4, 9, 25, 49, 121]\n\n// calculate Fibonacci numbers\nfunction func(x) = x < 3 ? 1 : func(x - 1) + func(x - 2);\ninput = [7, 10, 12];\noutput = [for (a = input) func(a) ];\necho(output); // ECHO: [13, 55, 144]\n\n[ for (c = \"String\") c ]\nGenerate output based on a string, this iterates over each character of the string.\n\n[Note: Requires version 2019.05]\n\nExamples\n\necho([ for (c = \"String\") c ]);\n// ECHO: [\"S\", \"t\", \"r\", \"i\", \"n\", \"g\"]\n\n[ for (a = inita, b = initb, ...;condition;a = nexta, b = nextb, ...) expr ]\nGenerator for expressing simple recursive call in a c-style for loop.\n\n[Note: Requires version 2019.05]\n\nThe recursive equivalent of this generator is\n\nfunction f(a, b, ...) =\n    condition\n    ? concat([expr], f(nexta, nextb, ...))\n    : [];\n  f(inita, initb, ...)\n\nExamples\n\necho( [for (a = 0, b = 1;a < 5;a = a + 1, b = b + 2) [ a, b * b ] ] );\n// ECHO: [[0, 1], [1, 9], [2, 25], [3, 49], [4, 81]]\n\n// Generate fibonacci sequence\necho([for (a = 0, b = 1;a < 1000;x = a + b, a = b, b = x) a]);\n// ECHO: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]\n\n// Cumulative sum of values in v\nfunction cumsum(v) = [for (a = v[0]-v[0], i = 0; i < len(v); a = a+v[i], i = i+1) a+v[i]];\necho(cumsum([1, 2, 3, 4]));\n// ECHO: [1, 3, 6, 10]\necho(cumsum([[1, 1], [2, 2], [3, 3]]));\n// ECHO: [[1, 1], [3, 3], [6, 6]]\n\neach[edit | edit source]\n\n[Note: Requires version 2019.05]\n\neach embeds the values of a list given as argument directly, effectively unwrapping the argument list.\n\n// Without using \"each\", a nested list is generated\necho([ for (a = [1 : 4]) [a, a * a] ]);\n// ECHO: [[1, 1], [2, 4], [3, 9], [4, 16]]\n\n// Adding \"each\" unwraps the inner list, producing a flat list as result\necho([ for (a = [1 : 4]) each [a, a * a] ]);\n// ECHO: [1, 1, 2, 4, 3, 9, 4, 16]\n\neach unwraps ranges and helps to build more general for lists when combined with multiple generator expressions.\n\nA = [-2, each [1:2:5], each [6:-2:0], -1];\necho(A);\n// ECHO: [-2, 1, 3, 5, 6, 4, 2, 0, -1]\necho([ for (a = A) 2 * a ]);\n// ECHO: [-4, 2, 6, 10, 12, 8, 4, 0, -2]\n\nif[edit | edit source]\n\nThe if element allows selection if the expression should be allocated and added to the result list or not. In the simplest case this allows filtering of an list.\n\n[ for (i = list) if (condition(i)) i ]\nWhen the evaluation of the condition returns true, the expression i is added to the result list.\n\nExample\n\nlist = [ for (a = [ 1 : 8 ]) if (a % 2 == 0) a ];\necho(list); // ECHO: [2, 4, 6, 8]\n\nNote that the if element cannot be inside an expression, it should be at the top.\n\nExample\n\n// from the input list include all positive odd numbers\n// and also all even number divided by 2\n\nlist = [-10:5];\necho([for(n=list) if(n%2==0 || n>=0) n%2==0 ? n/2 : n ]); \n// ECHO: [-5, -4, -3, -2, -1, 0, 1, 1, 3, 2, 5]\n// echo([for(n=list) n%2==0 ? n/2 : if(n>=0) n ]); // this would generate a syntactical error\n\nif/else[edit | edit source]\n\n[Note: Requires version 2019.05]\n\nThe if-else construct is equivalent to the conditional expression ?: except that it can be combined with filter if.\n\n[ for (i = list) if (condition(i)) x else y ]\nWhen the evaluation of the condition returns true, the expression x is added to the result list else the expression y.\n\n// even numbers are halved, positive odd numbers are preserved, negative odd numbers are eliminated\necho([for (a = [-3:5]) if (a % 2 == 0) [a, a/2] else if (a > 0) [a, a] ]);\n// ECHO: [[-2, -1], [0, 0], [1, 1], [2, 1], [3, 3], [4, 2], [5, 5]];\n\nNote that in the expression above the conditional operator could not substitute if-else. It is possible to express this same filter with the conditional operator but with a more cryptic logic:\n\n// even numbers are halved, positive odd numbers are preserved, negative odd numbers are eliminated\necho([for (a = [-3:5]) if (a % 2 == 0 || (a % 2 != 0 && a > 0)) a % 2 == 0 ? [a, a / 2] : [a, a] ]);\n// ECHO: [[-2, -1], [0, 0], [1, 1], [2, 1], [3, 3], [4, 2], [5, 5]];\n\nTo bind an else expression to a specific if, it's possible to use parenthesis.\n\n// even numbers are dropped, multiples of 4 are substituted by -1 \necho([for(i=[0:10]) if(i%2==0) (if(i%4==0) -1 ) else i]);\n// ECHO: [-1, 1, 3, -1, 5, 7, -1, 9]\n\n// odd numbers are dropped, multiples of 4 are substituted by -1 \necho([for(i=[0:10]) if(i%2==0) if(i%4==0) -1 else i]);\n// ECHO: [-1, 2, -1, 6, -1, 10]\n\nlet[edit | edit source]\n\nThe let element allows sequential assignment of variables inside a list comprehension definition.\n\n[ for (i = list) let (assignments) a ]\n\nExample\n\nlist = [ for (a = [ 1 : 4 ]) let (b = a*a, c = 2 * b) [ a, b, c ] ];\necho(list); // ECHO: [[1, 1, 2], [2, 4, 8], [3, 9, 18], [4, 16, 32]]\n\nNested loops[edit | edit source]\n\nThere are different ways to define nested loops. Defining multiple loop variables inside one for element and multiple for elements produce both flat result lists. To generate nested result lists an additional [ ] markup is required.\n\n// nested loop using multiple variables\nflat_result1 = [ for (a = [ 0 : 2 ], b = [ 0 : 2 ]) a == b ? 1 : 0 ];\necho(flat_result1); // ECHO: [1, 0, 0, 0, 1, 0, 0, 0, 1]\n\n// nested loop using multiple for elements\nflat_result2 = [ for (a = [ 0 : 2 ]) for (b = [0 : 2])  a == b ? 1 : 0 ];\necho(flat_result2); // ECHO: [1, 0, 0, 0, 1, 0, 0, 0, 1]\n\n// nested loop to generate a bi-dimensional matrix\nidentity_matrix = [ for (a = [ 0 : 2 ]) [ for (b = [ 0 : 2 ]) a == b ? 1 : 0 ] ];\necho(identity_matrix); // ECHO: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n\nAdvanced Examples[edit | edit source]\n\nThis chapter lists some advanced examples, useful idioms and use-cases for the list comprehension syntax.\n\nGenerating vertices for a polygon[edit | edit source]\n\nResult\n\nUsing list comprehension, a parametric equation can be calculated at a number of points to approximate many curves, such as the following example for an ellipse (using polygon()):\n\nsma = 20;  // semi-minor axis\nsmb = 30;  // semi-major axis\n\npolygon(\n    [ for (a = [0 : 5 : 359]) [ sma * sin(a), smb * cos(a) ] ]\n);\n\nFlattening a nested vector[edit | edit source]\n\nList comprehension can be used in a user-defined function to perform tasks on or for vectors.  Here is a user-defined function that flattens a nested vector.\n\n// input : nested list\n// output : list with the outer level nesting removed\nfunction flatten(l) = [ for (a = l) for (b = a) b ] ;\n\nnested_list = [ [ 1, 2, 3 ], [ 4, 5, 6 ] ];\necho(flatten(nested_list)); // ECHO: [1, 2, 3, 4, 5, 6]\n\nSorting a vector[edit | edit source]\n\nEven a complicated algorithm Quicksort becomes doable with for(), if(), let() and recursion:\n\n// input : list of numbers\n// output : sorted list of numbers\nfunction quicksort(arr) = !(len(arr)>0) ? [] : let(\n    pivot   = arr[floor(len(arr)/2)],\n    lesser  = [ for (y = arr) if (y  < pivot) y ],\n    equal   = [ for (y = arr) if (y == pivot) y ],\n    greater = [ for (y = arr) if (y  > pivot) y ]\n) concat(\n    quicksort(lesser), equal, quicksort(greater)\n);\n\n// use seed in rands() to get reproducible results\nunsorted = [for (a = rands(0, 10, 6, 3)) ceil(a)];\necho(unsorted); // ECHO: [6, 1, 8, 9, 3, 2]\necho(quicksort(unsorted)); // ECHO: [1, 2, 3, 6, 8, 9]\n\nSelecting elements of a vector[edit | edit source]\n\nselect() performs selection and reordering of elements into a new vector.\n\nfunction select(vector, indices) = [ for (index = indices) vector[index] ];\n   \nvector1 =   [[0,0],[1,1],[2,2],[3,3],[4,4]];\nselector1 = [4,0,3];\nvector2 =   select(vector1,selector1);    // [[4, 4], [0, 0], [3, 3]]\nvector3 =   select(vector1,[0,2,4,4,2,0]);// [[0, 0], [2, 2], [4, 4],[4, 4], [2, 2], [0, 0]]\n// range also works as indices\nvector4 =   select(vector1, [4:-1:0]);    // [[4, 4], [3, 3], [2, 2], [1, 1], [0, 0]]\n\nConcatenating two vectors[edit | edit source]\n\nUsing indices:\n\nfunction cat(L1, L2) = [for (i=[0:len(L1)+len(L2)-1]) \n                        i < len(L1)? L1[i] : L2[i-len(L1)]] ;\n\necho(cat([1,2,3],[4,5])); //concatenates two OpenSCAD lists [1,2,3] and [4,5], giving [1, 2, 3, 4, 5]\n\nWithout using indices:\n\nfunction cat(L1, L2) = [for(L=[L1, L2], a=L) a];\n\necho(cat([1,2,3],[4,5])); //concatenates two OpenSCAD lists [1,2,3] and [4,5], giving [1, 2, 3, 4, 5]",
      "content": {},
      "codeExamples": [
        {
          "code": "[ list-definition expression ]",
          "context": "The list comprehensions provide a flexible way to generate lists using the general syntax"
        },
        {
          "code": "steps = 50;\n\npoints = [\n\t// first expression generating the points in the positive Y quadrant\n\tfor (a = [0 : steps]) [ a, 10 * sin(a * 360 / steps) + 10 ],\n\t// second expression generating the points in the negative Y quadrant\n\tfor (a = [steps : -1 : 0]) [ a, 10 * cos(a * 360 / steps) - 20 ],\n\t// additional list of fixed points\n\t[ 10, -3 ], [ 3, 0 ], [ 10, 3 ]\n];\n\npolygon(points);",
          "context": "No specific context available"
        },
        {
          "code": "// generate a list with all values defined by a range\nlist1 = [ for (i = [0 : 2 : 10]) i ];\necho(list1); // ECHO: [0, 2, 4, 6, 8, 10]",
          "context": "No specific context available"
        },
        {
          "code": "// extract every second character of a string\nstr = \"SomeText\";\nlist2 = [ for (i = [0 : 2 : len(str) - 1]) str[i] ];\necho(list2); // ECHO: [\"S\", \"m\", \"T\", \"x\"]",
          "context": "No specific context available"
        },
        {
          "code": "// indexed list access, using function to map input values to output values\nfunction func(x) = x < 1 ? 0 : x + func(x - 1);\ninput = [1, 3, 5, 8];\noutput = [for (a = [ 0 : len(input) - 1 ]) func(input[a]) ];\necho(output); // ECHO: [1, 6, 15, 36]",
          "context": "No specific context available"
        },
        {
          "code": "// iterate over an existing list\nfriends = [\"John\", \"Mary\", \"Alice\", \"Bob\"];\nlist = [ for (i = friends) len(i)];\necho(list); // ECHO: [4, 4, 5, 3]",
          "context": "No specific context available"
        },
        {
          "code": "// map input list to output list\nlist = [ for (i = [2, 3, 5, 7, 11]) i * i ];\necho(list); // ECHO: [4, 9, 25, 49, 121]",
          "context": "No specific context available"
        },
        {
          "code": "// calculate Fibonacci numbers\nfunction func(x) = x < 3 ? 1 : func(x - 1) + func(x - 2);\ninput = [7, 10, 12];\noutput = [for (a = input) func(a) ];\necho(output); // ECHO: [13, 55, 144]",
          "context": "No specific context available"
        },
        {
          "code": "echo([ for (c = \"String\") c ]);\n// ECHO: [\"S\", \"t\", \"r\", \"i\", \"n\", \"g\"]",
          "context": "No specific context available"
        },
        {
          "code": "function f(a, b, ...) =\n    condition\n    ? concat([expr], f(nexta, nextb, ...))\n    : [];\n  f(inita, initb, ...)",
          "context": "The recursive equivalent of this generator is"
        },
        {
          "code": "echo( [for (a = 0, b = 1;a < 5;a = a + 1, b = b + 2) [ a, b * b ] ] );\n// ECHO: [[0, 1], [1, 9], [2, 25], [3, 49], [4, 81]]\n\n// Generate fibonacci sequence\necho([for (a = 0, b = 1;a < 1000;x = a + b, a = b, b = x) a]);\n// ECHO: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]\n\n// Cumulative sum of values in v\nfunction cumsum(v) = [for (a = v[0]-v[0], i = 0; i < len(v); a = a+v[i], i = i+1) a+v[i]];\necho(cumsum([1, 2, 3, 4]));\n// ECHO: [1, 3, 6, 10]\necho(cumsum([[1, 1], [2, 2], [3, 3]]));\n// ECHO: [[1, 1], [3, 3], [6, 6]]",
          "context": "No specific context available"
        },
        {
          "code": "// Without using \"each\", a nested list is generated\necho([ for (a = [1 : 4]) [a, a * a] ]);\n// ECHO: [[1, 1], [2, 4], [3, 9], [4, 16]]\n\n// Adding \"each\" unwraps the inner list, producing a flat list as result\necho([ for (a = [1 : 4]) each [a, a * a] ]);\n// ECHO: [1, 1, 2, 4, 3, 9, 4, 16]",
          "context": "No specific context available"
        },
        {
          "code": "A = [-2, each [1:2:5], each [6:-2:0], -1];\necho(A);\n// ECHO: [-2, 1, 3, 5, 6, 4, 2, 0, -1]\necho([ for (a = A) 2 * a ]);\n// ECHO: [-4, 2, 6, 10, 12, 8, 4, 0, -2]",
          "context": "No specific context available"
        },
        {
          "code": "list = [ for (a = [ 1 : 8 ]) if (a % 2 == 0) a ];\necho(list); // ECHO: [2, 4, 6, 8]",
          "context": "No specific context available"
        },
        {
          "code": "// from the input list include all positive odd numbers\n// and also all even number divided by 2\n\nlist = [-10:5];\necho([for(n=list) if(n%2==0 || n>=0) n%2==0 ? n/2 : n ]); \n// ECHO: [-5, -4, -3, -2, -1, 0, 1, 1, 3, 2, 5]\n// echo([for(n=list) n%2==0 ? n/2 : if(n>=0) n ]); // this would generate a syntactical error",
          "context": "No specific context available"
        },
        {
          "code": "// even numbers are halved, positive odd numbers are preserved, negative odd numbers are eliminated\necho([for (a = [-3:5]) if (a % 2 == 0) [a, a/2] else if (a > 0) [a, a] ]);\n// ECHO: [[-2, -1], [0, 0], [1, 1], [2, 1], [3, 3], [4, 2], [5, 5]];",
          "context": "No specific context available"
        },
        {
          "code": "// even numbers are halved, positive odd numbers are preserved, negative odd numbers are eliminated\necho([for (a = [-3:5]) if (a % 2 == 0 || (a % 2 != 0 && a > 0)) a % 2 == 0 ? [a, a / 2] : [a, a] ]);\n// ECHO: [[-2, -1], [0, 0], [1, 1], [2, 1], [3, 3], [4, 2], [5, 5]];",
          "context": "No specific context available"
        },
        {
          "code": "// even numbers are dropped, multiples of 4 are substituted by -1 \necho([for(i=[0:10]) if(i%2==0) (if(i%4==0) -1 ) else i]);\n// ECHO: [-1, 1, 3, -1, 5, 7, -1, 9]\n\n// odd numbers are dropped, multiples of 4 are substituted by -1 \necho([for(i=[0:10]) if(i%2==0) if(i%4==0) -1 else i]);\n// ECHO: [-1, 2, -1, 6, -1, 10]",
          "context": "No specific context available"
        },
        {
          "code": "list = [ for (a = [ 1 : 4 ]) let (b = a*a, c = 2 * b) [ a, b, c ] ];\necho(list); // ECHO: [[1, 1, 2], [2, 4, 8], [3, 9, 18], [4, 16, 32]]",
          "context": "No specific context available"
        },
        {
          "code": "// nested loop using multiple variables\nflat_result1 = [ for (a = [ 0 : 2 ], b = [ 0 : 2 ]) a == b ? 1 : 0 ];\necho(flat_result1); // ECHO: [1, 0, 0, 0, 1, 0, 0, 0, 1]",
          "context": "No specific context available"
        },
        {
          "code": "// nested loop using multiple for elements\nflat_result2 = [ for (a = [ 0 : 2 ]) for (b = [0 : 2])  a == b ? 1 : 0 ];\necho(flat_result2); // ECHO: [1, 0, 0, 0, 1, 0, 0, 0, 1]",
          "context": "No specific context available"
        },
        {
          "code": "// nested loop to generate a bi-dimensional matrix\nidentity_matrix = [ for (a = [ 0 : 2 ]) [ for (b = [ 0 : 2 ]) a == b ? 1 : 0 ] ];\necho(identity_matrix); // ECHO: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]",
          "context": "No specific context available"
        },
        {
          "code": "sma = 20;  // semi-minor axis\nsmb = 30;  // semi-major axis\n\npolygon(\n    [ for (a = [0 : 5 : 359]) [ sma * sin(a), smb * cos(a) ] ]\n);",
          "context": "No specific context available"
        },
        {
          "code": "// input : nested list\n// output : list with the outer level nesting removed\nfunction flatten(l) = [ for (a = l) for (b = a) b ] ;\n\nnested_list = [ [ 1, 2, 3 ], [ 4, 5, 6 ] ];\necho(flatten(nested_list)); // ECHO: [1, 2, 3, 4, 5, 6]",
          "context": "No specific context available"
        },
        {
          "code": "// input : list of numbers\n// output : sorted list of numbers\nfunction quicksort(arr) = !(len(arr)>0) ? [] : let(\n    pivot   = arr[floor(len(arr)/2)],\n    lesser  = [ for (y = arr) if (y  < pivot) y ],\n    equal   = [ for (y = arr) if (y == pivot) y ],\n    greater = [ for (y = arr) if (y  > pivot) y ]\n) concat(\n    quicksort(lesser), equal, quicksort(greater)\n);\n\n// use seed in rands() to get reproducible results\nunsorted = [for (a = rands(0, 10, 6, 3)) ceil(a)];\necho(unsorted); // ECHO: [6, 1, 8, 9, 3, 2]\necho(quicksort(unsorted)); // ECHO: [1, 2, 3, 6, 8, 9]",
          "context": "No specific context available"
        },
        {
          "code": "function select(vector, indices) = [ for (index = indices) vector[index] ];\n   \nvector1 =   [[0,0],[1,1],[2,2],[3,3],[4,4]];\nselector1 = [4,0,3];\nvector2 =   select(vector1,selector1);    // [[4, 4], [0, 0], [3, 3]]\nvector3 =   select(vector1,[0,2,4,4,2,0]);// [[0, 0], [2, 2], [4, 4],[4, 4], [2, 2], [0, 0]]\n// range also works as indices\nvector4 =   select(vector1, [4:-1:0]);    // [[4, 4], [3, 3], [2, 2], [1, 1], [0, 0]]",
          "context": "No specific context available"
        },
        {
          "code": "function cat(L1, L2) = [for (i=[0:len(L1)+len(L2)-1]) \n                        i < len(L1)? L1[i] : L2[i-len(L1)]] ;\n\necho(cat([1,2,3],[4,5])); //concatenates two OpenSCAD lists [1,2,3] and [4,5], giving [1, 2, 3, 4, 5]",
          "context": "No specific context available"
        },
        {
          "code": "function cat(L1, L2) = [for(L=[L1, L2], a=L) a];\n\necho(cat([1,2,3],[4,5])); //concatenates two OpenSCAD lists [1,2,3] and [4,5], giving [1, 2, 3, 4, 5]",
          "context": "No specific context available"
        }
      ]
    },
    "otherLanguageFeatures": {
      "title": "Other Language Features",
      "url": "https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/Other_Language_Features",
      "introduction": "Special variables[edit | edit source]\n\nSpecial variables provide an alternate means of passing arguments to modules and functions.\nAll user, or OpenSCAD, defined variables starting with a '$' are special variables, similar to special variables in lisp.\nModules and function see all outside variables in addition to those passed as arguments or defined internally.\n\nCurrently valid special variable names can only be composed of $ followed by simple characters and underscores [a-zA-Z0-9_] and do not allow high-ascii or unicode characters.\n\nThe value for a regular variable is assigned at compile time and is thus static for all calls.\n\nSpecial variables pass along their value from within the scope \n (see scope of variables)\nfrom which the module or function is called. \nThis means that special variables can potentially have a different value each time a module or function is called.\n\nregular  = \"regular global\";\n$special = \"special global\";\nmodule show() echo(\"         in show    \", regular,\"   \", $special );\n\necho (\"         outside    \", regular,\"   \", $special );\n          // ECHO: \"         outside    \", \"regular global\", \"   \", \"special global\"\n  \nfor ( regular = [0:1] ){ echo(\"in regular loop     \", regular,\"   \", $special ); show();}\n          // ECHO: \"in regular loop     \", 0, \"   \", \"special global\"\n          // ECHO: \"         in show    \", \"regular global\", \"   \", \"special global\"\n          // ECHO: \"in regular loop     \", 1, \"   \", \"special global\"\n          // ECHO: \"         in show    \", \"regular global\", \"   \", \"special global\"\n\nfor ( $special = [5:6] ){ echo(\"in special loop     \", regular,\"   \", $special ); show();}\n          // ECHO: \"in special loop     \", \"regular global\", \"   \", 5\n          // ECHO: \"         in show    \", \"regular global\", \"   \", 5\n          // ECHO: \"in special loop     \", \"regular global\", \"   \", 6\n          // ECHO: \"         in show    \", \"regular global\", \"   \", 6\n\nshow();\n          // ECHO: \"         in show    \", \"regular global\", \"   \", \"special global\"\n\nThis is useful when multiple arguments need to be passed thru several layers of module calls.\n\nSeveral special variables are already defined by OpenSCAD.\n\nCircle resolution:  $fa, $fs, and $fn [edit | edit source]\n\nThe $fa, $fs, and $fn special variables control the number of facets used to\ngenerate an arc:\n\n$fa is the minimum angle for a fragment. Even a huge circle does not have\nmore fragments than 360 divided by this number. The default value is 12 (i.e. 30 fragments\nfor a full circle). The minimum allowed value is 0.01. Attempting to set a lower value causes a warning.\n\n$fs is the minimum size of a fragment. The\ndefault value is 2 so very small circles have a smaller number of fragments than specified using $fa. The minimum allowed value is 0.01. Attempting to set a lower value causes a warning.\n\n$fn is number of fragments and usually has the default value of 0. When this variable has a value greater than zero, the\nother two variables are ignored, and a full circle is rendered using this\nnumber of fragments.\n\nThe higher the number of fragments, the more memory and CPU consumed; large values can bring many systems to their knees. Depending on the design, $fn values, and the corresponding results of $fa & $fs,  should be kept small, at least until the design is finalised when it can be increased for the final result. A $fn over 128 is not recommended or only for specific circumstances, and below 50 would be advisable for performance.\n\nYou can also use two different values for preview and render\n\n$fn = $preview ? 32 : 64;\n\nTIP: If you want to create a circle/cylinder/sphere which has an axis\naligned integer bounding box (i.e. a bounding box that has\nintegral dimensions, and an integral position) use a value of $fn that\nis divisible by 4. The circular shape appears as a faceted polygon that is inscribed within the radius or diameter provided.\n\nWhen $fa and $fs are used to determine the number of fragments for a\ncircle, then OpenSCAD never uses fewer than 5 fragments.\n\nThis is the C code that calculates the number of fragments in a circle:\n\nint get_fragments_from_r(double r, double fn, double fs, double fa)\n      {\n             if (r < GRID_FINE) return 3;\n             if (fn > 0.0) return (int)(fn >= 3 ? fn : 3);\n             return (int)ceil(fmax(fmin(360.0 / fa, r*2*M_PI / fs), 5));\n      }\n\nOr you can embed this OpenSCAD version in your code to work out what's going on, you need to set r= to your size\n\necho(n=($fn>0?($fn>=3?$fn:3):ceil(max(min(360/$fa,r*2*PI/$fs),5))),a_based=360/$fa,s_based=r*2*PI/$fs);\n\nSpheres are first sliced into as many slices as the number of fragments being used\nto render a circle of the sphere's radius, and then every slice is rendered\ninto as many fragments as are needed for the slice radius. You might have\nrecognized already that the pole of a sphere is usually a pentagon. This is\nwhy.\n\nThe number of fragments for a cylinder is determined using the greater of\nthe two radii.\n\nThe method is also used when rendering circles and arcs from DXF files. The\nvariables have no effect when importing STL files.\n\nYou can generate high resolution spheres by resetting the $fX values in\nthe instantiating module:\n\n$fs = 0.01;\n      sphere(2);\n\nor simply by passing the special variable as parameter:\n\nsphere(2, $fs = 0.01);\n\nYou can even scale the special variable instead of resetting it:\n\nsphere(2, $fs = $fs * 0.01);\n\nAnimation: $t [edit | edit source]\n\nSimple harmonic motion, 20 FPS, 100 steps\n\nAnimated gears 17T and 31T\n\nThe $t variable is used in \"rotate\" and \"translate\" for animation, $t*360 giving complete cycles. To start animation, select Window\\Animate and enter values for \"FPS\" and \"Steps\". The \"Time\" field shows the current value of $t as a decimal fraction.\n\nThe value of $t will repeat from 0 through (1 - 1/Steps). It never reaches 1 because this would produce a \"hitch\" in the animation if using it for rotation -- two consecutive frames would be at the same angle.\n\nThere is no variable to distinguish between the cases of animation running at the first frame ($t=0) and animation not running, so make $t=0 your rest position for the model.\n\nSimple harmonic motion[edit | edit source]\n\ntranslate ([0, 0, 10*sin($t*360)])\n\nsphere(2);\n\ngives a sphere that oscillates between -10 and +10 on the Z-axis.\n\nRotation[edit | edit source]\n\nrotate ([0, 0, $t*360])\n\nsquare(5);\n\nrotates a square around one corner around the Z-axis. To rotate the square about its middle, use:\n\nrotate ([0, 0, $t*360])\n\nsquare(5, center=true);\n\nPart-rotation[edit | edit source]\n\nAll parts in an animation complete one cycle of motion in the same time, $t, jump back to zero, and start again. However, the cycles can be given different numbers of steps, to give the illusion of different speeds in the same animation. This can be used to animate meshing gears of different sizes.\n\nrotate([0, 0, $t*360/17])\n\ngear(teeth=17);\n\nand\n\nrotate([0, 0, -$t*360/31])\n\ngear(teeth=31);\n\nCircular orbit[edit | edit source]\n\nrotate ([0, 0, $t*360])\n\ntranslate ([10, 0])\n\nsquare(5, center=true);\n\nCircular orbit without rotation[edit | edit source]\n\nrotate ([0, 0, $t*360])\n\ntranslate ([9, 0])\n\nElliptical orbit\n\nrotate ([0, 0, -$t*360])\n\nsquare(5, center=true);\n\nElliptical orbit[edit | edit source]\n\ntranslate([10*sin($t*360), 20*cos($t*360)])\n\nsquare(2, center=true);\n\nNote that with \"translate\", the object does not rotate.\n\nElliptical motion[edit | edit source]\n\nElliptical motion\n\ne=10;\n\nrotate([0, 0, $t*360])\n\ntranslate([e, 0])\n\nrotate([0, 0, -$t*720])\n\nsquare([2*e, 2], center=true);\n\nIf \"Dump Pictures\" is checked, then images are created in the same directory as the .scad file. The exported PNG files can be turned into a gif via command line:\n\nconvert -delay 10 -loop 0 *.png myimage.gif\n\nwhere -delay 10 is the duration of each frame in milliseconds, and -loop 0 specifies the number of loops (0 = loop forever).\n\nThe Linux convert command is part of ImageMagick, which can also be installed on macOS and Windows. Additional parameters are possible for cropping and scaling.\n\nViewport:  $vpr, $vpt, $vpf and $vpd [edit | edit source]\n\nThese contain the current viewport rotation and translation and camera distance - at the time of doing the rendering. Moving the viewport does not update them. During an animation they are updated for each frame.\n\n$vpr shows rotation\n$vpt shows translation (i.e. won't be affected by rotate and zoom)\n$vpf shows the FOV (Field of View) of the view [Note: Requires version 2021.01]\n$vpd shows the camera distance [Note: Requires version 2015.03]\n\nExample\n\ncube([10, 10, $vpr[0] / 10]);\n\nwhich makes the cube change size based on the view angle, if an animation loop is active (which does not need to use the $t variable)\n\nYou can also make bits of a complex model vanish as you change the view.\n\nAll four variables are writable, but only assignments at the top-level of the main file has an effect on the viewport. [Note: Requires version 2015.03]\n\nExample\n\n$vpr = [0, 0, $t * 360];\n\nwhich allows a simple 360 degree rotation around the Z axis in animation mode.\n\nThe menu command Edit - Paste Viewport Rotation/Translation copies the current value of the viewport, but not the current $vpr or $vpt.\n\nExecution mode:  $preview [edit | edit source]\n\n[Note: Requires version 2019.05]\n\n$preview is true, when in OpenCSG preview (F5). $preview is false, when in render (F6).\n\nThis can, for example, be used to reduce detail during preview to save time, without losing detail in the final rendered result:\n\n$fn = $preview ? 12 : 72;\nsphere(r = 1);\n\nNote that the render module does not affect $preview:\n\nrender(){\n    $fn = $preview ? 12 : 72;\n    sphere(r = 1);\n}\n\nAnother use could be to make the preview show an assembly view and the render generate just the printed parts laid out for printing.\n\nIf printed parts need extra features that are removed post printing, for example support for suspended holes, then the preview can omit these to show the finished part after post processing.\n\nWhen OpenSCAD is run from the command line $preview is only true when generating a PNG image with OpenCSG. It is false when generating STL, DXF and SVG files with CGAL. It is also false when generating CSG and ECHO files. This may or may not be what you want, but you can always override it on the command line like any other variable with the -D option.\n\nEcho module [edit | edit source]\n\nThe echo() module prints the contents to the compilation window (aka Console).  Useful for debugging code. Also see the String function str().\n\nNumeric values are rounded to 5 significant digits.\n\nIt can be handy to use 'variable=variable' as the expression to easily label the variables, see the example below.\n\nUsage examples:\n\nmy_h=50;\n my_r=100;\n echo(\"This is a cylinder with h=\", my_h, \" and r=\", my_r);\n echo(my_h=my_h,my_r=my_r); // shortcut\n cylinder(h=my_h, r=my_r);\n\nShows in the Console as\n\nECHO: \"This is a cylinder with h=\", 50, \" and r=\", 100\nECHO: my_h = 50, my_r = 100\n\nNote that the output will not have the extra double quotes and commas if converted to a string using str().\n\nRounding examples[edit | edit source]\n\nAn example for the rounding:\n\na=1.0;\nb=1.000002;\necho(a);\necho(b);\n\nif(a==b){ //while echoed the same, the values are still distinct \n    echo (\"a==b\");\n}else if(a>b){\n    echo (\"a>b\");\n}else if(a<b){\n    echo (\"a<b\");\n}else{\n    echo (\"???\");\n}\n\nShows in the Console as\n\nECHO: 1\nECHO: 1\nECHO: \"a<b\"\n\nSmall and large Numbers[edit | edit source]\n\nc=1000002;\nd=0.000002;\necho(c); //1e+06\necho(d); //2e-06\n\nHTML[edit | edit source]\n\nHTML output is not officially supported, however depending on the OpenSCAD version, some HTML tags were rendered in the console window.\n\nEcho function[edit | edit source]\n\n[Note: Requires version 2019.05]\n\nEcho can be used in expression context to print information while the function/expression is evaluated. The output is generated before the expression evaluation to allow debugging of recursive functions.\n\nExample\n\na = 3; b = 5;\n \n // echo() prints values before evaluating the expression\n r1 = echo(a, b) a * b; // ECHO: 3, 5\n \n // using let it's still easy to output the result\n r2 = let(r = 2 * a * b) echo(r) r; // ECHO: 30\n \n // use echo statement for showing results \n echo(r1, r2); // ECHO: 15, 30\n\nA more complex example shows how echo() can be used in both descending and ascending path of a recursive function. The result() helper function is a simple way to output the value of an expression after evaluation.\n\nExample printing both input values and result of recursive sum()\n\nv = [4, 7, 9, 12];\n function result(x) = echo(result = x) x;\n function sum(x, i = 0) = echo(str(\"x[\", i, \"]=\", x[i])) result(len(x) > i ? x[i] + sum(x, i + 1) : 0);\n echo(\"sum(v) = \", sum(v));\n \n // ECHO: \"x[0]=4\"\n // ECHO: \"x[1]=7\"\n // ECHO: \"x[2]=9\"\n // ECHO: \"x[3]=12\"\n // ECHO: \"x[4]=undef\"\n // ECHO: result = 0\n // ECHO: result = 12\n // ECHO: result = 21\n // ECHO: result = 28\n // ECHO: result = 32\n // ECHO: \"sum(v) = \", 32\n\nrender[edit | edit source]\n\nexample in preview\n\nrender() effects show edges\n\nForces the generation of a mesh even in preview mode. This is useful in certain situations, e.g. when the boolean operations become too slow to track.\n\nRender can also be used (typically in conjunction with convexity) to avoid/workaround preview artifacts.[1] See also OpenSCAD User Manual/FAQ#Why are some parts (e.g. holes) of the model not rendered correctly?\n\nUsage examples: (Needs description)\n\nrender(convexity = 2) difference() {\n cube([20, 20, 150], center = true);\n translate([-10, -10, 0])\n  cylinder(h = 80, r = 10, center = true);\n translate([-10, -10, +40])\n  sphere(r = 10);\n translate([-10, -10, -40])\n  sphere(r = 10);\n}\n\nsurface[edit | edit source]\n\nSurface reads Heightmap information from text or image files.\n\nParameters\n\nfile\nString. The path to the file containing the heightmap data.\n\ncenter\nBoolean.  This determines the positioning of the generated object.  If true, object is centered in X- and Y-axis.  Otherwise, the object is placed in the positive quadrant.  Defaults to false.\n\ninvert\nBoolean. Inverts how the color values of imported images are translated into height values. This has no effect when importing text data files. Defaults to false.: The geometry that results from using this parameter is positioned with its top in the z = 0 plane. A thin \"footprint\" layer, one unit thick, is added automatically just below the height map.:: [Note: Requires version 2015.03]\n\nconvexity\nInteger. The convexity parameter specifies the maximum number of front sides (back sides) a ray intersecting the object might penetrate. This parameter is only needed for correctly displaying the object in OpenCSG preview mode and has no effect on the final rendering.\n\nText file format[edit | edit source]\n\nThe format for text based height maps is a matrix of numbers which represent the heights for specific points. Rows are mapped in Y-axis direction, columns in X axis direction, with one unit increment between adjacent rows and columns.\nThe numbers must be separated by spaces or tabs. Empty lines and lines starting with a # character are ignored.\n\nImages[edit | edit source]\n\n[Note: Requires version 2015.03]\n\nCurrently only PNG images are supported. Alpha channel information of the image is ignored and the height for the pixel is determined by converting the color value to Grayscale using the linear luminance for the sRGB color space (Y = 0.2126R + 0.7152G + 0.0722B). The gray scale values are scaled to be in the range 0 to 100.\n\nA thin \"footprint\" layer, one unit thick, is added automatically just below the height map.\n\nExamples[edit | edit source]\n\nExample 1:\n\n//surface.scad\nsurface(file = \"surface.dat\", center = true, convexity = 5);\n%translate([0,0,5])cube([10,10,10], center = true);\n\n#surface.dat\n10 9 8 7 6 5 5 5 5 5 \n9 8 7 6 6 4 3 2 1 0 \n8 7 6 6 4 3 2 1 0 0\n7 6 6 4 3 2 1 0 0 0\n6 6 4 3 2 1 1 0 0 0\n6 6 3 2 1 1 1 0 0 0\n6 6 2 1 1 1 1 0 0 0\n6 6 1 0 0 0 0 0 0 0\n3 1 0 0 0 0 0 0 0 0\n3 0 0 0 0 0 0 0 0 0\n\nResult:\n\nExample 2\n\n// example010.dat generated using octave or matlab:\nd = (sin(1:0.2:10)' * cos(1:0.2:10)) * 10;\nsave(\"-ascii\", \"example010.dat\", \"d\");\n\n//original surface\nsurface(file = \"example010.dat\", center = true, convexity = 5);\n//rotated surface\ntranslate(v = [70, 0, 0]) rotate(45, [0, 0, 1]) surface(file = \"example010.dat\", center = true, convexity = 5);\n\n//intersection\ntranslate(v = [35, 60, 0])\nintersection() {\n    surface(file = \"example010.dat\", center = true, convexity = 5);\n    rotate(45, [0, 0, 1]) surface(file = \"example010.dat\", center = true, convexity = 5);\n}\n\nExample 3:\n\n[Note: Requires version 2015.03]\n\n// Example 3a\nscale([1, 1, 0.1])\n  surface(file = \"smiley.png\", center = true);\n\n// Example 3b\nscale([1, 1, 0.1])\n  surface(file = \"smiley.png\", center = true, invert = true);\n\nInput imageExample 3a: surface(invert = false)Example 3b: surface (invert = true)Example 3: Using surface() with a PNG image as heightmap input.\n\nExample 4:\n\n[Note: Requires version 2015.03]\n\n// Example 4\nsurface(file = \"BRGY-Grey.png\", center = true, invert = false);\n\nPNG Test File\n\t\t\n\t\t\n\t\t\t\n\t\t\t3D Surface\n\nsearch[edit | edit source]\n\nThe search() function is a general-purpose function to find one or more (or all) occurrences of a value or list of values in a vector, string or more complex list-of-list construct.\n\nSearch usage[edit | edit source]\n\nsearch( match_value , string_or_vector [, num_returns_per_match [, index_col_num ] ] );\n\nSearch arguments[edit | edit source]\n\nmatch_value\n\nCan be a single string value. Search loops over the characters in the string and searches for each one in the second argument. The second argument must be a string or a list of lists (this second case is not recommended). The search function does not search for substrings.\nCan be a single numerical value.\nCan be a list of values. The search function searches for each item on the list.\nTo search for a list or a full string give the list or string as a single element list such as [\"abc\"] to search for the string \"abc\" (See Example 9) or [[6,7,8]] to search for the list [6,7,8].  Without the extra brackets, search looks separately for each item in the list.\nIf match_value is boolean then search returns undef.\n\nstring_or_vector\n\nThe string or vector to search for matches.\nIf match_value is a string then this should be a string and the string is searched for individual character matches to the characters in match_value\nIf this is a list of lists, v=[[a0,a1,a2...],[b0,b1,b2,...],[c0,c1,c2,...],...] then search looks only at one index position of the sublists. By default this is position 0, so the search looks only at a0, b0, c0, etc.  The index_col_num parameter changes which index is searched.\nIf match_value is a string and this parameter is a list of lists then the characters of the string are tested against the appropriate index entry in the list of lists. However, if any characters fail to find a match a warning message is printed and that return value is excluded from the output (if num_returns_per_match is 1). This means that the length of the output is unpredictable.\n\nnum_returns_per_match (default: 1)\n\nBy default, search only looks for one match per element of match_value to return as a list of indices\nIf num_returns_per_match > 1, search returns a list of lists of up to num_returns_per_match index values for each element of match_value.\nSee Example 8 below.\nIf num_returns_per_match = 0, search returns a list of lists of all matching index values for each element of match_value.\nSee Example 6 below.\n\nindex_col_num (default: 0)\n\nAs noted above, when searching a list of lists, search looks only at one index position of each sublist.  That index position is specified by index_col_num.\nSee Example 5 below for a simple usage example.\n\nSearch usage examples[edit | edit source]\n\nSee example023.scad included with OpenSCAD for a renderable example.\n\nIndex values return as list[edit | edit source]\n\nExample\n\nCode\n\nResult\n\n\n\n1\n\n\n\nsearch(\"a\",\"abcdabcd\");\n\n\n\n[0]\n\n\n\n\n2\n\n\n\nsearch(\"e\",\"abcdabcd\");\n\n\n\n[]\n\n\n\n\n3\n\n\n\nsearch(\"a\",\"abcdabcd\",0);\n\n\n\n[[0,4]]\n\n\n\n\n4\n\n\n\ndata=[ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\nsearch(\"a\", data, num_returns_per_match=0);\n\n\n\n[[0,4]] (see also Example 6 below)\n\nSearch on different column; return Index values[edit | edit source]\n\nExample 5:\n\ndata= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",3] ];\n echo(search(3, data));    // Searches index 0, so it doesn't find anything\n echo(search(3, data, num_returns_per_match=0, index_col_num=1));\n\nOutputs:\n\nECHO: []\n ECHO: [2, 8]\n\nSearch on list of values[edit | edit source]\n\nExample 6:  Return all matches per search vector element.\n\ndata= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\n search(\"abc\", data, num_returns_per_match=0);\n\nReturns:\n\n[[0,4],[1,5],[2,6]]\n\nExample 7:  Return first match per search vector element; special case return vector.\n\ndata= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\n search(\"abc\", data, num_returns_per_match=1);\n\nReturns:\n\n[0,1,2]\n\nExample 8:  Return first two matches per search vector element; vector of vectors.\n\ndata= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\n search(\"abce\", data, num_returns_per_match=2);\n\nReturns:\n\n[[0,4],[1,5],[2,6],[8]]\n\nSearch on list of strings[edit | edit source]\n\nExample 9:\n\nlTable2=[ [\"cat\",1],[\"b\",2],[\"c\",3],[\"dog\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9],[\"apple\",10],[\"a\",11] ];\n lSearch2=[\"b\",\"zzz\",\"a\",\"c\",\"apple\",\"dog\"];\n l2=search(lSearch2,lTable2);\n echo(str(\"Default list string search (\",lSearch2,\"): \",l2));\n\nReturns\n\nECHO: \"Default list string search ([\"b\", \"zzz\", \"a\", \"c\", \"apple\", \"dog\"]): [1, [], 4, 2, 9, 3]\"\n\nGetting the right results[edit | edit source]\n\n// workout which vectors get the results\nv=[ [\"O\",2],[\"p\",3],[\"e\",9],[\"n\",4],[\"S\",5],[\"C\",6],[\"A\",7],[\"D\",8] ];\n//\necho(v[0]);\t\t\t\t\t// -> [\"O\",2]\necho(v[1]);                                     // -> [\"p\",3]\necho(v[1][0],v[1][1]);                          // -> \"p\",3\necho(search(\"p\",v));                            // find \"p\" -> [1]\necho(search(\"p\",v)[0]);                         // -> 1\necho(search(9,v,0,1));                          // find  9  -> [2] \necho(v[search(9,v,0,1)[0]]);                    // -> [\"e\",9]\necho(v[search(9,v,0,1)[0]][0]);                 // -> \"e\"\necho(v[search(9,v,0,1)[0]][1]);                 // -> 9\necho(v[search(\"p\",v,1,0)[0]][1]);               // -> 3\necho(v[search(\"p\",v,1,0)[0]][0]);               // -> \"p\"\necho(v[search(\"d\",v,1,0)[0]][0]);               // \"d\" not found -> undef\necho(v[search(\"D\",v,1,0)[0]][1]);               // -> 8\n\nOpenSCAD version [edit | edit source]\n\nversion() and version_num() returns the OpenSCAD version number.\n\nThe version() function returns the OpenSCAD version as a vector of three numbers, e.g. [2011, 9, 23]\nThe version_num() function returns the OpenSCAD version as a number, e.g. 20110923\n\nparent_module(n) and $parent_modules[edit | edit source]\n\n$parent_modules contains the number of modules in the instantiation stack.\nparent_module(i) returns the name of the module i levels above the current module in the instantiation stack.\nThe stack is independent of where the modules are defined. It's where they're instantiated that counts.\nThis can, for example, be used to build a BOM (Bill Of Material).\n\nExample:\n\nmodule top() {\n   children();\n }\n module middle() {\n   children();\n }\n top() middle() echo(parent_module(0)); // prints \"middle\"\n top() middle() echo(parent_module(1)); // prints \"top\"\n\nassert[edit | edit source]\n\n[Note: Requires version 2019.05]\n\nsee also Assertion (software development)\n\nAssert evaluates a logical expression. If the expression evaluates to false, the generation of the preview/render is stopped, and an error condition is reported via the console.  The report consists of a string representation of the expression and an additional string (optional) that is specified in the assert command.\n\nassert(condition);\n assert(condition, message);\n\nParameters\n\ncondition\nExpression. The expression to be evaluated as check for the assertion.\n\nmessage\nString. Optional message to be output in case the assertion failed.\n\nExample[edit | edit source]\n\nThe simplest example is a simple assert(false);, e.g. in a file named assert_example1.scad.\n\ncube();\nassert(false);\nsphere();\n  \n// ERROR: Assertion 'false' failed in file assert_example1.scad, line 2\n\nThis example has little use, but the simple assert(false); can be used in code sections that should be unreachable.\n\nChecking parameters[edit | edit source]\n\nA useful example is checking the validity of input parameters:\n\nmodule row(cnt = 3){\n    // Count has to be a positive integer greater 0\n    assert(cnt > 0);\n    for (i = [1 : cnt]) {\n        translate([i * 2, 0, 0]) sphere();\n    }\n}\n\nrow(0);\n\n// ERROR: Assertion '(cnt > 0)' failed in file assert_example2.scad, line 3\n\nAdding message[edit | edit source]\n\nWhen writing a library, it could be useful to output additional information to the user in case of an failed assertion.\n\nmodule row(cnt = 3){\n    assert(cnt > 0, \"Count has to be a positive integer greater 0\");\n    for(i = [1 : cnt]) {\n        translate([i * 2, 0, 0]) sphere();\n    }\n}\n\nrow(0);\n\n// ERROR: Assertion '(cnt > 0)': \"Count has to be a positive integer greater 0\" failed in file assert_example3.scad, line 2\n\nUsing assertions in function[edit | edit source]\n\nAssert returns its children, so when using it in a function you can write\n\nfunction f(a, b) =\n    assert(a < 0, \"wrong a\") // assert input\n    assert(b > 0, \"wrong b\") // assert input\n    let (c = a + b) // derive a new value from input\n    assert(c != 0, \"wrong c\") // assert derived value\n    a * b; // calculate\n\n↑ https://github.com/openscad/openscad/issues/4275",
      "content": {},
      "codeExamples": [
        {
          "code": "regular  = \"regular global\";\n$special = \"special global\";\nmodule show() echo(\"         in show    \", regular,\"   \", $special );\n\necho (\"         outside    \", regular,\"   \", $special );\n          // ECHO: \"         outside    \", \"regular global\", \"   \", \"special global\"\n  \nfor ( regular = [0:1] ){ echo(\"in regular loop     \", regular,\"   \", $special ); show();}\n          // ECHO: \"in regular loop     \", 0, \"   \", \"special global\"\n          // ECHO: \"         in show    \", \"regular global\", \"   \", \"special global\"\n          // ECHO: \"in regular loop     \", 1, \"   \", \"special global\"\n          // ECHO: \"         in show    \", \"regular global\", \"   \", \"special global\"\n\nfor ( $special = [5:6] ){ echo(\"in special loop     \", regular,\"   \", $special ); show();}\n          // ECHO: \"in special loop     \", \"regular global\", \"   \", 5\n          // ECHO: \"         in show    \", \"regular global\", \"   \", 5\n          // ECHO: \"in special loop     \", \"regular global\", \"   \", 6\n          // ECHO: \"         in show    \", \"regular global\", \"   \", 6\n\nshow();\n          // ECHO: \"         in show    \", \"regular global\", \"   \", \"special global\"",
          "context": "Special variables pass along their value from within the scope \n (see scope of variables)\nfrom which the module or function is called. \nThis means that special variables can potentially have a different value each time a module or function is called."
        },
        {
          "code": "$fn = $preview ? 32 : 64;",
          "context": "You can also use two different values for preview and render"
        },
        {
          "code": "int get_fragments_from_r(double r, double fn, double fs, double fa)\n      {\n             if (r < GRID_FINE) return 3;\n             if (fn > 0.0) return (int)(fn >= 3 ? fn : 3);\n             return (int)ceil(fmax(fmin(360.0 / fa, r*2*M_PI / fs), 5));\n      }",
          "context": "This is the C code that calculates the number of fragments in a circle:"
        },
        {
          "code": "echo(n=($fn>0?($fn>=3?$fn:3):ceil(max(min(360/$fa,r*2*PI/$fs),5))),a_based=360/$fa,s_based=r*2*PI/$fs);",
          "context": "Or you can embed this OpenSCAD version in your code to work out what's going on, you need to set r= to your size"
        },
        {
          "code": "$fs = 0.01;\n      sphere(2);",
          "context": "You can generate high resolution spheres by resetting the $fX values in\nthe instantiating module:"
        },
        {
          "code": "sphere(2, $fs = 0.01);",
          "context": "or simply by passing the special variable as parameter:"
        },
        {
          "code": "sphere(2, $fs = $fs * 0.01);",
          "context": "You can even scale the special variable instead of resetting it:"
        },
        {
          "code": "convert -delay 10 -loop 0 *.png myimage.gif",
          "context": "If \"Dump Pictures\" is checked, then images are created in the same directory as the .scad file. The exported PNG files can be turned into a gif via command line:"
        },
        {
          "code": "cube([10, 10, $vpr[0] / 10]);",
          "context": "$vpr shows rotation\n$vpt shows translation (i.e. won't be affected by rotate and zoom)\n$vpf shows the FOV (Field of View) of the view [Note: Requires version 2021.01]\n$vpd shows the camera distance [Note: Requires version 2015.03]"
        },
        {
          "code": "$vpr = [0, 0, $t * 360];",
          "context": "All four variables are writable, but only assignments at the top-level of the main file has an effect on the viewport. [Note: Requires version 2015.03]"
        },
        {
          "code": "$fn = $preview ? 12 : 72;\nsphere(r = 1);",
          "context": "This can, for example, be used to reduce detail during preview to save time, without losing detail in the final rendered result:"
        },
        {
          "code": "render(){\n    $fn = $preview ? 12 : 72;\n    sphere(r = 1);\n}",
          "context": "Note that the render module does not affect $preview:"
        },
        {
          "code": "my_h=50;\n my_r=100;\n echo(\"This is a cylinder with h=\", my_h, \" and r=\", my_r);\n echo(my_h=my_h,my_r=my_r); // shortcut\n cylinder(h=my_h, r=my_r);",
          "context": "No specific context available"
        },
        {
          "code": "ECHO: \"This is a cylinder with h=\", 50, \" and r=\", 100\nECHO: my_h = 50, my_r = 100",
          "context": "Shows in the Console as"
        },
        {
          "code": "a=1.0;\nb=1.000002;\necho(a);\necho(b);\n\nif(a==b){ //while echoed the same, the values are still distinct \n    echo (\"a==b\");\n}else if(a>b){\n    echo (\"a>b\");\n}else if(a<b){\n    echo (\"a<b\");\n}else{\n    echo (\"???\");\n}",
          "context": "No specific context available"
        },
        {
          "code": "ECHO: 1\nECHO: 1\nECHO: \"a<b\"",
          "context": "Shows in the Console as"
        },
        {
          "code": "c=1000002;\nd=0.000002;\necho(c); //1e+06\necho(d); //2e-06",
          "context": "No specific context available"
        },
        {
          "code": "a = 3; b = 5;\n \n // echo() prints values before evaluating the expression\n r1 = echo(a, b) a * b; // ECHO: 3, 5\n \n // using let it's still easy to output the result\n r2 = let(r = 2 * a * b) echo(r) r; // ECHO: 30\n \n // use echo statement for showing results \n echo(r1, r2); // ECHO: 15, 30",
          "context": "Echo can be used in expression context to print information while the function/expression is evaluated. The output is generated before the expression evaluation to allow debugging of recursive functions."
        },
        {
          "code": "v = [4, 7, 9, 12];\n function result(x) = echo(result = x) x;\n function sum(x, i = 0) = echo(str(\"x[\", i, \"]=\", x[i])) result(len(x) > i ? x[i] + sum(x, i + 1) : 0);\n echo(\"sum(v) = \", sum(v));\n \n // ECHO: \"x[0]=4\"\n // ECHO: \"x[1]=7\"\n // ECHO: \"x[2]=9\"\n // ECHO: \"x[3]=12\"\n // ECHO: \"x[4]=undef\"\n // ECHO: result = 0\n // ECHO: result = 12\n // ECHO: result = 21\n // ECHO: result = 28\n // ECHO: result = 32\n // ECHO: \"sum(v) = \", 32",
          "context": "Example printing both input values and result of recursive sum()"
        },
        {
          "code": "render(convexity = 2) difference() {\n cube([20, 20, 150], center = true);\n translate([-10, -10, 0])\n  cylinder(h = 80, r = 10, center = true);\n translate([-10, -10, +40])\n  sphere(r = 10);\n translate([-10, -10, -40])\n  sphere(r = 10);\n}",
          "context": "Usage examples: (Needs description)"
        },
        {
          "code": "//surface.scad\nsurface(file = \"surface.dat\", center = true, convexity = 5);\n%translate([0,0,5])cube([10,10,10], center = true);",
          "context": "Examples[edit | edit source]"
        },
        {
          "code": "#surface.dat\n10 9 8 7 6 5 5 5 5 5 \n9 8 7 6 6 4 3 2 1 0 \n8 7 6 6 4 3 2 1 0 0\n7 6 6 4 3 2 1 0 0 0\n6 6 4 3 2 1 1 0 0 0\n6 6 3 2 1 1 1 0 0 0\n6 6 2 1 1 1 1 0 0 0\n6 6 1 0 0 0 0 0 0 0\n3 1 0 0 0 0 0 0 0 0\n3 0 0 0 0 0 0 0 0 0",
          "context": "//surface.scad\nsurface(file = \"surface.dat\", center = true, convexity = 5);\n%translate([0,0,5])cube([10,10,10], center = true);"
        },
        {
          "code": "// example010.dat generated using octave or matlab:\nd = (sin(1:0.2:10)' * cos(1:0.2:10)) * 10;\nsave(\"-ascii\", \"example010.dat\", \"d\");",
          "context": "No specific context available"
        },
        {
          "code": "//original surface\nsurface(file = \"example010.dat\", center = true, convexity = 5);\n//rotated surface\ntranslate(v = [70, 0, 0]) rotate(45, [0, 0, 1]) surface(file = \"example010.dat\", center = true, convexity = 5);\n\n//intersection\ntranslate(v = [35, 60, 0])\nintersection() {\n    surface(file = \"example010.dat\", center = true, convexity = 5);\n    rotate(45, [0, 0, 1]) surface(file = \"example010.dat\", center = true, convexity = 5);\n}",
          "context": "// example010.dat generated using octave or matlab:\nd = (sin(1:0.2:10)' * cos(1:0.2:10)) * 10;\nsave(\"-ascii\", \"example010.dat\", \"d\");"
        },
        {
          "code": "// Example 3a\nscale([1, 1, 0.1])\n  surface(file = \"smiley.png\", center = true);",
          "context": "[Note: Requires version 2015.03]"
        },
        {
          "code": "// Example 3b\nscale([1, 1, 0.1])\n  surface(file = \"smiley.png\", center = true, invert = true);",
          "context": "// Example 3a\nscale([1, 1, 0.1])\n  surface(file = \"smiley.png\", center = true);"
        },
        {
          "code": "// Example 4\nsurface(file = \"BRGY-Grey.png\", center = true, invert = false);",
          "context": "[Note: Requires version 2015.03]"
        },
        {
          "code": "data= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",3] ];\n echo(search(3, data));    // Searches index 0, so it doesn't find anything\n echo(search(3, data, num_returns_per_match=0, index_col_num=1));",
          "context": "Search on different column; return Index values[edit | edit source]"
        },
        {
          "code": "ECHO: []\n ECHO: [2, 8]",
          "context": "data= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",3] ];\n echo(search(3, data));    // Searches index 0, so it doesn't find anything\n echo(search(3, data, num_returns_per_match=0, index_col_num=1));"
        },
        {
          "code": "data= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\n search(\"abc\", data, num_returns_per_match=0);",
          "context": "Example 6:  Return all matches per search vector element."
        },
        {
          "code": "[[0,4],[1,5],[2,6]]",
          "context": "data= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\n search(\"abc\", data, num_returns_per_match=0);"
        },
        {
          "code": "data= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\n search(\"abc\", data, num_returns_per_match=1);",
          "context": "Example 7:  Return first match per search vector element; special case return vector."
        },
        {
          "code": "[0,1,2]",
          "context": "data= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\n search(\"abc\", data, num_returns_per_match=1);"
        },
        {
          "code": "data= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\n search(\"abce\", data, num_returns_per_match=2);",
          "context": "Example 8:  Return first two matches per search vector element; vector of vectors."
        },
        {
          "code": "[[0,4],[1,5],[2,6],[8]]",
          "context": "data= [ [\"a\",1],[\"b\",2],[\"c\",3],[\"d\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9] ];\n search(\"abce\", data, num_returns_per_match=2);"
        },
        {
          "code": "lTable2=[ [\"cat\",1],[\"b\",2],[\"c\",3],[\"dog\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9],[\"apple\",10],[\"a\",11] ];\n lSearch2=[\"b\",\"zzz\",\"a\",\"c\",\"apple\",\"dog\"];\n l2=search(lSearch2,lTable2);\n echo(str(\"Default list string search (\",lSearch2,\"): \",l2));",
          "context": "Search on list of strings[edit | edit source]"
        },
        {
          "code": "ECHO: \"Default list string search ([\"b\", \"zzz\", \"a\", \"c\", \"apple\", \"dog\"]): [1, [], 4, 2, 9, 3]\"",
          "context": "lTable2=[ [\"cat\",1],[\"b\",2],[\"c\",3],[\"dog\",4],[\"a\",5],[\"b\",6],[\"c\",7],[\"d\",8],[\"e\",9],[\"apple\",10],[\"a\",11] ];\n lSearch2=[\"b\",\"zzz\",\"a\",\"c\",\"apple\",\"dog\"];\n l2=search(lSearch2,lTable2);\n echo(str(\"Default list string search (\",lSearch2,\"): \",l2));"
        },
        {
          "code": "// workout which vectors get the results\nv=[ [\"O\",2],[\"p\",3],[\"e\",9],[\"n\",4],[\"S\",5],[\"C\",6],[\"A\",7],[\"D\",8] ];\n//\necho(v[0]);\t\t\t\t\t// -> [\"O\",2]\necho(v[1]);                                     // -> [\"p\",3]\necho(v[1][0],v[1][1]);                          // -> \"p\",3\necho(search(\"p\",v));                            // find \"p\" -> [1]\necho(search(\"p\",v)[0]);                         // -> 1\necho(search(9,v,0,1));                          // find  9  -> [2] \necho(v[search(9,v,0,1)[0]]);                    // -> [\"e\",9]\necho(v[search(9,v,0,1)[0]][0]);                 // -> \"e\"\necho(v[search(9,v,0,1)[0]][1]);                 // -> 9\necho(v[search(\"p\",v,1,0)[0]][1]);               // -> 3\necho(v[search(\"p\",v,1,0)[0]][0]);               // -> \"p\"\necho(v[search(\"d\",v,1,0)[0]][0]);               // \"d\" not found -> undef\necho(v[search(\"D\",v,1,0)[0]][1]);               // -> 8",
          "context": "Getting the right results[edit | edit source]"
        },
        {
          "code": "module top() {\n   children();\n }\n module middle() {\n   children();\n }\n top() middle() echo(parent_module(0)); // prints \"middle\"\n top() middle() echo(parent_module(1)); // prints \"top\"",
          "context": "$parent_modules contains the number of modules in the instantiation stack.\nparent_module(i) returns the name of the module i levels above the current module in the instantiation stack.\nThe stack is independent of where the modules are defined. It's where they're instantiated that counts.\nThis can, for example, be used to build a BOM (Bill Of Material)."
        },
        {
          "code": "assert(condition);\n assert(condition, message);",
          "context": "Assert evaluates a logical expression. If the expression evaluates to false, the generation of the preview/render is stopped, and an error condition is reported via the console.  The report consists of a string representation of the expression and an additional string (optional) that is specified in the assert command."
        },
        {
          "code": "cube();\nassert(false);\nsphere();\n  \n// ERROR: Assertion 'false' failed in file assert_example1.scad, line 2",
          "context": "No specific context available"
        },
        {
          "code": "module row(cnt = 3){\n    // Count has to be a positive integer greater 0\n    assert(cnt > 0);\n    for (i = [1 : cnt]) {\n        translate([i * 2, 0, 0]) sphere();\n    }\n}\n\nrow(0);\n\n// ERROR: Assertion '(cnt > 0)' failed in file assert_example2.scad, line 3",
          "context": "No specific context available"
        },
        {
          "code": "module row(cnt = 3){\n    assert(cnt > 0, \"Count has to be a positive integer greater 0\");\n    for(i = [1 : cnt]) {\n        translate([i * 2, 0, 0]) sphere();\n    }\n}\n\nrow(0);\n\n// ERROR: Assertion '(cnt > 0)': \"Count has to be a positive integer greater 0\" failed in file assert_example3.scad, line 2",
          "context": "No specific context available"
        },
        {
          "code": "function f(a, b) =\n    assert(a < 0, \"wrong a\") // assert input\n    assert(b > 0, \"wrong b\") // assert input\n    let (c = a + b) // derive a new value from input\n    assert(c != 0, \"wrong c\") // assert derived value\n    a * b; // calculate",
          "context": "No specific context available"
        }
      ]
    }
  }
}